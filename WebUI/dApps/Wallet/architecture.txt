================================================================================
                   GRIDNET OS WALLET UI DAPP ARCHITECTURE
                         Comprehensive Documentation
================================================================================

Author:  Wizards
Last Updated: 2025-10-30

================================================================================
TABLE OF CONTENTS
================================================================================

1. Overview
2. System Architecture
3. Threading Mechanics in GRIDNET OS
4. Communication Protocols
5. Transaction Commit Flow
6. Headless Authentication
7. Key Components
8. Implementation Details
9. Critical Fixes and Improvements
10. Troubleshooting Guide
11. Identity Token Deployment

================================================================================
1. OVERVIEW
================================================================================

The Wallet UI dApp is a decentralized cryptocurrency wallet application for
GRIDNET OS. It provides comprehensive functionality for managing digital assets,
sending/receiving transactions, and interacting with the GRIDNET blockchain.

KEY FEATURES:
- Multi-account management with cryptographic keychains
- Send/receive transactions with real-time balance updates
- Transaction history with search and filtering
- Headless authentication (browser-based signing without mobile QR codes)
- Integration with GRIDNET OS threading system
- Real-time blockchain synchronization

CRITICAL ARCHITECTURAL PRINCIPLES:
1. The Wallet operates within the GRIDNET OS decentralized processing model
2. All commits require authentication and blockchain validation
3. Threading isolation prevents blocking and enables concurrent operations
4. Two-protocol system: DFS for commits, VM Meta Data for authentication


================================================================================
2. SYSTEM ARCHITECTURE
================================================================================

2.1 HIGH-LEVEL ARCHITECTURE
────────────────────────────────────────────────────────────────────────────

┌─────────────────────────────────────────────────────────────────────────┐
│                         WALLET UI DAPP                                  │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐  ┌─────────────┐ │
│  │              │  │              │  │              │  │             │ │
│  │  UI Layer    │◄─┤ Business     │◄─┤ Data Access  │◄─┤  Event      │ │
│  │              │  │ Logic Layer  │  │ Layer        │  │  Handlers   │ │
│  │              │  │              │  │              │  │             │ │
│  └──────────────┘  └──────────────┘  └──────────────┘  └─────────────┘ │
└────────────────────────────────────────────┬────────────────────────────┘
                                             │
                                             ▼
┌─────────────────────────────────────────────────────────────────────────┐
│                         CVMContext (VM Context Manager)                  │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐  ┌─────────────┐ │
│  │              │  │              │  │              │  │             │ │
│  │  API         │◄─┤  Threading   │◄─┤  Network     │◄─┤  Keychain   │ │
│  │  Interface   │  │  Manager     │  │  Manager     │  │  Manager    │ │
│  │              │  │              │  │              │  │             │ │
│  └──────────────┘  └──────────────┘  └──────────────┘  └─────────────┘ │
└────────────────────────────────────────────┬────────────────────────────┘
                                             │
                    ┌────────────────────────┴────────────────────────┐
                    │                                                 │
                    ▼                                                 ▼
┌────────────────────────────────┐        ┌────────────────────────────────┐
│   WebSocket Connection         │        │    DFS Protocol                │
│   (VM Meta Data Protocol)      │        │    (Commit Protocol)           │
└────────────────┬───────────────┘        └────────────┬───────────────────┘
                 │                                     │
                 └─────────────┬───────────────────────┘
                               │
                               ▼
┌─────────────────────────────────────────────────────────────────────────┐
│                      GRIDNET CORE NODE                                  │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐  ┌─────────────┐ │
│  │ CConversation│  │ GridScript   │  │ Transaction  │  │ Blockchain  │ │
│  │ (WebSocket   │◄─┤ VM           │◄─┤ Manager      │◄─┤ Manager     │ │
│  │  Handler)    │  │              │  │              │  │             │ │
│  └──────────────┘  └──────────────┘  └──────────────┘  └─────────────┘ │
└─────────────────────────────────────────────────────────────────────────┘


2.2 COMPONENT RELATIONSHIPS
────────────────────────────────────────────────────────────────────────────

Browser (Wallet dApp)                    GRIDNET Core Node
─────────────────────                    ─────────────────

┌──────────────────┐                    ┌──────────────────┐
│  Wallet.js       │                    │ CConversation    │
│                  │                    │ (WebSocket)      │
│  - UI State      │◄──────────────────►│                  │
│  - Balance       │   WebSocket        │ - Message Router │
│  - Transactions  │   Connection       │ - Protocol Mgr   │
└────────┬─────────┘                    └────────┬─────────┘
         │                                       │
         │                                       │
         ▼                                       ▼
┌──────────────────┐                    ┌──────────────────┐
│  CVMContext      │                    │ GridScript VM    │
│                  │                    │                  │
│  - Threading     │◄──────────────────►│ - System Thread  │
│  - Network       │   VM Meta Data     │ - Data Thread    │
│  - Keychains     │   + DFS Protocols  │ - User Threads   │
└────────┬─────────┘                    └────────┬─────────┘
         │                                       │
         │                                       │
         ▼                                       ▼
┌──────────────────┐                    ┌──────────────────┐
│ CKeyChainManager │                    │ CTransactionMgr  │
│                  │                    │                  │
│  - Sign Auth     │◄──────────────────►│ - Validate TX    │
│  - Store Keys    │   Authentication   │ - Register TX    │
│  - Auto-detect   │   Response         │ - Pre-validate   │
└──────────────────┘                    └──────────────────┘


================================================================================
3. THREADING MECHANICS IN GRIDNET OS
================================================================================

3.1 THREAD TYPES AND PURPOSES
────────────────────────────────────────────────────────────────────────────

GRIDNET OS uses a sophisticated threading model for decentralized processing.
Understanding threads is CRITICAL for working with the Wallet.

┌──────────────────────────────────────────────────────────────────────────┐
│                      GRIDNET OS THREAD TYPES                             │
└──────────────────────────────────────────────────────────────────────────┘

1. SYSTEM THREAD ("system")
   ──────────────────────────
   Purpose: Main thread for all commit operations
   Access: Indirect only (via CVMContext.proposeCode())
   Lifecycle: Created automatically when Wallet initializes
   Thread ID: System-assigned unique identifier

   CRITICAL PROPERTIES:
   - ALL blockchain commits MUST execute on system thread
   - Automatically set as "committable" at all times
   - Cannot be accessed directly by user-mode applications
   - Required for Magic Button commit operations

   USAGE IN WALLET:
   - Transaction commits (sendOnChainTransaction)
   - Balance updates requiring state changes
   - Any operation that modifies blockchain state

   CODE EXAMPLE:
   ```javascript
   // Wallet ensures system thread is available before commit
   let systemThreadID = this.mVMContext.getSystemThreadID;
   if (!systemThreadID || systemThreadID.byteLength === 0) {
       const wakeResult = await this.mVMContext.wakeThreadA(
           new ArrayBuffer(0), this, 30000
       );
       systemThreadID = this.mVMContext.getSystemThreadID;
   }
   ```

2. DATA THREAD ("data")
   ────────────────────
   Purpose: Read-only operations, data queries
   Access: Shared across all applications
   Lifecycle: Created automatically
   Thread ID: Named "data"

   CRITICAL PROPERTIES:
   - Read-only operations ONLY
   - Can be used during pending commits (non-blocking)
   - Shared resource across all dApps
   - Cannot be marked as committable

   USAGE IN WALLET:
   - Balance queries (retrieveBalance)
   - Transaction history (loadTransactionHistory)
   - Domain lookups
   - Any read-only blockchain queries

   CODE EXAMPLE:
   ```javascript
   // Wallet uses data thread for balance queries
   this.mVMContext.processGridScriptA(
       `balance ${address}`,
       eVMMetaCodeExecutionMode.RAW,
       'data'  // Use data thread for read-only operation
   );
   ```

3. USER-DEFINED THREADS (custom IDs)
   ──────────────────────────────────
   Purpose: Parallel, isolated transaction formulation
   Access: Created via CVMContext.createThreadA()
   Lifecycle: Application-managed
   Thread ID: User-specified

   CRITICAL PROPERTIES:
   - Private to creating application (unless marked public)
   - Can be made committable (via 'rt' command)
   - Can be committed individually or in bulk
   - Useful for concurrent operation isolation

   USAGE IN WALLET:
   - Currently not extensively used
   - Future: Batch transaction formulation
   - Future: Parallel transaction preparation

   CODE EXAMPLE:
   ```javascript
   // Create private thread for isolated transaction
   const threadID = this.mTools.stringToBytes('tx-batch-1');
   await this.mVMContext.createThreadA(
       threadID,
       eVMFlags.private,  // Private to this dApp
       this
   );
   ```


3.2 THREAD LIFECYCLE AND STATE MANAGEMENT
────────────────────────────────────────────────────────────────────────────

THREAD STATES:
┌─────────────────────────────────────────────────────────────────────────┐
│                          Thread State Machine                            │
└─────────────────────────────────────────────────────────────────────────┘

    [NOT CREATED]
         │
         │ createThreadA() or auto-created
         ▼
    [INITIALIZING] ────► [INITIALIZATION FAILED]
         │                      (notify user)
         │ VM ready notification
         ▼
    [ACTIVE/READY]
         │
         ├──► [EXECUTING CODE] ──► [WAITING FOR DATA]
         │           │                     │
         │           │                     │ Data arrives
         │           │◄────────────────────┘
         │           │
         │           ▼
         │      [COMMITTABLE] (after 'rt' command)
         │           │
         │           │ 'ct' command
         │           ▼
         │      [COMMITTING] ──► [COMMIT FAILED]
         │           │                  (rollback)
         │           │
         │           ▼
         │      [COMMITTED]
         │
         │ freeThread()
         ▼
    [TERMINATED]


THREAD STATE MONITORING IN WALLET:
```javascript
// Wallet subscribes to thread state changes
this.mVMContext.addVMStateChangedListener(
    this.onVMStateChanged.bind(this),
    this.getProcessID
);

onVMStateChanged(vmState) {
    const threadID = vmState.getThreadID;
    const state = vmState.getState;

    switch (state) {
        case eVMState.ready:
            // Thread ready for operations
            console.log('Thread ready:', threadID);
            break;
        case eVMState.committable:
            // Thread marked as ready to commit
            console.log('Thread committable:', threadID);
            break;
        case eVMState.committed:
            // Thread successfully committed
            console.log('Thread committed:', threadID);
            break;
    }
}
```


3.3 DETACHED PROCESSING AND NATIVE THREADS
────────────────────────────────────────────────────────────────────────────

CRITICAL CONCEPT: Detached processing prevents WebSocket thread blocking.

PROBLEM WITHOUT DETACHED PROCESSING:
┌─────────────────────────────────────────────────────────────────────────┐
│                     WebSocket Thread (BLOCKED) ❌                       │
├─────────────────────────────────────────────────────────────────────────┤
│ 1. Browser → DFS requestCommit                                          │
│ 2. handleProcessDFSMsg() executes 'ct' command                          │
│ 3. commitThreads() sends QRIntentAuth request                           │
│ 4. ⏸️  BLOCKS waiting for auth response                                 │
│                                                                         │
│ ❌ WebSocket thread blocked → Cannot receive auth data → DEADLOCK!      │
└─────────────────────────────────────────────────────────────────────────┘

SOLUTION WITH DETACHED PROCESSING:
┌─────────────────────────────────────────────────────────────────────────┐
│                  WebSocket Thread (NON-BLOCKING) ✅                      │
├─────────────────────────────────────────────────────────────────────────┤
│ 1. Browser → DFS requestCommit                                          │
│ 2. handleProcessDFSMsg() spawns NATIVE THREAD                           │
│ 3. WebSocket thread RETURNS IMMEDIATELY ✅                              │
└─────────────────────────────────────────────────────────────────────────┘
                               │
                               ▼
┌─────────────────────────────────────────────────────────────────────────┐
│                    Native Thread (DETACHED) ✅                          │
├─────────────────────────────────────────────────────────────────────────┤
│ 1. Executes 'ct' command                                                │
│ 2. commitThreads() sends QRIntentAuth                                   │
│ 3. ⏸️  Blocks waiting for auth (WebSocket thread is FREE)               │
└─────────────────────────────────────────────────────────────────────────┘
                               │
                               ▼
┌─────────────────────────────────────────────────────────────────────────┐
│             Browser (WebSocket thread is responsive) ✅                 │
├─────────────────────────────────────────────────────────────────────────┤
│ 1. Receives QRIntentAuth request                                        │
│ 2. Signs with keychain                                                  │
│ 3. Sends auth response via WebSocket ✅                                 │
└─────────────────────────────────────────────────────────────────────────┘
                               │
                               ▼
┌─────────────────────────────────────────────────────────────────────────┐
│                    Native Thread (RESUMED) ✅                           │
├─────────────────────────────────────────────────────────────────────────┤
│ 1. Receives auth data                                                   │
│ 2. Validates signature                                                  │
│ 3. Commits to blockchain                                                │
│ 4. Sends DFS commitSuccess ✅                                           │
└─────────────────────────────────────────────────────────────────────────┘


IMPLEMENTATION IN GRIDNET CORE:
```cpp
// In CConversation::handleProcessDFSMsg (conversation.cpp:8184-8234)

if (requiresDetachedProcessing) {
    // Check if thread already has native thread attached
    size_t nativeThreadsCount = targetThread->getNativeThreadCount();

    if (!nativeThreadsCount) {
        // Spawn native thread for detached processing
        targetThread->addNativeThread(
            std::make_shared<std::thread>(
                std::bind(&SE::CScriptEngine::processScript, targetThread,
                    cmd,                      // "ct" command
                    ...,
                    msg->getRequestID(),      // metaRequestID
                    true,                     // detachedProcessing flag
                    false                     // excuseERGusage
                )
            )
        );
    } else {
        // Abort existing thread and spawn new one
        targetThread->quitCurrentApp();
        targetThread->abortCurrentVMTask();
    }

    // Return immediately - WebSocket thread is FREE
    return true;
}
```


================================================================================
4. COMMUNICATION PROTOCOLS
================================================================================

4.1 DUAL-PROTOCOL ARCHITECTURE
────────────────────────────────────────────────────────────────────────────

GRIDNET OS uses TWO distinct protocols for different purposes:

┌──────────────────────────────────────────────────────────────────────────┐
│                    DFS PROTOCOL (Decentralized File System)              │
├──────────────────────────────────────────────────────────────────────────┤
│ PURPOSE: Blockchain operations, commits, file operations                 │
│ ROUTING: Thread-aware (by threadID), NOT process-aware                   │
│ MESSAGE TYPE: CDFSMsg                                                    │
│ USED FOR:                                                                │
│   • Commit requests (eDFSCmdType::requestCommit)                         │
│   • Commit results (commitSuccess, commitAborted, error)                 │
│   • File operations (readFile, writeFile, readDir)                       │
│   • Sync operations                                                      │
└──────────────────────────────────────────────────────────────────────────┘

┌──────────────────────────────────────────────────────────────────────────┐
│              VM META DATA EXCHANGE PROTOCOL                              │
├──────────────────────────────────────────────────────────────────────────┤
│ PURPOSE: GridScript execution, data requests, authentication             │
│ ROUTING: Process-aware AND thread-aware (processID + threadID/vmID)      │
│ MESSAGE TYPE: CVMMetaData (BER-encoded)                                  │
│ USED FOR:                                                                │
│   • GridScript code execution                                            │
│   • QRIntentAuth requests (authentication)                               │
│   • Data responses (signature, publicKey)                                │
│   • VM status notifications                                              │
└──────────────────────────────────────────────────────────────────────────┘


4.2 DFS PROTOCOL DETAILS
────────────────────────────────────────────────────────────────────────────

MESSAGE STRUCTURE:
```
CDFSMsg:
  - mType: eDFSCmdType (requestCommit, commitSuccess, etc.)
  - mThreadID: Target thread identifier
  - mRequestID: Request correlation ID
  - mData1: Primary data (BER-encoded VM Meta Data)
  - mData2: Secondary data (Receipt ID, error messages)
  - mFlags: Operation flags (suspendThrows, etc.)
```

KEY DFS MESSAGE TYPES USED IN WALLET:

1. eDFSCmdType::requestCommit
   ───────────────────────────
   Direction: Browser → GRIDNET Core
   Purpose: Request blockchain commit
   Data1: Empty
   Data2: Empty
   ThreadID: System thread ID

   CODE EXAMPLE:
   ```javascript
   // In FileSystem.js:166-182
   let cmd = new CDFSMsg(eDFSCmdType.requestCommit, threadID);
   cmd.setRequestID = result.getReqID;
   CVMContext.getInstance().sendDFSMsg(cmd, breakCommit);
   ```

2. eDFSCmdType::commitSuccess
   ───────────────────────────
   Direction: GRIDNET Core → Browser
   Purpose: Notify successful commit
   Data1: BER-encoded VM Meta Data (optional)
   Data2: Receipt ID (base58-encoded transaction hash)
   ThreadID: Committing thread ID

   CRITICAL: Must set threadID for Wallet to receive!

   CODE EXAMPLE (GRIDNET Core):
   ```cpp
   // In CScriptEngine::notifyCommitStatus (scriptengine.cpp:8806)
   std::shared_ptr<CDFSMsg> dfsMsg = std::make_shared<CDFSMsg>(commitSuccess);
   dfsMsg->setRequestID(getMetaRequestID());
   dfsMsg->setThreadID(getID());  // CRITICAL: Set threadID!
   dfsMsg->setData2(mTools->stringToBytes(receiptID));
   ```

3. eDFSCmdType::commitAborted
   ───────────────────────────
   Direction: GRIDNET Core → Browser
   Purpose: Notify commit failure
   Data1: Error message
   Data2: Empty
   ThreadID: Failed thread ID

4. eDFSCmdType::error
   ──────────────────
   Direction: GRIDNET Core → Browser
   Purpose: Notify error during operation
   Data1: Error message
   Data2: Empty


DFS MESSAGE FILTERING IN WALLET:
```javascript
// In wallet.js:12179-12224
onDFSMessage(dfsMsg) {
    // Filter by system thread ID (CRITICAL!)
    const systemThreadID = this.mVMContext.getSystemThreadID;

    if (!this.mTools.compareByteVectors(systemThreadID, dfsMsg.getThreadID)) {
        return; // Not our thread - ignore
    }

    switch (dfsMsg.getType) {
        case eDFSCmdType.commitSuccess:
            const receiptID = this.mTools.arrayBufferToString(dfsMsg.getData2);
            this.updateTransactionStatus('success', receiptID);
            break;

        case eDFSCmdType.commitAborted:
            const errorMsg = this.mTools.arrayBufferToString(dfsMsg.getData1);
            this.updateTransactionStatus('error', `Commit aborted: ${errorMsg}`);
            break;
    }
}
```


4.3 VM META DATA PROTOCOL DETAILS
────────────────────────────────────────────────────────────────────────────

MESSAGE STRUCTURE:
```
CVMMetaData:
  - Sections: Array of CVMMetaSection
    - Type: eVMMetaSectionType (requests, notifications, responses)
    - Entries: Array of CVMMetaEntry
      - Type: eVMMetaEntryType (dataRequest, dataResponse, code, etc.)
      - ReqID: Request correlation ID
      - ProcessID: Target process identifier
      - VMID: Target VM/thread identifier
      - Fields: Array of data fields (signature, publicKey, etc.)
```

KEY VM META DATA TYPES USED IN WALLET:

1. eDataRequestType::QRIntentAuth
   ───────────────────────────────
   Direction: GRIDNET Core → Browser
   Purpose: Request authentication for commit
   Section: eVMMetaSectionType::requests
   Entry: eVMMetaEntryType::dataRequest
   Fields: QRIntent data (serialized)

   GRIDNET CORE SENDS:
   ```cpp
   // In commitThreads() when authentication needed
   mMetaGenerator->beginSection(eVMMetaSectionType::requests);
   mMetaGenerator->addDataRequest(
       eDataRequestType::QRIntentAuth,
       serializedQR,           // QRIntent with dataToSign
       getMetaRequestID(),     // Request ID for correlation
       getID()                 // VM ID (thread ID)
   );
   ```

2. eVMMetaEntryType::dataResponse
   ───────────────────────────────
   Direction: Browser → GRIDNET Core
   Purpose: Provide authentication data
   Section: eVMMetaSectionType::notifications
   Entry: eVMMetaEntryType::dataResponse
   Fields: [signature (ArrayBuffer), publicKey (ArrayBuffer)]

   BROWSER SENDS:
   ```javascript
   // In CKeyChainManager.js:1388-1394
   const responseData = {
       reqID: reqID,
       processID: processID,
       type: eUITTaskType.response,
       dataType: eDataRequestType.QRIntentAuth,
       dataFields: [signature, publicKey]  // MUST be in this order!
   };
   this.mVMContext.registerUserDataResponse(responseData);
   ```

3. VM Status Notifications
   ────────────────────────
   Direction: GRIDNET Core → Browser
   Purpose: Notify VM state changes
   Section: eVMMetaSectionType::notifications
   Entry: eVMMetaEntryType::vmStatus
   Fields: State information

   Used for:
   - Thread ready notifications
   - Thread committable notifications
   - Thread committed notifications


4.4 PROTOCOL INTERACTION EXAMPLE
────────────────────────────────────────────────────────────────────────────

Complete flow for a Wallet transaction:

STEP 1: Transaction Preparation (VM Meta Data)
```
Browser → GRIDNET Core [VM Meta Data]
  Command: "send 100 GBU to user@domain.grid"
  Mode: eVMMetaCodeExecutionMode.GUI
  Thread: system

GRIDNET Core → Browser [VM Meta Data]
  Status: Code executed successfully
  Result: Transaction prepared in ephemeral mode
```

STEP 2: Commit Request (DFS)
```
Browser → GRIDNET Core [DFS]
  Type: eDFSCmdType::requestCommit
  ThreadID: system thread ID
  RequestID: 12345

GRIDNET Core:
  - Spawns native thread (detached processing)
  - WebSocket thread returns immediately ✅
```

STEP 3: Authentication Request (VM Meta Data)
```
GRIDNET Core → Browser [VM Meta Data]
  Native Thread sends:
    Type: eDataRequestType::QRIntentAuth
    ReqID: 12345
    Data: QRIntent with transaction hash to sign
```

STEP 4: Authentication Response (VM Meta Data)
```
Browser → GRIDNET Core [VM Meta Data]
  Type: eVMMetaEntryType::dataResponse
  ReqID: 12345
  Fields: [signature, publicKey]

GRIDNET Core:
  - Native thread receives auth data
  - Validates signature
  - Commits to blockchain
```

STEP 5: Commit Result (DFS)
```
GRIDNET Core → Browser [DFS]
  Type: eDFSCmdType::commitSuccess
  ThreadID: system thread ID
  RequestID: 12345
  Data2: Receipt ID (transaction hash)

Browser:
  - Wallet receives notification
  - Shows success with Receipt ID
  - Updates balance and history
```


================================================================================
5. TRANSACTION COMMIT FLOW
================================================================================

5.1 END-TO-END COMMIT SEQUENCE
────────────────────────────────────────────────────────────────────────────

┌──────────────────────────────────────────────────────────────────────────┐
│           COMPLETE TRANSACTION COMMIT FLOW (HEADLESS MODE)               │
└──────────────────────────────────────────────────────────────────────────┘

BROWSER SIDE (Wallet dApp)          |  GRIDNET CORE SIDE
────────────────────────────────────┼──────────────────────────────────────

1. USER INITIATES TRANSACTION
   ───────────────────────────
   User clicks "Send"
   ↓
   wallet.js:sendOnChainTransaction()
   ↓
   Validates inputs
   Checks system thread


2. PREPARE TRANSACTION CODE
   ────────────────────────
   Format GridScript command:
   "send 100 GBU to addr..."
   ↓
   CVMContext.proposeCode()         →  CConversation receives
   ↓                                    ↓
   VM Meta Data protocol                processVMMetaDataMsg()
                                        ↓
                                        System thread executes code
                                        ↓
                                        Transaction prepared (ephemeral)


3. REQUEST COMMIT
   ──────────────
   CVMContext.commit()              →  CConversation receives
   ↓                                    ↓
   FileSystem.doCommit()                handleProcessDFSMsg()
   ↓                                    ↓
   Sends DFS requestCommit              Detects requiresDetachedProcessing
   ThreadID: system                     ↓
   RequestID: 67890                     Spawns NATIVE THREAD
                                        ↓
                                        WebSocket thread RETURNS ✅

                                        ┌─────────────────────────────┐
                                        │ NATIVE THREAD (Detached)    │
                                        ├─────────────────────────────┤
                                        │ Executes 'ct' command       │
                                        │ ↓                           │
                                        │ commitThreads()             │
                                        │ ↓                           │
                                        │ Compiles transaction        │
                                        │ ↓                           │
                                        │ validateTransactionSemantics│
                                        │ ↓                           │
                                        │ preValidateTransaction      │
                                        │   - Check ERG               │
                                        │   - Check signature format  │
                                        │   - Check balance           │
                                        │   - Check nonce             │
                                        │ ↓                           │
                                        │ Needs authentication...     │
                                        └─────────────────────────────┘


4. AUTHENTICATION REQUEST
   ──────────────────────
                                    ←  Native thread sends
   CVMContext receives                  QRIntentAuth via
   QRIntentAuth request                 VM Meta Data protocol
   ↓                                    ↓
   processVMMetaDataRequest()           Sets: getIsWaitingForVMMetaData()
   ↓                                    ↓
   Detects QRIntentAuth                 Native thread BLOCKS ⏸️
   ↓                                    (WebSocket still responsive!)
   CKeyChainManager.
     signAuthenticationRequest()
   ↓


5. BROWSER SIGNS TRANSACTION
   ─────────────────────────
   Gets active keychain
   ↓
   Signs transaction hash
   ↓
   Prepares response:
     dataFields: [signature, publicKey]
   ↓
   CVMContext.registerUserDataResponse()


6. AUTHENTICATION RESPONSE
   ───────────────────────
   Sends VM Meta Data response      →  WebSocket thread receives
   dataType: QRIntentAuth               ↓
   fields: [sig, pubKey]                handleProcessVMMetaDataMsg()
   reqID: 67890                         ↓
                                        getTaskByMetaReqID() → null
                                        ↓
                                        FALLBACK: Iterate all VMs
                                        ↓
                                        Find VM with
                                          getIsWaitingForVMMetaData()
                                        ↓
                                        targetVM->setVMMetaDataResponse()

                                        ┌─────────────────────────────┐
                                        │ NATIVE THREAD (Resumed)     │
                                        ├─────────────────────────────┤
                                        │ Receives auth data ✅       │
                                        │ ↓                           │
                                        │ Validates signature         │
                                        │ ↓                           │
                                        │ Applies to transaction      │
                                        │ ↓                           │
                                        │ registerTransaction()       │
                                        │ ↓                           │
                                        │ Transaction in mempool      │
                                        │ ↓                           │
                                        │ notifyCommitStatus(success) │
                                        └─────────────────────────────┘


7. COMMIT RESULT NOTIFICATION
   ──────────────────────────
   CVMContext.processDFSMsg()       ←  Native thread sends
   ↓                                    DFS commitSuccess
   Wallet.onDFSMessage()                ThreadID: system
   ↓                                    RequestID: 67890
   Filters by threadID                  Data2: Receipt ID
   ↓
   updateTransactionStatus('success')
   ↓
   Display Receipt ID
   ↓
   Play success sound
   ↓
   Refresh balance (after 2s)
   ↓
   Refresh history (after 3s)


5.2 CRITICAL VALIDATION STEPS
────────────────────────────────────────────────────────────────────────────

GRIDNET Core performs TWO levels of validation:

LEVEL 1: Semantic Validation (validateTransactionSemantics)
────────────────────────────────────────────────────────────
Location: Before pre-validation
Checks:
  - Transaction structure is well-formed
  - Code compiles successfully
  - Basic syntax checks

CODE:
```cpp
RUNTIME_ERROR_IF(!mTools->validateTransactionSemantics(t),
    "Invalid final transaction semantics.");
```

LEVEL 2: Pre-Validation (CTransactionManager::preValidateTransaction)
──────────────────────────────────────────────────────────────────────
Location: After semantic validation, before registration
Checks:
  - Public key matches issuer address (eTransactionValidationResult::pubNotMatch)
  - Sufficient ERG available (insufficientERG)
  - ERG bid meets minimum (ERGBidTooLow)
  - Valid signature (invalidSig)
  - ID token present (noIDToken)
  - Valid nonce (invalidNonce)
  - Not forked out (forkedOut)
  - Consistent data (incosistentData)
  - Valid sacrifice (if applicable) (invalidSacrifice)

CODE:
```cpp
uint64_t currentKeyHeight = targetBlockchain->getKeyHeight();
std::shared_ptr<CTransaction> transPtr = std::make_shared<CTransaction>(t);

eTransactionValidationResult validationResult =
    targetBlockchain->getTransactionManager()->preValidateTransaction(
        transPtr, currentKeyHeight, nullptr
    );

switch (validationResult) {
    case eTransactionValidationResult::valid:
        break; // Continue to registration
    case eTransactionValidationResult::insufficientERG:
        RUNTIME_ERROR("Transaction validation failed: Insufficient ERG.");
        break;
    // ... (all other error cases)
}
```

ONLY if validation result is 'valid', proceed to:
```cpp
targetBlockchain->getFormationFlowManager()->registerTransaction(t, receiptID);
```


5.3 MAGIC BUTTON MECHANICS
────────────────────────────────────────────────────────────────────────────

The Magic Button is GRIDNET OS's universal commit mechanism.

MAGIC BUTTON STATES:
┌─────────────────────────────────────────────────────────────────────────┐
│ State          │ Meaning                    │ User Action             │
├────────────────┼────────────────────────────┼─────────────────────────┤
│ ready          │ No pending operations      │ Click for sync          │
│ pending        │ Operations queued          │ Click to commit         │
│ committing     │ Commit in progress         │ Wait...                 │
│ syncing        │ Sync in progress           │ Wait...                 │
│ error          │ Operation failed           │ Review error            │
└─────────────────────────────────────────────────────────────────────────┘

CONSENSUS TASK QUEUE:
The Magic Button manages a queue of consensus tasks:

```javascript
// Wallet adds transaction to consensus task queue
const task = new CConsensusTask("Send 100 GBU");
this.mVMContext.addConsensusTask(task);

// Magic Button commits when clicked
if (immediateDispatch) {
    this.mVMContext.getMagicButton.commitActions();
}
```

COMMIT FLOW:
```javascript
// In MagicButton.js:490-530
commitActions() {
    // Lock commit to prevent concurrent commits
    this.mVMContext.tryLockCommit(this, true);

    // Request commit via DFS protocol
    let result = this.mVMContext.commit(this, true, systemThreadID);

    if (result.getStatus == eOperationStatus.failure) {
        this.setState = eMagicButtonState.error;
    } else {
        this.setRecentOperationID = result.getReqID;
        // Wait for commit result via DFS notification
    }
}
```


5.4 TRANSACTION BROADCASTING MODES
────────────────────────────────────────────────────────────────────────────

The Wallet UI dApp supports TWO distinct modes for broadcasting on-chain
transactions, each with different trust assumptions and threat models:

┌──────────────────────────────────────────────────────────────────────────┐
│                    TRANSACTION BROADCASTING MODES                         │
├──────────────────────────────────────────────────────────────────────────┤
│                                                                           │
│  MODE 1: DECENTRALIZED THREADS API (Remote Compilation)                  │
│  ─────────────────────────────────────────────────────────────           │
│  • GridScript compiled remotely by GRIDNET Core                          │
│  • Transaction signed in browser (headless) or mobile (QR)               │
│  • Server controls transaction logic via code compilation                │
│  • Requires trust in GRIDNET Core's compilation process                  │
│                                                                           │
│  MODE 2: LOCAL TRANSACTION GENERATION (Trustless)                        │
│  ────────────────────────────────────────────────────────               │
│  • GridScript compiled locally in browser                                │
│  • Transaction signed locally in browser                                 │
│  • Pre-compiled bytecode submitted to blockchain                         │
│  • Zero trust required - full user control                               │
│                                                                           │
└──────────────────────────────────────────────────────────────────────────┘


5.4.1 MODE 1: DECENTRALIZED THREADS API (Remote Compilation)
────────────────────────────────────────────────────────────────────────────

This is the traditional mode where GRIDNET Core compiles and manages
transactions via the Decentralized Threads API.

SEQUENCE OF EVENTS:
───────────────────

BROWSER SIDE                          |  GRIDNET CORE SIDE
──────────────────────────────────────┼─────────────────────────────────────

1. USER ACTION
   User clicks "Send"
   ↓
   Wallet validates inputs
   ↓

2. BUILD GRIDSCRIPT SOURCE
   Format command sequence:
   ```
   bt
   txconfig -setbid <ERG_BID>
   txconfig -setlimit <ERG_LIMIT>
   cd /<DOMAIN>
   send <ADDRESS> <AMOUNT>
   rt
   ```
   ↓

3. PROPOSE CODE
   CVMContext.proposeCode()          →  CConversation receives
   ↓                                     ↓
   VM Meta Data protocol                 processVMMetaDataMsg()
   ThreadID: system                      ↓
                                         System thread INTERPRETS code
                                         ↓
                                         bt - Begin Thread (new thread)
                                         txconfig - Set ERG parameters
                                         cd - Change directory to domain
                                         send - Queue send operation
                                         rt - Ready Thread (mark for commit)
                                         ↓
                                         Transaction EPHEMERAL (not compiled)

4. REQUEST COMMIT
   CVMContext.commit()               →  CConversation receives
   ↓                                     ↓
   DFS requestCommit                     handleProcessDFSMsg()
   ThreadID: system                      ↓
   RequestID: <UUID>                     Detects requiresDetachedProcessing
                                         ↓
                                         Spawns NATIVE THREAD
                                         ↓
                                         WebSocket returns immediately

                                         ┌──────────────────────────────┐
                                         │ NATIVE THREAD (Detached)     │
                                         ├──────────────────────────────┤
                                         │ Executes 'ct' command        │
                                         │ ↓                            │
                                         │ commitThreads()              │
                                         │ ↓                            │
                                         │ FOR EACH ready thread:       │
                                         │   ↓                          │
                                         │   COMPILE GridScript         │
                                         │   ↓                          │
                                         │   CGridScriptCompiler::      │
                                         │     compile(source, bytecode)│
                                         │   ↓                          │
                                         │   V2 Bytecode Generated:     │
                                         │   [VERSION][HASH][OPCODES]   │
                                         │   ↓                          │
                                         │   Create CTransaction        │
                                         │   ↓                          │
                                         │   tx.setCode(bytecode)       │
                                         │   ↓                          │
                                         │   validateSemantics()        │
                                         │   ↓                          │
                                         │   Needs signature...         │
                                         └──────────────────────────────┘

5. AUTHENTICATION REQUEST
                                      ←  Native thread sends
   Receives QRIntentAuth                 VM Meta Data protocol
   ↓                                     ↓
   processVMMetaDataRequest()            Sets: getIsWaitingForVMMetaData()
   ↓                                     ↓
   IF (headless mode):                   Native thread BLOCKS ⏸️
     CKeyChainManager.sign()
   ELSE (QR mode):
     Display QR code
     Wait for mobile signature

6. BROWSER SIGNS
   Gets keychain
   ↓
   Signs transaction hash
   ↓
   CVMContext.registerUserDataResponse()

7. AUTHENTICATION RESPONSE
   Sends VM Meta Data response       →  WebSocket receives
   fields: [signature, publicKey]       ↓
   reqID: <UUID>                         Finds waiting VM
                                         ↓
                                         setVMMetaDataResponse()

                                         ┌──────────────────────────────┐
                                         │ NATIVE THREAD (Resumed)      │
                                         ├──────────────────────────────┤
                                         │ Receives auth data ✅        │
                                         │ ↓                            │
                                         │ tx.setSignature(sig)         │
                                         │ tx.setPublicKey(pubKey)      │
                                         │ ↓                            │
                                         │ preValidateTransaction()     │
                                         │ ↓                            │
                                         │ registerTransaction()        │
                                         │ ↓                            │
                                         │ Transaction in mempool       │
                                         │ ↓                            │
                                         │ notifyCommitStatus(success)  │
                                         └──────────────────────────────┘

8. COMMIT RESULT
   CVMContext.processDFSMsg()        ←  DFS commitSuccess
   ↓                                     Data2: Receipt ID
   updateTransactionStatus('success')
   ↓
   Display receipt


THREAT MODEL (Mode 1):
──────────────────────

TRUST ASSUMPTIONS:
  ✓ User controls private keys (browser or mobile)
  ✓ Signature happens client-side
  ✗ GRIDNET Core compiles the GridScript bytecode
  ✗ GRIDNET Core constructs the transaction

ATTACK VECTORS:

  1. MALICIOUS COMPILATION
     Threat: Compromised GRIDNET Core modifies bytecode
     Impact: Transaction logic altered (wrong amount, wrong recipient)
     Example:
       User: send Bob 100
       Core: Compiles as "send Eve 1000"
     Mitigation: Code is visible in thread before commit
     Risk: HIGH - Users typically don't verify compiled bytecode

  2. CODE SUBSTITUTION
     Threat: Core executes different code than proposed
     Impact: Arbitrary transaction logic
     Example:
       Proposed: send Bob 100
       Executed: send Eve 1000; send Mallory 500
     Mitigation: None in this mode
     Risk: CRITICAL - No client-side verification

  3. PARAMETER MANIPULATION
     Threat: Core modifies ERG parameters
     Impact: Higher fees, reduced gas limits
     Example:
       User: ERG bid = 1 attoGNC
       Core: ERG bid = 1000000 attoGNC (excessive fee)
     Mitigation: None in this mode
     Risk: MEDIUM - Visible in balance changes

  4. TIMING ATTACKS
     Threat: Core delays transaction submission
     Impact: Price manipulation, MEV extraction
     Example:
       User submits buy order
       Core delays until price changes
       Core front-runs with own transaction
     Mitigation: Transaction timestamps checked
     Risk: MEDIUM - Limited by consensus rules

SECURITY PROPERTIES:
  ✓ Signature Security: Private keys never leave client
  ✓ Authentication: Only valid signatures accepted
  ✗ Code Integrity: No verification of compiled bytecode
  ✗ Transaction Logic: Fully controlled by server
  ✗ Determinism: Same source may compile differently

SUITABLE FOR:
  • Trusted GRIDNET Core instances (own node)
  • Development and testing
  • Operations where convenience > trustlessness
  • Low-value transactions


5.4.2 MODE 2: LOCAL TRANSACTION GENERATION (Trustless)
────────────────────────────────────────────────────────────────────────────

This mode enables COMPLETE trustlessness by compiling GridScript locally
in the browser and submitting pre-signed transactions directly to the
blockchain.

ARCHITECTURE:
─────────────

BROWSER COMPONENTS:
  • GridScriptCompiler.js - JavaScript bytecode compiler
  • CTransaction.js - Transaction container and BER encoding
  • CKeyChain.js - Ed25519 signing with local keys
  • Tools.js - Cryptographic utilities

KEY PRINCIPLE: The browser has COMPLETE control over transaction creation.
The server ONLY relays the pre-signed transaction to the blockchain.


SEQUENCE OF EVENTS:
───────────────────

BROWSER SIDE                          |  GRIDNET CORE SIDE
──────────────────────────────────────┼─────────────────────────────────────

1. USER ACTION
   User clicks "Send"
   ↓
   Wallet.sendLocalTransaction()
   ↓
   Local Transaction Mode ENABLED


2. BUILD GRIDSCRIPT SOURCE (LOCALLY)
   ```javascript
   let source = `cd /${domain}\n`;
   source += `send ${address} ${amount}\n`;
   ```
   ↓
   Source code STAYS in browser


3. COMPILE BYTECODE (LOCALLY)
   ```javascript
   const compiler = new GridScriptCompiler();
   const result = await compiler.compile(source);
   ```
   ↓
   GridScriptCompiler.compile():
   ├─ Tokenize source code
   ├─ Initialize V2 hash chain
   │  H0 = SHA256("GRIDSCRIPT_V2_KEYWORD_IMAGE")
   ├─ For each codeword:
   │  ├─ Update hash: H(n+1) = SHA256(H(n) || keyword)
   │  ├─ Encode opcode (165 for cd, 198 for send)
   │  ├─ Encode parameters as UTF-8
   │  └─ Append to bytecode
   └─ Return: [VERSION][HASH][OPCODES]
   ↓
   Bytecode: 122 bytes (V2 format)
   ↓
   100% IDENTICAL to C++ compilation


4. CREATE TRANSACTION (LOCALLY)
   ```javascript
   const tx = new CTransaction(
     issuer,      // Domain ID bytes
     pubKey,      // Ed25519 public key
     nonce,       // Transaction nonce
     bytecode,    // Compiled GridScript (NO checksum)
     timestamp,   // Unix timestamp
     ergPrice,    // ERG bid in attoGNC
     ergLimit     // Maximum ERG units
   );
   ```
   ↓
   Transaction structure:
   ┌─────────────────────────────────┐
   │ CTransaction (BER-encoded)      │
   ├─────────────────────────────────┤
   │ • Issuer (domain address)       │
   │ • Public Key (Ed25519)          │
   │ • Nonce (unique ID)             │
   │ • Bytecode (compiled GridScript)│
   │ • Timestamp (Unix time)         │
   │ • ERG Price (attoGNC)           │
   │ • ERG Limit (max units)         │
   │ • Signature (empty - not signed)│
   └─────────────────────────────────┘


5. SIGN TRANSACTION (LOCALLY)
   ```javascript
   const privateKey = keychain.getPrivateKey();
   tx.sign(privateKey);
   ```
   ↓
   Signing process:
   ├─ Serialize transaction (BER encode)
   ├─ Hash: SHA-256(serialized_tx)
   ├─ Sign: Ed25519.sign(hash, privateKey)
   └─ Attach signature to transaction
   ↓
   Private key NEVER leaves browser
   ↓
   Fully signed CTransaction ready


6. SERIALIZE TRANSACTION (LOCALLY)
   ```javascript
   const packedTx = tx.getPackedData(false);
   ```
   ↓
   BER Encoding:
   ┌─────────────────────────────────┐
   │ BER-encoded Transaction         │
   ├─────────────────────────────────┤
   │ Tag: CTransaction               │
   │ Length: <total_length>          │
   │ Fields (in order):              │
   │   [Issuer]                      │
   │   [Public Key]                  │
   │   [Nonce]                       │
   │   [Bytecode]                    │
   │   [Timestamp]                   │
   │   [ERG Price]                   │
   │   [ERG Limit]                   │
   │   [Signature] ✅ SIGNED         │
   └─────────────────────────────────┘
   ↓
   Binary transaction: ~250 bytes


7. SUBMIT PRE-SIGNED TRANSACTION
   ```javascript
   await this.mVMContext.submitTransaction(packedTx);
   ```
   ↓
   CVMContext.submitTransaction()
   ↓
   WebSocket sends:                  →  GRIDNET Core receives
   {                                     ↓
     type: "submitTransaction",          CConversation::
     data: <BER_bytes>                     processSubmitTransaction()
   }                                     ↓
                                         Deserialize CTransaction
                                         ↓
                                         Extract fields:
                                         ├─ issuer
                                         ├─ publicKey
                                         ├─ nonce
                                         ├─ bytecode ✅ Pre-compiled
                                         ├─ timestamp
                                         ├─ ergPrice
                                         ├─ ergLimit
                                         └─ signature ✅ Pre-signed
                                         ↓
                                         NO COMPILATION NEEDED
                                         ↓
                                         validateTransactionSemantics()
                                         ├─ Verify BER structure
                                         ├─ Check bytecode format
                                         └─ Validate V2 header
                                         ↓
                                         preValidateTransaction()
                                         ├─ Verify signature
                                         ├─ Check pubKey matches issuer
                                         ├─ Verify nonce
                                         ├─ Check ERG availability
                                         ├─ Validate ERG bid
                                         └─ Check balance
                                         ↓
                                         IF (all valid):
                                           registerTransaction()
                                           ↓
                                           Transaction → Mempool
                                           ↓
                                           Generate Receipt ID
                                         ↓
                                         Send response

8. RECEIVE CONFIRMATION
   CVMContext receives response      ←  Response message
   ↓                                     {
   Parse receipt ID                       status: "success",
   ↓                                       receiptID: <base58>
   updateTransactionStatus('success')    }
   ↓
   Display receipt
   ↓
   Refresh balance/history


CRITICAL DIFFERENCES FROM MODE 1:
──────────────────────────────────

MODE 1 (Remote):                     MODE 2 (Local):
────────────────                     ───────────────

Source Code:                         Source Code:
  Sent to Core → Interpreted          Stays in browser

Compilation:                         Compilation:
  Core compiles bytecode               Browser compiles bytecode

Transaction:                         Transaction:
  Core builds CTransaction             Browser builds CTransaction

Signature:                           Signature:
  Core requests → Browser signs       Browser signs directly

Submission:                          Submission:
  Core registers directly              Core validates pre-signed TX

Trust:                               Trust:
  Must trust Core's compilation        Zero trust required


THREAT MODEL (Mode 2):
──────────────────────

TRUST ASSUMPTIONS:
  ✓ GridScriptCompiler.js is correct (open source, auditable)
  ✓ CTransaction.js is correct (open source, auditable)
  ✓ Browser executes JavaScript correctly
  ✓ User controls private keys
  ✗ NO trust in GRIDNET Core required

ATTACK VECTORS ELIMINATED:

  ✅ Malicious Compilation → ELIMINATED
     Browser compiles locally
     User can verify bytecode
     Identical to C++ implementation

  ✅ Code Substitution → ELIMINATED
     No code sent to server
     Transaction pre-compiled

  ✅ Parameter Manipulation → ELIMINATED
     All parameters set client-side
     Cryptographically signed

  ✅ Timing Attacks → MITIGATED
     Transaction timestamp set client-side
     Signature covers timestamp

REMAINING ATTACK VECTORS:

  ⚠️  MALICIOUS JAVASCRIPT
     Threat: Compromised GridScriptCompiler.js or CTransaction.js
     Impact: Arbitrary transaction generation
     Mitigation:
       • Code is open source
       • Can be audited
       • Served via HTTPS
       • SubResource Integrity (SRI) possible
     Risk: LOW - Requires compromising deployment infrastructure

  ⚠️  BROWSER COMPROMISE
     Threat: Malware in browser extracts private keys
     Impact: Unauthorized transaction signing
     Mitigation:
       • Standard browser security
       • Private keys encrypted at rest
       • Require user confirmation
     Risk: MEDIUM - Standard web security concern

  ⚠️  TRANSACTION RELAY CENSORSHIP
     Threat: GRIDNET Core refuses to relay transaction
     Impact: Denial of service
     Mitigation:
       • User can submit to different node
       • Transaction can be broadcast p2p
       • Mempool propagation
     Risk: LOW - User can switch nodes

  ⚠️  CONSENSUS REJECTION
     Threat: Transaction rejected by consensus
     Impact: Transaction not included
     Mitigation:
       • Pre-validation catches most issues
       • User receives clear error message
       • Can retry with adjusted parameters
     Risk: LOW - Normal consensus operation

SECURITY PROPERTIES:
  ✓ Code Integrity: Bytecode compiled client-side
  ✓ Transaction Logic: Fully controlled by user
  ✓ Determinism: Same source = identical bytecode
  ✓ Signature Security: Keys never leave client
  ✓ Authentication: Cryptographic signature
  ✓ Transparency: User can inspect all data
  ✓ Auditability: Open source implementation

SUITABLE FOR:
  • High-value transactions
  • Untrusted GRIDNET Core instances
  • Maximum security requirements
  • Trustless decentralized operation
  • Compliance and auditing needs


5.4.3 MODE SELECTION AND CONFIGURATION
────────────────────────────────────────────────────────────────────────────

The Wallet UI dApp provides a toggle to switch between modes:

CONFIGURATION:
──────────────

```javascript
// wallet.js
this.mLocalTransactionMode = false;  // Default: Remote compilation

// UI Toggle
toggleLocalTransactionMode() {
    this.mLocalTransactionMode = !this.mLocalTransactionMode;

    if (this.mLocalTransactionMode) {
        this.showNotification(
            'Local transaction generation enabled. ' +
            'Your transactions will be compiled and signed locally.',
            'Security Enhanced',
            'success'
        );
    } else {
        this.showNotification(
            'Remote transaction generation enabled. ' +
            'GRIDNET Core will compile your transactions.',
            'Standard Mode',
            'info'
        );
    }
}
```

MODE DETECTION:
───────────────

```javascript
async sendOnChainTransaction(recipients, amount, note) {
    // Check mode
    if (this.mLocalTransactionMode) {
        // MODE 2: Local compilation and signing
        return await this.sendLocalTransaction(recipients, amount, note);
    } else {
        // MODE 1: Remote compilation via Threads API
        return await this.sendRemoteTransaction(recipients, amount, note);
    }
}
```

USER INTERFACE:
───────────────

┌────────────────────────────────────────────────────────────┐
│ Transaction Mode: [●] Local  [ ] Remote                    │
├────────────────────────────────────────────────────────────┤
│                                                             │
│ ✓ Zero Trust Mode                                          │
│ ✓ Transactions compiled locally in your browser            │
│ ✓ Private keys never transmitted                           │
│ ✓ Full control over transaction logic                      │
│                                                             │
│ [ Switch to Remote Mode ]                                  │
│                                                             │
└────────────────────────────────────────────────────────────┘

RECOMMENDED USAGE:
──────────────────

Use LOCAL MODE (Mode 2) when:
  • Sending large amounts
  • Connecting to untrusted nodes
  • Maximum security is critical
  • Compliance requires auditability
  • Paranoid about server manipulation

Use REMOTE MODE (Mode 1) when:
  • Running your own GRIDNET Core node
  • Convenience is more important than paranoia
  • Transaction amounts are small
  • Development and testing
  • Trust relationship with node operator


5.4.4 IMPLEMENTATION FILES
────────────────────────────────────────────────────────────────────────────

MODE 2 (Local Transaction) Implementation:

Browser-Side:
  • WebUI/lib/GridScriptCompiler.js
      - JavaScript implementation of GridScript compiler
      - Must produce byte-for-byte identical output to C++
      - Supports V1 and V2 bytecode formats

  • WebUI/lib/Transaction.js
      - CTransaction class implementation
      - BER encoding/decoding
      - Ed25519 signature integration

  • WebUI/lib/tools.js
      - CTools class (crypto utilities)
      - Base58/Base64 encoding
      - SHA-256 hashing

  • WebUI/dApps/Wallet/wallet.js
      - sendLocalTransaction() method (line ~13060)
      - Mode selection logic
      - UI integration

Server-Side:
  • GRIDNETCore/GridScript/GridScriptCompiler.cpp
      - Reference C++ implementation
      - JavaScript must match exactly

  • GRIDNETCore/GRIDNET/Conversation.cpp
      - processSubmitTransaction() handler
      - Validates pre-signed transactions
      - No compilation performed

  • GRIDNETCore/GRIDNET/TransactionManager.cpp
      - preValidateTransaction() validation
      - registerTransaction() registration


5.4.5 VERIFICATION AND TESTING
────────────────────────────────────────────────────────────────────────────

BYTECODE COMPATIBILITY TESTING:

Test vectors ensure JavaScript and C++ compilers produce identical output:

```javascript
// test-compiler-standalone.js
const TEST_VECTOR = {
    source: 'cd /144c2Aof5t3GDUTv8x9mPorpzMLhkFQLWp send 1BKGXMjWuQyxS7Bpr4bxr9vAvXWy 2000000000000000000',
    expected_hex: 'c23b00dca4f738279e283a2714017bafb933a4344b2e87dc1accda8e425bc341fa...',
    expected_base64: 'wjsA3KT3OCeeKDonFAF7r7kzpDRL...'
};

// Compile with JavaScript
const compiler = new GridScriptCompiler();
const result = await compiler.compile(TEST_VECTOR.source);

// Verify byte-for-byte match
assert(result.bytecode.equals(expected_bytecode));
```

TRANSACTION VALIDATION TESTING:

```javascript
// Create and sign transaction locally
const tx = new CTransaction(issuer, pubKey, nonce, bytecode,
                            timestamp, ergPrice, ergLimit);
tx.sign(privateKey);

// Submit to Core
const packedTx = tx.getPackedData(false);
await submitTransaction(packedTx);

// Verify Core accepts and validates
// Should return receipt ID if valid
```

SECURITY AUDIT CHECKLIST:

  ✓ GridScriptCompiler produces identical bytecode to C++
  ✓ CTransaction BER encoding matches C++ implementation
  ✓ Ed25519 signatures are valid
  ✓ Private keys never transmitted over network
  ✓ Timestamps are client-controlled
  ✓ ERG parameters are client-controlled
  ✓ Nonce generation is secure
  ✓ No server-side modification possible


================================================================================
6. HEADLESS AUTHENTICATION
================================================================================

6.1 AUTHENTICATION OVERVIEW
────────────────────────────────────────────────────────────────────────────

HEADLESS AUTHENTICATION allows transaction signing in the browser WITHOUT
requiring a mobile device to scan QR codes.

TRADITIONAL FLOW (QR-based):           HEADLESS FLOW (Browser-based):
─────────────────────────────────      ──────────────────────────────────

1. Browser requests commit              1. Browser requests commit
2. Core generates QR code               2. Core requests auth (VM Meta Data)
3. Browser displays QR code             3. Browser signs with stored keychain
4. User scans with mobile               4. Browser sends signature
5. Mobile signs transaction             5. Core validates signature
6. Mobile sends signature               6. Core commits transaction
7. Core commits transaction             7. Browser receives result
8. Browser receives result


ADVANTAGES OF HEADLESS MODE:
  ✅ No mobile device required
  ✅ Faster transaction signing
  ✅ Better user experience
  ✅ Works offline (no mobile connection needed)
  ✅ Suitable for high-frequency operations

SECURITY CONSIDERATIONS:
  ⚠️  Private keys stored in browser (encrypted)
  ⚠️  Browser-based signing (not HSM-protected)
  ✅ User must unlock keychain with password
  ✅ Timeout auto-locks keychain
  ✅ Optional fallback to QR mode


6.2 KEYCHAIN MANAGER ARCHITECTURE
────────────────────────────────────────────────────────────────────────────

CKeyChainManager handles cryptographic operations for headless authentication.

KEY METHODS:

1. signAuthenticationRequest(processHandle, request, qrIntent, waitForConfirmation)
   ─────────────────────────────────────────────────────────────────────────────────
   Purpose: Sign authentication request with stored keychain
   Location: CKeyChainManager.js:1339-1507

   FLOW:
   ```
   ┌─────────────────────────────────────────────────────────┐
   │ 1. Validate request structure                          │
   │    - Check request.id exists                           │
   │    - Check processID matches (if provided)             │
   └─────────────────┬───────────────────────────────────────┘
                     ▼
   ┌─────────────────────────────────────────────────────────┐
   │ 2. Get active keychain                                  │
   │    - Prompt for password if locked                      │
   │    - Unlock keychain                                    │
   │    - Get private key at current index                   │
   └─────────────────┬───────────────────────────────────────┘
                     ▼
   ┌─────────────────────────────────────────────────────────┐
   │ 3. Extract data to sign from QRIntent                   │
   │    - qrIntent.getData() returns ArrayBuffer             │
   │    - This is the transaction hash                       │
   └─────────────────┬───────────────────────────────────────┘
                     ▼
   ┌─────────────────────────────────────────────────────────┐
   │ 4. Sign data                                            │
   │    - signature = mCrypto.sign(privateKey, dataToSign)   │
   │    - publicKey = keychain.getPubKey()                   │
   └─────────────────┬───────────────────────────────────────┘
                     ▼
   ┌─────────────────────────────────────────────────────────┐
   │ 5. Prepare response                                     │
   │    dataFields: [signature, publicKey]  ← ORDER MATTERS! │
   │    reqID: request.id                                    │
   │    dataType: eDataRequestType.QRIntentAuth              │
   └─────────────────┬───────────────────────────────────────┘
                     ▼
   ┌─────────────────────────────────────────────────────────┐
   │ 6. Send response with retry logic                       │
   │    - Base delay: 3 seconds                              │
   │    - Exponential backoff: 1.5x                          │
   │    - Max retries: 5                                     │
   │    - Wait for DFS confirmation                          │
   └─────────────────┬───────────────────────────────────────┘
                     ▼
   ┌─────────────────────────────────────────────────────────┐
   │ 7. Return result                                        │
   │    - true: Confirmed success                            │
   │    - false: Uncertain (no confirmation)                 │
   │    - throw: Confirmed failure                           │
   └─────────────────────────────────────────────────────────┘
   ```

   CODE:
   ```javascript
   const activeKeyChain = await this.getActiveKeyChain(processHandle);
   const privateKey = activeKeyChain.getPrivKey();
   const publicKey = activeKeyChain.getPubKey();
   const signature = this.mCrypto.sign(privateKey, dataToSign);

   const responseData = {
       reqID: request.id,
       processID: processID,
       type: eUITTaskType.response,
       dataType: eDataRequestType.QRIntentAuth,
       dataFields: [signature, publicKey]  // CRITICAL: Order matters!
   };

   // Send with retry logic
   this.mVMContext.registerUserDataResponse(responseData);
   ```

2. Retry Logic with Exponential Backoff
   ────────────────────────────────────
   Why needed: Network issues, Core processing delays

   ```javascript
   const baseRetryDelay = 3000;  // 3 seconds
   let attempt = 0;

   while (attempt <= maxRetriesAttempt && !confirmationReceived) {
       const retryDelay = attempt > 0
           ? baseRetryDelay * Math.pow(1.5, attempt - 1)
           : 0;

       if (attempt > 0) {
           await new Promise(resolve => setTimeout(resolve, retryDelay));
       }

       this.mVMContext.registerUserDataResponse(responseData);

       await Promise.race([
           confirmationPromise,
           new Promise(resolve => setTimeout(resolve, baseRetryDelay))
       ]).catch(() => {});

       if (confirmationReceived) break;
       attempt++;
   }
   ```

3. Confirmation Waiting Mechanism
   ───────────────────────────────
   ```javascript
   let listenerID = null;

   try {
       const confirmationPromise = new Promise((resolve, reject) => {
           const dfsListener = (dfsMsg) => {
               if (dfsMsg.getType === eDFSCmdType.commitSuccess) {
                   confirmationReceived = true;
                   resolve(true);
               } else if (dfsMsg.getType === eDFSCmdType.commitAborted) {
                   confirmationReceived = true;
                   reject(new Error('Commit failed'));
               }
           };

           listenerID = this.mVMContext.addNewDFSMsgListener(
               dfsListener,
               request.id
           );
       });

       // Wait for confirmation...

   } finally {
       // ALWAYS cleanup listener
       if (listenerID !== null) {
           this.mVMContext.removeNewDFSMsgListener(listenerID);
       }
   }
   ```


6.3 SYSTEM MODE AUTO-DETECTION
────────────────────────────────────────────────────────────────────────────

PROBLEM: When commits execute, processID is lost in the chain.
SOLUTION: Auto-detect system mode when processHandle is null.

```javascript
// In CKeyChainManager.js:204-220
_validateProcessHandle(processHandle, operationName, requireProcessHandle = false) {
    // Auto-detect system mode
    if (!processHandle || !isValidProcessHandle(processHandle)) {
        if (requireProcessHandle) {
            // Admin operations REQUIRE valid dApp context
            throw new Error(`${operationName} requires a valid processHandle.`);
        }

        // System-level operation (commit without explicit dApp context)
        console.log(`${operationName} in system mode (auto-detected)`);
        return 0; // Use processID = 0 for system operations
    }

    return processHandle.getProcessID;
}
```

USAGE:
```javascript
// Signing during commit (no processHandle)
const processID = this._validateProcessHandle(
    null,              // processHandle is null during commit
    "Sign Auth Request",
    false              // Don't require processHandle
);
// Returns: 0 (system mode)

// Admin operation (requires processHandle)
const processID = this._validateProcessHandle(
    processHandle,
    "Delete Keychain",
    true               // Require processHandle
);
// Throws error if processHandle is null
```


================================================================================
7. KEY COMPONENTS
================================================================================

7.1 WALLET.JS (Main Wallet Application)
────────────────────────────────────────────────────────────────────────────

LOCATION: dApps/Wallet/wallet.js
PRIMARY METHODS:

initialize()
────────────
  Purpose: Setup Wallet, subscribe to events
  Key actions:
    - Subscribe to VM state changes (onVMStateChanged)
    - Subscribe to DFS messages (onDFSMessage)
    - Load initial balance and history

  CODE:
  ```javascript
  this.mVMContext.addVMStateChangedListener(
      this.onVMStateChanged.bind(this),
      this.getProcessID
  );

  this.mVMContext.addNewDFSMsgListener(
      this.onDFSMessage.bind(this),
      this.getProcessID
  );
  ```

sendOnChainTransaction(recipient, amount, immediateDispatch)
────────────────────────────────────────────────────────────
  Purpose: Send cryptocurrency transaction
  Flow:
    1. Validate inputs (recipient, amount)
    2. Check system thread availability
    3. Wake system thread if needed
    4. Propose transaction code
    5. Add to consensus task queue
    6. Commit (if immediateDispatch)
    7. Wait for DFS confirmation

  CODE:
  ```javascript
  // Check system thread
  let systemThreadID = this.mVMContext.getSystemThreadID;
  if (!systemThreadID || systemThreadID.byteLength === 0) {
      await this.mVMContext.wakeThreadA(new ArrayBuffer(0), this, 30000);
  }

  // Propose transaction
  const gridScriptCmd = `send ${amount} GBU to ${recipient}`;
  await this.mVMContext.proposeCodeA(gridScriptCmd, this);

  // Add to consensus queue
  const task = new CConsensusTask(`Send ${amount} GBU to ${recipient}`);
  this.mVMContext.addConsensusTask(task);

  // Commit
  if (immediateDispatch) {
      this.updateTransactionStatus('committing', 'Committing...');
      this.mVMContext.getMagicButton.commitActions();
      // Wait for onDFSMessage() callback for success
  }
  ```

onDFSMessage(dfsMsg)
────────────────────
  Purpose: Handle DFS protocol messages
  Critical: Filters by threadID!

  CODE:
  ```javascript
  onDFSMessage(dfsMsg) {
      const systemThreadID = this.mVMContext.getSystemThreadID;

      // CRITICAL: Filter by thread ID
      if (!this.mTools.compareByteVectors(systemThreadID, dfsMsg.getThreadID)) {
          return; // Not our thread
      }

      switch (dfsMsg.getType) {
          case eDFSCmdType.commitSuccess:
              const receiptID = this.mTools.arrayBufferToString(dfsMsg.getData2);
              this.updateTransactionStatus('success', receiptID);
              this.mVMContext.playSound(eSound.sent);
              setTimeout(() => this.retrieveBalance(), 2000);
              setTimeout(() => this.loadTransactionHistory(), 3000);
              break;

          case eDFSCmdType.commitAborted:
          case eDFSCmdType.error:
              const errorMsg = this.mTools.arrayBufferToString(dfsMsg.getData1);
              this.updateTransactionStatus('error', errorMsg);
              break;
      }
  }
  ```

onVMStateChanged(vmState)
─────────────────────────
  Purpose: Handle VM state change notifications

  CODE:
  ```javascript
  onVMStateChanged(vmState) {
      const state = vmState.getState;
      const threadID = vmState.getThreadID;

      switch (state) {
          case eVMState.ready:
              console.log('[Wallet] Thread ready:', threadID);
              break;
          case eVMState.committable:
              console.log('[Wallet] Thread committable:', threadID);
              break;
          case eVMState.committed:
              console.log('[Wallet] Thread committed:', threadID);
              break;
      }
  }
  ```


7.2 CVMCONTEXT.JS (VM Context Manager)
────────────────────────────────────────────────────────────────────────────

LOCATION: lib/VMContext.js
PRIMARY METHODS:

processVMMetaDataRequest(targetProcessHandle, request)
───────────────────────────────────────────────────────
  Purpose: Handle incoming VM Meta Data requests (e.g., QRIntentAuth)
  Location: VMContext.js:8900-8950

  FLOW:
  ```
  1. Receive request from GRIDNET Core
  2. Deserialize QRIntent
  3. Attempt headless signing via CKeyChainManager
  4. If successful: Return true (confirmed)
  5. If uncertain: Return false (no confirmation)
  6. If failed: Fall through to QR display
  ```

  CODE:
  ```javascript
  const qr = CQRIntent.instantiate(request.defaultValue);

  const handledLocally = await this.mKeyChainManager.signAuthenticationRequest(
      targetProcessHandle,
      request,
      qr
  );

  if (handledLocally === true) {
      // Confirmed success
      return true;
  } else if (handledLocally === false) {
      // Uncertain - signature sent but no confirmation
      return false;
  } else {
      // Fall through to QR display
      // ... display QR code ...
  }
  ```

addNewDFSMsgListener(eventListener, filterID)
──────────────────────────────────────────────
  Purpose: Register DFS message listener with optional filter
  Returns: Listener ID for later removal

  CODE:
  ```javascript
  addNewDFSMsgListener(eventListener, filterID = 0) {
      const listenerID = ++this.mDFSMsgListenerIDCounter;
      this.mNewDFSMsgListeners.push({
          id: listenerID,
          eventListener: eventListener,
          filterID: filterID
      });
      return listenerID;
  }
  ```

removeNewDFSMsgListener(listenerIdOrFunction)
──────────────────────────────────────────────
  Purpose: Remove DFS message listener by ID or function

  CODE:
  ```javascript
  removeNewDFSMsgListener(listenerIdOrFunction) {
      if (typeof listenerIdOrFunction === 'number') {
          this.mNewDFSMsgListeners = this.mNewDFSMsgListeners.filter(
              listener => listener.id !== listenerIdOrFunction
          );
      } else if (typeof listenerIdOrFunction === 'function') {
          this.mNewDFSMsgListeners = this.mNewDFSMsgListeners.filter(
              listener => listener.eventListener !== listenerIdOrFunction
          );
      }
  }
  ```

wakeThreadA(threadID, appHandle, maxWait)
──────────────────────────────────────────
  Purpose: Wake or create a thread (typically system thread)

  CODE:
  ```javascript
  async wakeThreadA(threadID, appHandle, maxWait = 30000) {
      return new Promise((resolve, reject) => {
          // Send wake command via VM Meta Data protocol
          // Wait for thread ready notification
          // Timeout if not ready within maxWait
      });
  }
  ```


7.3 CKEYCHAIN MANAGER.JS
────────────────────────────────────────────────────────────────────────────

LOCATION: lib/CKeyChainManager.js

See section 6.2 for detailed documentation.


7.4 GRIDNET CORE COMPONENTS
────────────────────────────────────────────────────────────────────────────

CConversation (conversation.cpp)
─────────────────────────────────
  Purpose: Manages WebSocket connection with browser
  Key methods:
    - handleProcessDFSMsg(): Process DFS protocol messages
    - handleProcessVMMetaDataMsg(): Process VM Meta Data messages
    - processMsg(): Route incoming messages to appropriate handler

CScriptEngine (scriptengine.cpp)
─────────────────────────────────
  Purpose: GridScript VM for code execution
  Key methods:
    - processScript(): Execute GridScript code
    - commitThreads(): Commit transaction to blockchain
    - notifyCommitStatus(): Send commit result to browser
    - setVMMetaDataResponse(): Receive authentication data

CTransactionManager (TransactionManager.cpp)
────────────────────────────────────────────
  Purpose: Validate and manage transactions
  Key methods:
    - preValidateTransaction(): Comprehensive pre-commit validation
    - registerTransaction(): Add transaction to formation queue


================================================================================
8. IMPLEMENTATION DETAILS
================================================================================

8.1 RECEIPT ID HANDLING
────────────────────────────────────────────────────────────────────────────

Receipt IDs are blockchain transaction hashes that serve as proof of commit.

RECEIPT ID FLOW:
```
GRIDNET Core                         Browser
─────────────                        ────────
commitThreads()
  ↓
registerTransaction() returns receiptID
  ↓
notifyCommitStatus(success, receiptID)
  ↓
DFS commitSuccess
  Data2: receiptID (base58-encoded)  →  onDFSMessage()
                                           ↓
                                         Extract receiptID
                                           ↓
                                         Display to user
                                           ↓
                                         Copy to clipboard
```

WALLET UI DISPLAY:
```javascript
updateTransactionStatus(status, message) {
    if (status === 'success') {
        // Display receipt with copy button
        const html = `
            <div style="color: #0f0;">✅ Transaction Successful</div>
            <div id="receipt-id-display">${message}</div>
            <button id="copy-receipt-btn" onclick="navigator.clipboard.writeText('${message}')">
                <i class="fa fa-copy"></i> Copy Receipt ID
            </button>
        `;
        // ... update UI ...
    }
}
```


8.2 CONSENSUS TASK MANAGEMENT
────────────────────────────────────────────────────────────────────────────

Consensus tasks track operations pending commit.

TASK LIFECYCLE:
```
Created → Pending → Committed/Aborted
```

CVMContext manages consensus tasks:
```javascript
// Add task
addConsensusTask(task) {
    this.mConsensusTasks.push(task);
    this.updateMagicButtonState();
}

// Remove task
removeConsensusTask(taskID) {
    this.mConsensusTasks = this.mConsensusTasks.filter(
        t => t.getID !== taskID
    );
    this.updateMagicButtonState();
}

// Clear all tasks
clearPendngConsensusTasks() {
    this.mConsensusTasks = [];
    this.updateMagicButtonState();
}
```


8.3 ERROR HANDLING PATTERNS
────────────────────────────────────────────────────────────────────────────

BROWSER SIDE:
```javascript
try {
    const result = await this.sendOnChainTransaction(recipient, amount, true);
    // Success handled via onDFSMessage() callback
} catch (error) {
    this.updateTransactionStatus('error', error.message);
    this.showMessageBox('Error', error.message, eNotificationType.error);
}
```

GRIDNET CORE SIDE:
```cpp
try {
    // Validate transaction
    eTransactionValidationResult result = preValidateTransaction(...);

    if (result != eTransactionValidationResult::valid) {
        RUNTIME_ERROR("Validation failed: " + getErrorMessage(result));
    }

    // Register transaction
    if (!registerTransaction(t, receiptID)) {
        RUNTIME_ERROR("Registration failed");
    }

    // Notify success
    notifyCommitStatus(eCommitStatus::success, receiptID);

} catch (const std::exception& e) {
    // Notify failure
    notifyCommitStatus(eCommitStatus::aborted, e.what());
}
```


================================================================================
9. CRITICAL FIXES AND IMPROVEMENTS
================================================================================

9.1 WEBSOCKET DEADLOCK FIX
────────────────────────────────────────────────────────────────────────────

PROBLEM:
  WebSocket thread blocked during commit, unable to receive auth data.

ROOT CAUSE:
  CConversation::handleProcessDFSMsg() executed 'ct' command synchronously
  on WebSocket thread, which then blocked waiting for auth response.

SOLUTION:
  Spawn native thread for detached processing.

CODE (conversation.cpp:8184-8234):
```cpp
if (mType == eDFSCmdType::requestCommit) {
    requiresDetachedProcessing = true;
}

if (requiresDetachedProcessing) {
    size_t nativeThreadsCount = targetThread->getNativeThreadCount();

    if (!nativeThreadsCount) {
        // Spawn native thread
        targetThread->addNativeThread(
            std::make_shared<std::thread>(
                std::bind(&SE::CScriptEngine::processScript, targetThread,
                    cmd,
                    ...,
                    msg->getRequestID(),  // metaRequestID
                    true,                 // detachedProcessing
                    false                 // excuseERGusage
                )
            )
        );
    }

    // Return immediately - WebSocket thread FREE
    return true;
}
```


9.2 AUTH DATA DELIVERY FIX
────────────────────────────────────────────────────────────────────────────

PROBLEM:
  Auth response arrives but getTaskByMetaReqID() returns nullptr.
  Data silently discarded.

ROOT CAUSE:
  DFS-initiated requests don't create tasks in task queue.

SOLUTION:
  Add fallback to deliver auth data directly to waiting VM.

CODE (conversation.cpp:10334-10365):
```cpp
if (task != nullptr && task->getState() == eNetTaskState::working) {
    // Normal path: deliver to task
    task->addResultDataEntry(dataFields[b]);
} else if (task == nullptr) {
    // FALLBACK: Deliver directly to waiting VM
    std::shared_ptr<SE::CScriptEngine> systemThread = getSystemThread();
    if (systemThread != nullptr) {
        // Get all VMs (system + child threads)
        std::vector<std::shared_ptr<SE::CScriptEngine>> allThreads =
            systemThread->getThreads(false);

        // Find waiting VM
        bool delivered = false;
        for (size_t i = 0; i < allThreads.size() && !delivered; i++) {
            if (allThreads[i] != nullptr &&
                allThreads[i]->getIsWaitingForVMMetaData()) {
                // Deliver auth data
                allThreads[i]->setVMMetaDataResponse(sections, true, false);
                delivered = true;
            }
        }

        // Check system thread itself
        if (!delivered && systemThread->getIsWaitingForVMMetaData()) {
            systemThread->setVMMetaDataResponse(sections, true, false);
        }
    }
}
```


9.3 THREADID MISSING IN COMMIT NOTIFICATION FIX
────────────────────────────────────────────────────────────────────────────

PROBLEM:
  Wallet UI not receiving commitSuccess notifications.
  UI kept showing "Sending to 1 recipient. Please wait..."

ROOT CAUSE:
  notifyCommitStatus() created DFS message without setting threadID.
  Wallet filters messages by threadID, so ignored the notification.

SOLUTION:
  Set threadID in DFS commit notification.

CODE (scriptengine.cpp:8806):
```cpp
std::shared_ptr<CDFSMsg> dfsMsg = std::make_shared<CDFSMsg>(targetDFSType);
dfsMsg->setRequestID(getMetaRequestID());
dfsMsg->setThreadID(getID());  // CRITICAL: Set threadID!
if (receiptID.size() > 0)
    dfsMsg->setData2(mTools->stringToBytes(receiptID));
```


9.4 TRANSACTION PRE-VALIDATION FIX
────────────────────────────────────────────────────────────────────────────

PROBLEM:
  Transactions only validated for semantics, not for ERG, signatures, etc.
  Invalid transactions could be registered.

ROOT CAUSE:
  commitThreads() only called validateTransactionSemantics().
  No comprehensive validation before registerTransaction().

SOLUTION:
  Add CTransactionManager::preValidateTransaction() call.

CODE (scriptengine.cpp:13285-13342):
```cpp
// Semantic validation (existing)
RUNTIME_ERROR_IF(!mTools->validateTransactionSemantics(t),
    "Invalid final transaction semantics.");

// NEW: Comprehensive pre-validation
uint64_t currentKeyHeight = targetBlockchain->getKeyHeight();
std::shared_ptr<CTransaction> transPtr = std::make_shared<CTransaction>(t);

eTransactionValidationResult validationResult =
    targetBlockchain->getTransactionManager()->preValidateTransaction(
        transPtr, currentKeyHeight, nullptr
    );

// Check all possible failure cases
switch (validationResult) {
    case eTransactionValidationResult::valid:
        break; // Continue
    case eTransactionValidationResult::insufficientERG:
        RUNTIME_ERROR("Transaction validation failed: Insufficient ERG.");
        break;
    case eTransactionValidationResult::invalidSig:
        RUNTIME_ERROR("Transaction validation failed: Invalid signature.");
        break;
    // ... (all other cases)
}

// Only register if valid
registerTransaction(t, receiptID);
```


9.5 SYSTEM MODE AUTO-DETECTION FIX
────────────────────────────────────────────────────────────────────────────

PROBLEM:
  processID lost in commit chain.
  CKeyChainManager couldn't determine if operating in system mode.

ROOT CAUSE:
  Commits execute without explicit dApp context (processHandle is null).

SOLUTION:
  Auto-detect system mode when processHandle is null.

CODE (CKeyChainManager.js:204-220):
```javascript
_validateProcessHandle(processHandle, operationName, requireProcessHandle = false) {
    if (!processHandle || !isValidProcessHandle(processHandle)) {
        if (requireProcessHandle) {
            // Admin operations require valid dApp context
            throw new Error(`${operationName} requires a valid processHandle.`);
        }

        // Auto-detect system mode
        console.log(`${operationName} in system mode (auto-detected)`);
        return 0; // processID = 0 for system operations
    }

    return processHandle.getProcessID;
}
```


================================================================================
10. TROUBLESHOOTING GUIDE
================================================================================

10.1 COMMON ISSUES AND SOLUTIONS
────────────────────────────────────────────────────────────────────────────

ISSUE: Transaction stays in "Committing..." state forever
──────────────────────────────────────────────────────────
SYMPTOMS:
  - Wallet shows "Committing transaction to blockchain..."
  - No success or error message appears
  - Balance doesn't update

DIAGNOSIS:
  1. Check browser console for errors
  2. Check if DFS listener is registered:
     ```javascript
     console.log(this.mVMContext.mNewDFSMsgListeners);
     ```
  3. Check if commitSuccess message received:
     ```javascript
     // Add debug logging in onDFSMessage
     onDFSMessage(dfsMsg) {
         console.log('[DEBUG] DFS message received:', dfsMsg.getType);
         console.log('[DEBUG] Thread ID:', dfsMsg.getThreadID);
         // ...
     }
     ```

SOLUTIONS:
  ✅ Ensure threadID is set in notifyCommitStatus() (Core fix)
  ✅ Ensure Wallet filters messages correctly by threadID
  ✅ Check DFS listener is not prematurely removed
  ✅ Verify system thread ID is correct


ISSUE: "No System Thread available" error
──────────────────────────────────────────
SYMPTOMS:
  - Transaction fails with "No System Thread available"
  - Balance queries work, but commits fail

DIAGNOSIS:
  ```javascript
  const systemThreadID = this.mVMContext.getSystemThreadID;
  console.log('System thread ID:', systemThreadID);
  console.log('Byte length:', systemThreadID ? systemThreadID.byteLength : 0);
  ```

SOLUTIONS:
  ✅ Call wakeThreadA() before commit:
     ```javascript
     if (!systemThreadID || systemThreadID.byteLength === 0) {
         await this.mVMContext.wakeThreadA(new ArrayBuffer(0), this, 30000);
         systemThreadID = this.mVMContext.getSystemThreadID;
     }
     ```
  ✅ Wait for thread ready notification before proceeding
  ✅ Check GRIDNET Core is running and connected


ISSUE: Authentication fails (Wallet reports "uncertain" state)
───────────────────────────────────────────────────────────────
SYMPTOMS:
  - signAuthenticationRequest() returns false
  - No commit confirmation received
  - Transaction in limbo

DIAGNOSIS:
  1. Check retry attempts:
     ```javascript
     console.log('[DEBUG] Retry attempt:', attempt);
     console.log('[DEBUG] Confirmation received:', confirmationReceived);
     ```
  2. Check DFS listener is registered:
     ```javascript
     console.log('[DEBUG] Listener ID:', listenerID);
     ```
  3. Check Core is sending confirmations

SOLUTIONS:
  ✅ Increase max retry attempts (default: 5)
  ✅ Increase retry delay (default: 3s base, 1.5x exponential)
  ✅ Ensure DFS listener cleanup in finally block
  ✅ Check Core is using detached processing (not blocking)


ISSUE: "Transaction validation failed" errors
──────────────────────────────────────────────
SYMPTOMS:
  - Commit fails with specific validation error
  - Examples: "Insufficient ERG", "Invalid signature", "Invalid nonce"

DIAGNOSIS:
  Check which validation failed:
  - insufficientERG: User doesn't have enough balance
  - ERGBidTooLow: Transaction fee bid too low
  - invalidSig: Signature doesn't match transaction
  - pubNotMatch: Public key doesn't match issuer address
  - invalidNonce: Transaction nonce incorrect

SOLUTIONS:
  ✅ Check user balance before allowing transaction
  ✅ Ensure correct keychain is active (matches sender address)
  ✅ Verify ERG price and bid are set correctly
  ✅ Check nonce management in transaction preparation


ISSUE: Deadlock during commit
──────────────────────────────
SYMPTOMS:
  - Entire browser hangs during commit
  - No response from GRIDNET Core
  - WebSocket connection times out

DIAGNOSIS:
  Check GRIDNET Core stack trace:
  - Is WebSocket thread blocked in commitThreads()?
  - Is detached processing enabled?

SOLUTIONS:
  ✅ Ensure GRIDNET Core uses detached processing (Core fix)
  ✅ Restart GRIDNET Core with updated code
  ✅ Clear browser cache and reload


10.2 DEBUGGING TECHNIQUES
────────────────────────────────────────────────────────────────────────────

ENABLE VERBOSE LOGGING:
```javascript
// In wallet.js
const DEBUG_MODE = true;

if (DEBUG_MODE) {
    console.log('[Wallet] Transaction flow:', {
        recipient: recipient,
        amount: amount,
        systemThreadID: systemThreadID,
        immediateDispatch: immediateDispatch
    });
}
```

TRACE DFS MESSAGES:
```javascript
// In VMContext.js processDFSMsg
processDFSMsg(dfsMsg) {
    console.log('[VMContext] DFS message:', {
        type: dfsMsg.getType,
        threadID: dfsMsg.getThreadID,
        requestID: dfsMsg.getRequestID,
        data2Length: dfsMsg.getData2 ? dfsMsg.getData2.byteLength : 0
    });
    // ... process message ...
}
```

MONITOR THREAD STATE:
```javascript
// In wallet.js onVMStateChanged
onVMStateChanged(vmState) {
    console.log('[Wallet] VM state changed:', {
        threadID: vmState.getThreadID,
        state: vmState.getState,
        timestamp: Date.now()
    });
}
```

TRACE AUTHENTICATION FLOW:
```javascript
// In CKeyChainManager.js signAuthenticationRequest
async signAuthenticationRequest(processHandle, request, qrIntent) {
    console.log('[KeyChain] Auth request:', {
        reqID: request.id,
        processID: processID,
        dataSize: qrIntent.getData().byteLength
    });

    // ... sign ...

    console.log('[KeyChain] Auth response:', {
        signatureSize: signature.byteLength,
        publicKeySize: publicKey.byteLength
    });

    // ... send response ...
}
```


10.3 PERFORMANCE MONITORING
────────────────────────────────────────────────────────────────────────────

MEASURE TRANSACTION TIME:
```javascript
const startTime = performance.now();

await this.sendOnChainTransaction(recipient, amount, true);

// In onDFSMessage when commitSuccess received:
const endTime = performance.now();
const duration = endTime - startTime;
console.log(`Transaction completed in ${duration}ms`);
```

MONITOR RETRY ATTEMPTS:
```javascript
// In CKeyChainManager retry loop
console.log(`[Retry] Attempt ${attempt}/${maxRetriesAttempt}, delay: ${retryDelay}ms`);
```

TRACK CONFIRMATION DELAYS:
```javascript
const confirmationStartTime = Date.now();

// In DFS listener
if (dfsMsg.getType === eDFSCmdType.commitSuccess) {
    const confirmationDelay = Date.now() - confirmationStartTime;
    console.log(`Confirmation received after ${confirmationDelay}ms`);
}
```


================================================================================
11. ADDITIONAL KEY CONCEPTS
================================================================================

11.1 GRIDSCRIPT COMMAND REFERENCE
────────────────────────────────────────────────────────────────────────────

GridScript is GRIDNET OS's native scripting language for blockchain operations.
Key commands used in Wallet:

TRANSACTION COMMANDS:
─────────────────────
```
send <amount> GBU to <recipient>
  Purpose: Transfer cryptocurrency
  Example: send 100 GBU to user@domain.grid
  Mode: GUI (requires system thread)
  Result: Transaction queued for commit

balance <address>
  Purpose: Query account balance
  Example: balance user@domain.grid
  Mode: RAW (can use data thread)
  Result: Returns balance in GBU

history <address> [size] [page]
  Purpose: Get transaction history
  Example: history user@domain.grid 20 0
  Mode: RAW (can use data thread)
  Result: Returns transaction list
```

THREAD CONTROL COMMANDS:
────────────────────────
```
ct (commit-thread)
  Purpose: Commit current thread to blockchain
  Example: ct
  Mode: N/A (triggered by Magic Button)
  Result: Initiates blockchain commit
  CRITICAL: ALWAYS requires detached processing!

rt (ready-thread)
  Purpose: Mark thread as ready for commit
  Example: rt
  Mode: RAW
  Result: Thread marked committable

st [threadID] (start-thread)
  Purpose: Create new decentralized processing thread
  Example: st my-thread-123
  Mode: RAW
  Result: New thread spawned
```

CONTEXT COMMANDS:
─────────────────
```
context -c <command> [options]
  Purpose: Execute blockchain query commands
  Example: context -c getBlockDetails -search <blockID> -tx
  Mode: RAW/GUI
  Result: Blockchain data returned
```


11.2 VM EXECUTION MODES
────────────────────────────────────────────────────────────────────────────

GRIDNET OS supports three VM execution modes for different use cases:

┌──────────────────────────────────────────────────────────────────────────┐
│ eVMMetaCodeExecutionMode.RAW                                             │
├──────────────────────────────────────────────────────────────────────────┤
│ PURPOSE: Direct VM execution without preprocessing                       │
│ USE CASES:                                                               │
│   • Read-only operations (balance queries, history)                      │
│   • Data thread operations                                               │
│   • Private user-defined thread operations                               │
│   • High-performance scenarios                                           │
│                                                                          │
│ CHARACTERISTICS:                                                         │
│   ✓ No code preprocessing                                                │
│   ✓ Command Executor NOT available                                      │
│   ✓ Executes directly on specified VM                                   │
│   ✗ No shell-like features (cd, current directory)                      │
│                                                                          │
│ EXAMPLE:                                                                 │
│   this.mVMContext.processGridScript(                                     │
│       `balance ${address}`,                                              │
│       'data',                       // Data thread                       │
│       this,                         // Process handle                    │
│       eVMMetaCodeExecutionMode.RAW  // RAW mode                         │
│   );                                                                     │
└──────────────────────────────────────────────────────────────────────────┘

┌──────────────────────────────────────────────────────────────────────────┐
│ eVMMetaCodeExecutionMode.GUI                                             │
├──────────────────────────────────────────────────────────────────────────┤
│ PURPOSE: UI-aware execution with transaction formulation                 │
│ USE CASES:                                                               │
│   • Transaction preparation (send commands)                              │
│   • System thread operations                                             │
│   • Operations that will be committed                                    │
│                                                                          │
│ CHARACTERISTICS:                                                         │
│   ✓ Code preprocessing enabled                                           │
│   ✓ VM automatically enters transaction formulation mode                │
│   ✓ Suitable for commit operations                                      │
│   ✓ Processes on system thread by default                               │
│                                                                          │
│ EXAMPLE:                                                                 │
│   this.mVMContext.processGridScript(                                     │
│       `send 100 GBU to recipient@domain.grid`,                           │
│       systemThreadID,               // System thread                     │
│       this,                         // Process handle                    │
│       eVMMetaCodeExecutionMode.GUI  // GUI mode                         │
│   );                                                                     │
└──────────────────────────────────────────────────────────────────────────┘

┌──────────────────────────────────────────────────────────────────────────┐
│ eVMMetaCodeExecutionMode.GUITerminal                                     │
├──────────────────────────────────────────────────────────────────────────┤
│ PURPOSE: Terminal-like execution with shell features                     │
│ USE CASES:                                                               │
│   • Terminal dApp operations                                             │
│   • DTI (Decentralized Terminal Interface) sessions                      │
│   • Commands requiring shell context                                     │
│                                                                          │
│ CHARACTERISTICS:                                                         │
│   ✓ Processed through Command Executor                                   │
│   ✓ Shell pre- and post-processing available                            │
│   ✓ Current directory tracking                                           │
│   ✓ Supports both processID and threadID routing                        │
│                                                                          │
│ EXAMPLE:                                                                 │
│   this.mVMContext.processGridScript(                                     │
│       `cd /home && ls`,                                                  │
│       terminalThreadID,                  // Terminal VM thread           │
│       this,                              // Process handle               │
│       eVMMetaCodeExecutionMode.GUITerminal // Terminal mode             │
│   );                                                                     │
└──────────────────────────────────────────────────────────────────────────┘

MODE SELECTION DECISION TREE:
```
┌─────────────────────────────────────┐
│ Is this a commit operation?         │
└─────────────┬───────────────────────┘
              │
       Yes────┤
              │    ┌──────────────────────────────┐
              └───►│ Use GUI mode                 │
                   │ (system thread, committable) │
                   └──────────────────────────────┘
       No─────┐
              │
              ▼
┌─────────────────────────────────────┐
│ Is this a read-only query?          │
└─────────────┬───────────────────────┘
              │
       Yes────┤
              │    ┌──────────────────────────────┐
              └───►│ Use RAW mode                 │
                   │ (data thread, fast)          │
                   └──────────────────────────────┘
       No─────┐
              │
              ▼
┌─────────────────────────────────────┐
│ Is this a terminal operation?       │
└─────────────┬───────────────────────┘
              │
       Yes────┤
              │    ┌──────────────────────────────┐
              └───►│ Use GUITerminal mode         │
                   │ (terminal VM, shell features)│
                   └──────────────────────────────┘
```


11.3 CONSENSUS TASK PROCESSING
────────────────────────────────────────────────────────────────────────────

Consensus tasks are notifications from GRIDNET Core about blockchain operations
and thread state changes.

CONSENSUS TASK TYPES (eConsensusTaskType):
```
┌──────────────────────────┬──────────────────────────────────────────────┐
│ Type                     │ Meaning                                      │
├──────────────────────────┼──────────────────────────────────────────────┤
│ threadCommitPending      │ Thread commit began, awaiting auth           │
│ readyForCommit           │ Thread has code ready to be committed        │
│ threadCommitted          │ Thread successfully committed                │
│ commitAborted            │ Thread commit failed/aborted                 │
│ DFS                      │ DFS-related consensus task                   │
└──────────────────────────┴──────────────────────────────────────────────┘
```

PROCESSING FLOW:
```
GRIDNET Core → Browser [VM Meta Data]
  Type: eVMMetaEntryType.consensusTask
  Data: Serialized CConsensusTask
        ↓
CVMContext.processVMMetaData()
        ↓
Deserializes CConsensusTask
        ↓
CVMContext.processIncConsensusTask(task)
        ↓
┌───────────────────────────────────────────┐
│ Internal Processing:                      │
│ 1. Find target thread by threadID         │
│ 2. Update thread state flags:             │
│    - setHasDataCommitPending = true       │
│    - setHasActionsPending = false         │
│ 3. Log event                              │
└───────────────┬───────────────────────────┘
                │
                ▼
┌───────────────────────────────────────────┐
│ Notification Dispatch:                    │
│ 1. Add task to UI update queue            │
│ 2. Notify registered listeners            │
│ 3. Update Magic Button state              │
└───────────────────────────────────────────┘
```

CODE EXAMPLE (CVMContext.js:7251-7300):
```javascript
processIncConsensusTask(task) {
    let thread = this.getThreadByID(task.getThreadID);

    switch (task.getType) {
        case eConsensusTaskType.threadCommitPending:
            // Commit started but not yet authorized
            if (thread) {
                this.mTools.logEvent("Thread's " +
                    this.mTools.arrayBufferToString(thread.getID) +
                    " commit process began.",
                    eLogEntryCategory.VM, 0, eLogEntryType.info);
                thread.setHasDataCommitPending = true;
            }
            break;

        case eConsensusTaskType.threadCommitted:
            // Thread committed successfully
            if (thread) {
                this.mTools.logEvent("Thread " +
                    this.mTools.arrayBufferToString(thread.getID) +
                    " committed successfully.",
                    eLogEntryCategory.VM, 0, eLogEntryType.info);
                thread.setHasActionsPending = false;
            }
            break;

        case eConsensusTaskType.commitAborted:
            // Commit failed
            if (thread) {
                this.mTools.logEvent("Thread's " +
                    this.mTools.arrayBufferToString(thread.getID) +
                    " code commit failed.",
                    eLogEntryCategory.VM, 0, eLogEntryType.info);
            }
            break;
    }

    // Dispatch notifications to other dApps
    // ...
}
```


11.4 REQUEST ID CORRELATION
────────────────────────────────────────────────────────────────────────────

Request IDs tie together related operations across protocols.

REQUEST ID FLOW:
```
Browser Side                         GRIDNET Core Side
────────────                         ─────────────────

1. Generate Request ID
   reqID = ++requestCounter

2. Send Operation
   DFS requestCommit               →  Receives DFS message
   RequestID: 12345                    RequestID: 12345
                                       ↓
                                    3. Spawn Native Thread
                                       metaRequestID = 12345
                                       ↓
                                    4. Send Auth Request
                                       QRIntentAuth
   Receives Auth Request           ←  ReqID: 12345
   ReqID: 12345
   ↓
5. Send Auth Response
   dataResponse                    →  Receives Auth Response
   ReqID: 12345                        ReqID: 12345
                                       ↓
                                    6. Send Commit Result
                                       commitSuccess
   Receives Commit Result          ←  RequestID: 12345
   RequestID: 12345
```

REQUEST ID USAGE:

1. **DFS Protocol**: RequestID in CDFSMsg
   ```javascript
   let dfsMsg = new CDFSMsg(eDFSCmdType.requestCommit, threadID);
   dfsMsg.setRequestID = 12345;
   ```

2. **VM Meta Data Protocol**: ReqID in entries
   ```javascript
   const responseData = {
       reqID: 12345,
       processID: processID,
       type: eUITTaskType.response,
       dataType: eDataRequestType.QRIntentAuth,
       dataFields: [signature, publicKey]
   };
   ```

3. **Listener Filtering**: Filter notifications by requestID
   ```javascript
   this.mVMContext.addNewDFSMsgListener(dfsListener, reqID);
   // Listener only receives messages matching reqID
   ```

4. **Task Correlation**: Find pending task by requestID
   ```javascript
   task = getTaskByMetaReqID(inRespToReqID);
   ```


11.5 ERG (ENERGY) MECHANICS
────────────────────────────────────────────────────────────────────────────

ERG is GRIDNET OS's equivalent to Ethereum's "gas" - the computational
resource required for blockchain operations.

ERG PARAMETERS:
```
┌──────────────┬──────────────────────────────────────────────────────────┐
│ Parameter    │ Description                                              │
├──────────────┼──────────────────────────────────────────────────────────┤
│ ERG Price    │ Cost per ERG unit (set by transaction issuer)           │
│              │ Example: 0.001 GBU per ERG                               │
│              │ Higher price = faster processing priority                │
├──────────────┼──────────────────────────────────────────────────────────┤
│ ERG Bid      │ Maximum ERG willing to pay                               │
│              │ Example: ERG Bid = 1000 ERG                              │
│              │ Transaction aborts if exceeds bid                        │
├──────────────┼──────────────────────────────────────────────────────────┤
│ ERG Limit    │ Maximum ERG allowed for operation                        │
│              │ Prevents runaway computation                             │
├──────────────┼──────────────────────────────────────────────────────────┤
│ ERG Used     │ Actual ERG consumed during execution                     │
│              │ Final transaction cost = ERG Used × ERG Price            │
└──────────────┴──────────────────────────────────────────────────────────┘
```

VALIDATION IN COMMIT FLOW:
```cpp
// In preValidateTransaction() (TransactionManager.cpp)

1. Check ERG Bid
   if (trans->getERGBid() < minimumERGBid) {
       return eTransactionValidationResult::ERGBidTooLow;
   }

2. Check Balance for ERG Cost
   BigInt ergCost = trans->getERGUsed() * trans->getERGPrice();
   if (accountBalance < ergCost) {
       return eTransactionValidationResult::insufficientERG;
   }

3. Check ERG Limit Not Exceeded
   if (actualERGUsed > trans->getERGLimit()) {
       // Abort transaction
   }
```

ERG CALCULATION EXAMPLE:
```
Transaction Details:
  - Operation: send 100 GBU
  - ERG Used: 500 ERG (determined during execution)
  - ERG Price: 0.002 GBU per ERG (set by user)
  - ERG Bid: 1000 ERG (maximum willing to pay)

Cost Calculation:
  Transaction Fee = ERG Used × ERG Price
                  = 500 × 0.002
                  = 1 GBU

Total Cost:
  Transfer Amount: 100 GBU
  Transaction Fee: 1 GBU
  ─────────────────────
  Total Deducted:  101 GBU

Validation Checks:
  ✓ ERG Used (500) < ERG Bid (1000)
  ✓ Balance sufficient for 101 GBU
  ✓ Transaction proceeds
```


11.6 COMMIT LOCKING MECHANISM
────────────────────────────────────────────────────────────────────────────

Commit locks prevent concurrent commits that could cause conflicts.

LOCK USAGE:
```javascript
// In Magic Button or before manual commits
this.mVMContext.tryLockCommit(this, waitIfBusy = true);

// Commit operations...
this.mVMContext.commit(...);

// Release lock
this.mVMContext.freeCommitLock();
```

LOCK RULES:
```
1. BEFORE proposing code that will be committed:
   tryLockCommit() ensures exclusive access to system thread

2. BEFORE invoking commit():
   Lock prevents other dApps from committing simultaneously

3. DURING manipulation of committable thread:
   Lock prevents race conditions during thread state changes

4. ALWAYS call freeCommitLock() when done:
   Otherwise system thread remains locked until timeout
```

WHEN TO USE LOCKS vs DETACHED THREADS:
```
┌──────────────────────────────────────────────────────────────────────┐
│ Use tryLockCommit() when:                                            │
│ ✓ Single-threaded commit (system thread only)                       │
│ ✓ No parallel commits needed                                        │
│ ✓ Cheaper than spawning new thread                                  │
│ ✓ Sufficient for most Wallet operations                             │
└──────────────────────────────────────────────────────────────────────┘

┌──────────────────────────────────────────────────────────────────────┐
│ Use Detached Processing Thread (DPT) when:                          │
│ ✓ Parallel isolated commits needed                                  │
│ ✓ Other commitment already pending                                  │
│ ✓ Want to formulate separate transaction                            │
│ ✓ Need execution on different/multiple nodes                        │
│ ✓ Resources on current node busy                                    │
└──────────────────────────────────────────────────────────────────────┘
```


11.7 BER ENCODING/DECODING
────────────────────────────────────────────────────────────────────────────

BER (Basic Encoding Rules) is used for serializing complex data structures.

WHAT IS BER?
```
BER is a binary encoding format based on ASN.1 (Abstract Syntax Notation One).
GRIDNET OS uses BER for efficient network transmission of:
  • VM Meta Data (requests, responses, notifications)
  • Blockchain objects (blocks, transactions, domains)
  • QRIntents
  • Consensus tasks
```

USAGE IN WALLET:
```javascript
// Browser RARELY encodes directly (handled by CVMContext)
// Browser frequently DECODES incoming data:

1. Deserialize VM Meta Data
   CVMContext automatically decodes BER-encoded network messages

2. Deserialize Objects
   let block = CBlockDesc.instantiate(berEncodedData);
   let tx = CTransactionDesc.instantiate(berEncodedData);
   let domain = CDomainDesc.instantiate(berEncodedData);

3. Serialize for Network
   let qrBytes = qrIntent.getPackedData(); // Returns BER-encoded
```

BER DATA FLOW:
```
GRIDNET Core Side                    Browser Side
─────────────────                    ────────────

1. Create Object
   CTransaction tx;
   tx.setIssuer(...);
   tx.setCode(...);

2. Serialize to BER
   vector<uint8_t> berData =
       tx.getPackedData();
                                  →  3. Network Transmission
                                       BER-encoded bytes
                                       ↓
                                    4. Deserialize
                                       let tx =
                                         CTransactionDesc.instantiate(
                                           berData
                                         );
                                       ↓
                                    5. Use Object
                                       let amount = tx.getValue;
                                       let sender = tx.getIssuer;
```


11.8 THREAD FLAGS (eVMFlags)
────────────────────────────────────────────────────────────────────────────

Thread flags control thread behavior and access permissions.

COMMON FLAGS:
```
┌────────────────┬──────────────────────────────────────────────────────┐
│ Flag           │ Purpose                                              │
├────────────────┼──────────────────────────────────────────────────────┤
│ private        │ Thread accessible only to creating dApp              │
│                │ Use for: Sensitive operations, isolated transactions │
├────────────────┼──────────────────────────────────────────────────────┤
│ public         │ Thread accessible to all dApps                       │
│                │ Use for: Shared resources, collaborative operations  │
├────────────────┼──────────────────────────────────────────────────────┤
│ committable    │ Thread ready for blockchain commit                   │
│                │ Automatically set by 'rt' (ready-thread) command     │
└────────────────┴──────────────────────────────────────────────────────┘
```

USAGE:
```javascript
// Create private thread for batch transactions
const threadID = this.mTools.stringToBytes('batch-tx-thread');
await this.mVMContext.createThreadA(
    threadID,
    eVMFlags.private,  // Only this dApp can access
    this
);

// Execute operations on private thread
await this.mVMContext.processGridScriptA(
    "send 10 GBU to alice@domain.grid",
    eVMMetaCodeExecutionMode.RAW,
    threadID
);

await this.mVMContext.processGridScriptA(
    "send 20 GBU to bob@domain.grid",
    eVMMetaCodeExecutionMode.RAW,
    threadID
);

// Mark as ready for commit
await this.mVMContext.processGridScriptA(
    "rt",  // ready-thread
    eVMMetaCodeExecutionMode.RAW,
    threadID
);

// Commit this thread specifically
await this.mVMContext.commit(this, false, threadID);
```


11.9 BALANCE AND HISTORY RETRIEVAL
────────────────────────────────────────────────────────────────────────────

BALANCE QUERY:
```javascript
// In Wallet.js retrieveBalance()

async retrieveBalance() {
    const address = this.mCurrentDomain;

    // Use data thread for read-only operation
    const result = await this.mVMContext.processGridScriptA(
        `balance ${address}`,
        eVMMetaCodeExecutionMode.RAW,  // RAW mode for reads
        'data',                          // Data thread (shared, non-blocking)
        this
    );

    // Parse result
    const balance = parseFloat(result.topMostValue);
    this.updateBalanceDisplay(balance);
}
```

TRANSACTION HISTORY:
```javascript
// In Wallet.js loadTransactionHistory()

async loadTransactionHistory(size = 50, page = 0) {
    const address = this.mCurrentDomain;

    // Query history via data thread
    const result = await this.mVMContext.processGridScriptA(
        `history ${address} ${size} ${page}`,
        eVMMetaCodeExecutionMode.RAW,
        'data',
        this
    );

    // Result contains BER-encoded transaction descriptors
    const transactions = this.parseTransactionHistory(result.data);
    this.displayTransactionHistory(transactions);
}
```

KEY POINTS:
```
✓ Always use data thread for balance/history queries
✓ Use RAW execution mode for performance
✓ Data thread operations work during pending commits
✓ Results returned via VM Meta Data protocol
✓ No authentication required for read operations
```


11.10 QRINTENT STRUCTURE
────────────────────────────────────────────────────────────────────────────

QRIntent encapsulates authentication requests.

STRUCTURE:
```javascript
CQRIntent {
    mType: eQRIntentType              // QRSign, QRAuth, etc.
    mRecipientID: ArrayBuffer         // Target VM/endpoint ID
    mRecipientType: eEndpointType     // VM, IPv4, TerminalID, etc.
    mData: ArrayBuffer                // Data to sign (transaction hash)
    mInfo: ArrayBuffer                // Additional info (node IP, etc.)
    mPubKey: ArrayBuffer              // Encryption public key
}
```

TYPES:
```
eQRIntentType.QRSign:
  Purpose: Request signature of data
  Used in: Transaction commits
  Data contains: Transaction hash to sign

eQRIntentType.QRAuth:
  Purpose: Request authentication
  Used in: Login, identity verification
  Data contains: Challenge data
```

USAGE IN COMMIT FLOW:
```
GRIDNET Core Side:
──────────────────
// In commitThreads() when auth needed
qr = std::make_shared<CQRIntent>(
    eQRIntentType::QRSign,     // Requesting signature
    recipientID,               // Browser VM ID
    nodeIP,                    // Node IP address
    eEndpointType::VM          // Target is VM
);
qr->setPubKey(encRespToPubKey);  // Encryption key
qr->setData(dataToSign);          // Transaction hash

// Serialize and send
std::vector<uint8_t> serializedQR = qr->getPackedData();
mMetaGenerator->addDataRequest(
    eDataRequestType::QRIntentAuth,
    serializedQR,
    getMetaRequestID(),
    getID()
);


Browser Side:
─────────────
// In processVMMetaDataRequest()
const qr = CQRIntent.instantiate(request.defaultValue);

// Extract data to sign
const dataToSign = qr.getData();  // Transaction hash

// Sign with keychain
const signature = this.mCrypto.sign(privateKey, dataToSign);

// Send response
const responseData = {
    reqID: request.id,
    dataFields: [signature, publicKey]
};
```


================================================================================
11. IDENTITY TOKEN DEPLOYMENT
================================================================================

Identity Tokens are on-chain identity credentials in GRIDNET OS that provide
verifiable proof of identity commitment through cryptographic mechanisms and
economic sacrifice. The Wallet UI dApp implements a comprehensive 4-step wizard
for deploying Identity Tokens with support for two transaction modes.


11.1 OVERVIEW
────────────────────────────────────────────────────────────────────────────

WHAT IS AN IDENTITY TOKEN?

An Identity Token (CIdentityToken) is a blockchain-registered credential that:
- Proves commitment through a sacrificial transaction (burning GNC)
- Associates a public key with a human-friendly nickname
- Becomes part of the permanent blockchain record
- Cannot be modified once deployed (immutable identity)

TYPES OF IDENTITY TOKENS:

```javascript
eIdentityTokenType.Basic    // Basic identity token
eIdentityTokenType.PoW      // Proof-of-Work based token
eIdentityTokenType.Stake    // Stake-based token (most common)
eIdentityTokenType.Hybrid   // Combines PoW and Stake
```

The Wallet UI dApp primarily uses **Stake-based tokens** requiring a
sacrificial transaction where GNC is permanently consumed (minimum 1 GNC).


11.2 DEPLOYMENT PROCESS OVERVIEW
────────────────────────────────────────────────────────────────────────────

Identity Token deployment requires TWO distinct transactions:

┌─────────────────────────────────────────────────────────────────────────┐
│                    IDENTITY TOKEN DEPLOYMENT FLOW                       │
└─────────────────────────────────────────────────────────────────────────┘

TRANSACTION 1: SACRIFICIAL TRANSACTION
┌──────────────────────────────────────┐
│  GridScript Command: sacrifice       │
│  Purpose: Burn GNC to prove commitment│
│  Amount: User-specified (≥ 1 GNC)    │
│  Mode: Local OR DPT (user settings)  │
│  Result: Receipt ID + Sacrificed Value│
└──────────────────────────────────────┘
                 │
                 ▼
┌──────────────────────────────────────┐
│  VERIFICATION PHASE                  │
│  - Check transaction status          │
│  - Verify sacrificedValue > 0        │
│  - Wait for confirmation             │
└──────────────────────────────────────┘
                 │
                 ▼
TRANSACTION 2: REGISTRATION TRANSACTION
┌──────────────────────────────────────┐
│  DPT Mode:                           │
│  - genid (generate token)            │
│  - regid (register token)            │
│  - txconfig (set ERG)                │
│  - commitActions()                   │
│                                      │
│  Local Mode:                         │
│  - Generate CIdentityToken locally   │
│  - adata58 (push token to stack)     │
│  - regid (register from stack)       │
│  - Local compilation & broadcast     │
└──────────────────────────────────────┘


11.3 TWO TRANSACTION MODES
────────────────────────────────────────────────────────────────────────────

The Wallet supports two distinct modes for Identity Token deployment, controlled
by the global wallet setting `mLocalTransactionMode`.


11.3.1 DECENTRALIZED PROCESSING THREAD (DPT) MODE
──────────────────────────────────────────────────

CHARACTERISTICS:
- Server-side transaction formulation and compilation
- Uses GRIDNET Core's GridScript VM for token generation
- Leverages threading isolation for concurrent operations
- Requires Magic Button API for commitment
- Uses DFS Protocol callbacks for result notification

SACRIFICE TRANSACTION (DPT Mode):
```javascript
async executeSacrificeDPT(amount) {
    const amountAtto = this.mTools.GNCToAtto(amount);

    // Build GridScript command sequence
    let cmd = `bt\n`;                           // Begin transaction
    cmd += `txconfig -setbid 1\n`;              // Set ERG price
    cmd += `txconfig -setlimit 100000000\n`;    // Set ERG limit
    cmd += `sacrifice ${amountAtto.toString()}\n`;  // Sacrifice GNC
    cmd += `rt`;                                // Ready thread

    // Execute through DPT
    const result = await this.mVMContext.processGridScriptA(
        cmd,
        this.getThreadID,
        this
    );

    // Add consensus task for UI tracking
    const task = new CConsensusTask(
        `Sacrifice Transaction (${this.mTools.formatGNCValue(amountAtto)} GNC)`
    );
    this.mVMContext.addConsensusTask(task);

    // Commit via Magic Button
    this.mVMContext.getMagicButton.commitActions();

    // Receipt ID captured in onDFSMessage callback
}
```

REGISTRATION TRANSACTION (DPT Mode):
```javascript
async deployIdentityTokenDPT(publicKeyBase58) {
    // Step 1: Generate identity token on server
    const genidCmd = `genid -p ${publicKeyBase58} ` +
                    `-f ${this.mIdentityWizard.nickname} ` +
                    `-r ${this.mIdentityWizard.sacrificeReceiptID}`;

    const genidResult = await this.mVMContext.processGridScriptA(
        genidCmd,
        this.getThreadID,
        this
    );

    if (!genidResult || genidResult.status !== 0) {
        throw new Error(`Token generation failed: ${genidResult?.errorMessage}`);
    }

    // Step 2: Register the generated token
    const regidCmd = `regid`;
    const regidResult = await this.mVMContext.processGridScriptA(
        regidCmd,
        this.getThreadID,
        this
    );

    if (!regidResult || regidResult.status !== 0) {
        throw new Error(`Token registration failed: ${regidResult?.errorMessage}`);
    }

    // Step 3: Configure ERG and ready thread
    let configCmd = `txconfig -setbid 1\n`;
    configCmd += `txconfig -setlimit 100000000\n`;
    configCmd += `rt`;

    const configResult = await this.mVMContext.processGridScriptA(
        configCmd,
        this.getThreadID,
        this
    );

    if (!configResult || configResult.status !== 0) {
        throw new Error(`Transaction config failed: ${configResult?.errorMessage}`);
    }

    // Step 4: Commit all operations
    this.mIdentityWizard.waitingForCommit = true;
    this.mVMContext.getMagicButton.commitActions();

    // Result handled in onDFSMessage() callback
}
```

GRIDSCRIPT COMMANDS (DPT Mode):
```
genid -p <base58_public_key> -f <friendly_name> -r <receipt_id>
  Purpose: Generates CIdentityToken server-side
  Arguments:
    -p: Base58Check encoded public key
    -f: Friendly identifier (nickname)
    -r: Receipt ID from sacrificial transaction
  Result: Token stored in thread context

regid
  Purpose: Registers identity token from thread context
  Pre-condition: genid must have been called
  Result: Token added to blockchain state

txconfig -setbid <value>
  Purpose: Set ERG price for transaction
  Value: 1 (standard rate)

txconfig -setlimit <value>
  Purpose: Set ERG limit for transaction
  Value: 100000000 (generous limit for registration)
```


11.3.2 LOCAL TRANSACTION MODE (TRUSTLESS MODE)
───────────────────────────────────────────────

CHARACTERISTICS:
- Client-side transaction formulation and compilation
- Browser generates CIdentityToken locally
- No server-side state or token generation
- Pre-validation ensures correctness before broadcast
- Immediate feedback (no DFS callback needed)

SACRIFICE TRANSACTION (Local Mode):
Same as DPT mode but compiled locally using GridScriptCompiler.

REGISTRATION TRANSACTION (Local Mode):
```javascript
async deployIdentityTokenLocal(publicKey, publicKeyBase58) {
    // ═══════════════════════════════════════════════════════════════════
    // STEP 1: GENERATE IDENTITY TOKEN LOCALLY
    // ═══════════════════════════════════════════════════════════════════

    // Retrieve sacrifice transaction details
    const txDesc = await this.mVMContext.getTransactionDetailsA(
        this.mIdentityWizard.sacrificeReceiptID
    );
    const sacrificedValue = txDesc.sacrificedValue || BigInt(0);

    // Decode receipt ID to bytes
    const receiptIDBytes = this.mTools.base58CheckDecode(
        this.mIdentityWizard.sacrificeReceiptID
    );

    // Create CIdentityToken with all required fields
    const identityToken = new CIdentityToken(
        eIdentityTokenType.Stake,        // Type: Stake-based token
        publicKey,                        // Public key (Uint8Array)
        0,                                // PoW (0 for Stake type)
        sacrificedValue,                  // Consumed coins (BigInt)
        "",                               // IOT Address (empty for Stake)
        receiptIDBytes,                   // Receipt ID (Uint8Array)
        new Uint8Array(),                 // Additional data (empty)
        this.mIdentityWizard.nickname     // Friendly ID (string)
    );

    // Serialize token using BER encoding
    const packedToken = identityToken.getPackedData();

    // Base58Check encode for GridScript
    const tokenBase58 = this.mTools.base58CheckEncode(packedToken);


    // ═══════════════════════════════════════════════════════════════════
    // STEP 2: PRE-VALIDATE COMPLETE GRIDSCRIPT SEQUENCE
    // ═══════════════════════════════════════════════════════════════════

    // Build COMPLETE transaction command sequence
    let fullValidationSequence = `bt\n`;                  // Begin transaction
    fullValidationSequence += `txconfig -setbid 1\n`;     // Set ERG price
    fullValidationSequence += `txconfig -setlimit 100000000\n`;  // Set ERG limit
    fullValidationSequence += `adata58 ${tokenBase58}\n`; // Push token to stack
    fullValidationSequence += `regid\n`;                  // Register from stack
    fullValidationSequence += `rt`;                       // Ready thread

    // Pre-validate with GRIDNET Core before compilation
    const validationResult = await this.mVMContext.processGridScriptA(
        fullValidationSequence,
        this.getThreadID,
        this
    );

    if (!validationResult || validationResult.status !== 0) {
        throw new Error(
            `Pre-validation failed: ${validationResult?.errorMessage || 'Unknown error'}`
        );
    }

    // Validation checks performed by Core:
    // - Receipt ID exists and is valid
    // - Receipt has not been consumed by another token
    // - Sacrificed value > 0
    // - Token structure is valid (BER decoding)
    // - Signature verification (if applicable)
    // - Nickname is available (not taken)
    // - Domain ownership validation
    // - ERG configuration validity
    // - All security checks from C++ regID() implementation


    // ═══════════════════════════════════════════════════════════════════
    // STEP 3: COMPILE LOCALLY
    // ═══════════════════════════════════════════════════════════════════

    const sourceCode = fullValidationSequence;
    const compiler = new GridScriptCompiler(this.mCurrentDomain);
    const compileResult = compiler.compile(sourceCode);

    if (!compileResult.success) {
        throw new Error(`Compilation failed: ${compileResult.error}`);
    }

    // Encode bytecode with SHA-256 checksum
    const base64Bytecode = await GridScriptCompiler.base64CheckEncode(
        compileResult.bytecode
    );


    // ═══════════════════════════════════════════════════════════════════
    // STEP 4: SUBMIT PRE-COMPILED TRANSACTION
    // ═══════════════════════════════════════════════════════════════════

    const submitResult = await this.mVMContext.submitPreCompiledTransactionA(
        base64Bytecode,
        this.mTools.stringToByteVector(sourceCode),
        this
    );

    if (!submitResult || !submitResult.success) {
        throw new Error(`Submission failed: ${submitResult?.error}`);
    }

    // Success! No DFS callback needed for local mode
    this.handleIdentityTokenDeploymentSuccess();
}
```

GRIDSCRIPT COMMANDS (Local Mode):
```
adata58 <base58_encoded_data>
  Purpose: Push base58-encoded data onto stack
  Argument: Base58Check encoded serialized CIdentityToken
  Result: Binary data on stack

regid
  Purpose: Register identity token from stack
  Pre-condition: Stack must contain serialized CIdentityToken
  Result: Token added to blockchain state
```

KEY DIFFERENCES BETWEEN MODES:

┌─────────────────────┬────────────────────────┬──────────────────────────┐
│   Aspect            │   DPT Mode             │   Local Mode             │
├─────────────────────┼────────────────────────┼──────────────────────────┤
│ Token Generation    │ Server-side (genid)    │ Client-side (CIdentityToken)│
│ Token Location      │ Thread context         │ Browser memory           │
│ Commands            │ genid + regid          │ adata58 + regid          │
│ Compilation         │ Server-side            │ Client-side (GridScriptCompiler)│
│ Result Notification │ DFS callback           │ Immediate (submitResult) │
│ Security Model      │ Trust server           │ Trustless (verify all)   │
│ Pre-validation      │ Each command           │ Complete sequence        │
└─────────────────────┴────────────────────────┴──────────────────────────┘


11.4 WIZARD STATE MACHINE
────────────────────────────────────────────────────────────────────────────

The Identity Token Wizard is implemented as a state machine tracking progress
through deployment stages.

STATE OBJECT:
```javascript
this.mIdentityWizard = {
    currentStep: 1,              // Current wizard step (1-4)
    sacrificeReceiptID: null,    // Receipt ID from sacrifice transaction
    sacrificeTxVerified: false,  // Has sacrifice been verified?
    nickname: '',                // User-chosen friendly identifier
    isWalletIssued: false,       // Was sacrifice issued by wallet?
    waitingForCommit: false,     // Waiting for DFS callback?
    verificationTimer: null,     // Polling timer for verification
    verificationStartTime: null  // When verification started
};
```

STATE TRANSITIONS:

```
┌─────────────────────────────────────────────────────────────────────────┐
│                        WIZARD STATE MACHINE                             │
└─────────────────────────────────────────────────────────────────────────┘

STEP 1: SACRIFICE
┌────────────────────────────────────┐
│ State:                             │
│  currentStep = 1                   │
│  sacrificeReceiptID = null         │
│  isWalletIssued = false            │
│                                    │
│ User Actions:                      │
│  - Create new sacrifice OR         │
│  - Provide existing receipt ID     │
│                                    │
│ Transitions:                       │
│  ✓ Create new → STEP 2             │
│  ✓ Provide existing → STEP 2       │
│  ✗ Cancel → Exit wizard            │
└────────────────────────────────────┘
          │
          ▼
STEP 2: VERIFICATION
┌────────────────────────────────────┐
│ State:                             │
│  currentStep = 2                   │
│  sacrificeReceiptID = <value>      │
│  sacrificeTxVerified = false       │
│  verificationTimer = <interval>    │
│  verificationStartTime = <time>    │
│                                    │
│ Automatic Actions:                 │
│  - Poll transaction status         │
│  - Verify sacrificedValue > 0      │
│  - Update elapsed time display     │
│                                    │
│ Transitions:                       │
│  ✓ Valid sacrifice → STEP 3        │
│  ✗ Invalid sacrifice → Error state │
│  ⏱ Polling → Repeat verification   │
└────────────────────────────────────┘
          │
          ▼
STEP 3: NICKNAME
┌────────────────────────────────────┐
│ State:                             │
│  currentStep = 3                   │
│  sacrificeTxVerified = true        │
│  nickname = ''                     │
│                                    │
│ User Actions:                      │
│  - Enter nickname (≥3 chars)       │
│                                    │
│ Transitions:                       │
│  ✓ Valid nickname → STEP 4         │
│  ✗ Invalid → Show error            │
│  ← Back → STEP 1                   │
└────────────────────────────────────┘
          │
          ▼
STEP 4: DEPLOY
┌────────────────────────────────────┐
│ State:                             │
│  currentStep = 4                   │
│  nickname = <value>                │
│  waitingForCommit = true (DPT)     │
│                                    │
│ Automatic Actions:                 │
│  - Generate/register token         │
│  - Display progress indicators     │
│                                    │
│ Transitions:                       │
│  ✓ Success → Show success screen   │
│  ✗ Failure → Show error            │
│  ← Back → STEP 3                   │
└────────────────────────────────────┘
```

STATE VALIDATION RULES:

Step 1 → Step 2:
  ✓ Must have sacrificeReceiptID (either new or provided)

Step 2 → Step 3:
  ✓ Transaction status must be 'Success' or 'Confirmed'
  ✓ sacrificedValue must be > 0
  ✓ Transaction must exist on blockchain

Step 3 → Step 4:
  ✓ Nickname must be ≥ 3 characters
  ✓ Nickname must be set (not empty)

Step 4 → Complete:
  ✓ Token generation succeeded (no error)
  ✓ Token registration succeeded (no error)
  ✓ Commit succeeded (DPT) or submission succeeded (Local)


11.5 WIZARD IMPLEMENTATION DETAILS
────────────────────────────────────────────────────────────────────────────

11.5.1 STEP 1: SACRIFICIAL TRANSACTION
───────────────────────────────────────

PURPOSE:
Prove commitment by permanently burning GNC. This prevents spam and ensures
only serious participants deploy identity tokens.

UI ELEMENTS:
```
┌─────────────────────────────────────────────────────┐
│ Step 1: Sacrificial Transaction                     │
│                                                     │
│ Transaction Mode: [Local Transaction (Trustless)]  │
│                                                     │
│ Choose an option:                                   │
│                                                     │
│ ○ Create New Sacrifice                             │
│   Amount: [____] GNC (minimum 1 GNC)               │
│   [Create Transaction]                             │
│                                                     │
│ ○ Use Existing Transaction                         │
│   Receipt ID: [________________________________]    │
│   [Verify & Continue]                              │
│                                                     │
│ [Cancel]                                           │
└─────────────────────────────────────────────────────┘
```

VALIDATION:
- Amount must be ≥ 1 GNC for new transactions
- Receipt ID must be valid Base58Check format
- Transaction mode badge shows current wallet setting

CODE FLOW:
```javascript
// User clicks "Create Transaction"
async executeSacrificeTransaction(amount) {
    if (this.mLocalTransactionMode) {
        await this.executeSacrificeLocal(amount);
    } else {
        await this.executeSacrificeDPT(amount);
    }

    // Set state for verification phase
    this.mIdentityWizard.isWalletIssued = true;
    this.mIdentityWizard.currentStep = 2;
    this.renderWizardStep();
}

// User provides existing receipt ID
async useExistingSacrifice(receiptID) {
    this.mIdentityWizard.sacrificeReceiptID = receiptID;
    this.mIdentityWizard.isWalletIssued = false;
    this.mIdentityWizard.currentStep = 2;
    this.renderWizardStep();
}
```


11.5.2 STEP 2: TRANSACTION VERIFICATION
────────────────────────────────────────

PURPOSE:
Ensure the sacrificial transaction succeeded and has non-zero sacrificed value
before proceeding to token deployment.

UI ELEMENTS:
```
┌─────────────────────────────────────────────────────┐
│ Step 2: Verifying Transaction                       │
│                                                     │
│ Receipt ID: abc123...xyz                           │
│                                                     │
│ Status: [Checking...] ⏱ Elapsed: 00:15            │
│                                                     │
│ Waiting for transaction confirmation...            │
│ This may take a few moments.                       │
│                                                     │
│ [Cancel]                                           │
└─────────────────────────────────────────────────────┘
```

VERIFICATION LOGIC:
```javascript
async verifySacrificeTransaction() {
    const txDesc = await this.mVMContext.getTransactionDetailsA(
        this.mIdentityWizard.sacrificeReceiptID
    );

    if (!txDesc) {
        // Transaction not found
        this.showError('Transaction not found on blockchain');
        return false;
    }

    const status = txDesc.status;  // 'Success', 'Confirmed', 'Pending', 'Failed'
    const sacrificedValue = txDesc.sacrificedValue || BigInt(0);

    if (status === 'Success' || status === 'Confirmed') {
        if (sacrificedValue > BigInt(0)) {
            // Valid sacrifice!
            this.mIdentityWizard.sacrificeTxVerified = true;
            this.mIdentityWizard.currentStep = 3;
            this.renderWizardStep();
            return true;
        } else {
            // Transaction succeeded but no value sacrificed
            this.showError('Invalid sacrifice: No GNC was consumed');
            return false;
        }
    } else if (status === 'Failed') {
        this.showError('Sacrificial transaction failed');
        return false;
    }

    // Still pending, continue polling
    return false;
}
```

POLLING MECHANISM:
```javascript
async pollSacrificeTransaction() {
    const maxAttempts = 60;  // 2 minutes max for non-wallet transactions
    let attempts = 0;

    this.mIdentityWizard.verificationStartTime = Date.now();

    this.mIdentityWizard.verificationTimer = setInterval(async () => {
        // Update elapsed time display
        const elapsed = Math.floor((Date.now() - this.mIdentityWizard.verificationStartTime) / 1000);
        const minutes = Math.floor(elapsed / 60);
        const seconds = elapsed % 60;
        document.querySelector('.verification-timer').textContent =
            `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;

        // Check transaction
        const verified = await this.verifySacrificeTransaction();

        if (verified) {
            clearInterval(this.mIdentityWizard.verificationTimer);
            return;
        }

        // For non-wallet transactions, timeout after max attempts
        if (!this.mIdentityWizard.isWalletIssued) {
            attempts++;
            if (attempts >= maxAttempts) {
                clearInterval(this.mIdentityWizard.verificationTimer);
                this.showError('Transaction verification timeout');
            }
        }
        // For wallet-issued transactions, poll indefinitely
    }, 2000);  // Poll every 2 seconds
}
```

BEHAVIOR DIFFERENCES:

Wallet-Issued Transaction:
  - Polls indefinitely (no timeout)
  - Shows elapsed time
  - User can cancel manually

User-Provided Receipt ID:
  - Polls for 2 minutes maximum
  - Shows immediate error if not found
  - Times out if never confirms


11.5.3 STEP 3: NICKNAME SELECTION
──────────────────────────────────

PURPOSE:
Allow user to choose a permanent human-friendly identifier for their identity.

UI ELEMENTS:
```
┌─────────────────────────────────────────────────────┐
│ Step 3: Choose Your Nickname                        │
│                                                     │
│ ⚠ WARNING: This nickname is PERMANENT and cannot   │
│   be changed once deployed!                        │
│                                                     │
│ Nickname: [__________________]                     │
│           (minimum 3 characters)                   │
│                                                     │
│ [← Back]  [Continue →]                             │
└─────────────────────────────────────────────────────┘
```

VALIDATION:
```javascript
function validateNickname(nickname) {
    if (!nickname || nickname.trim().length < 3) {
        return { valid: false, error: 'Nickname must be at least 3 characters' };
    }

    // Additional validation can be added:
    // - Character restrictions
    // - Profanity filtering
    // - Length limits

    return { valid: true };
}
```

CODE FLOW:
```javascript
async proceedToDeployment() {
    const nickname = document.querySelector('#nickname-input').value;
    const validation = this.validateNickname(nickname);

    if (!validation.valid) {
        this.showError(validation.error);
        return;
    }

    this.mIdentityWizard.nickname = nickname;
    this.mIdentityWizard.currentStep = 4;
    this.renderWizardStep();

    // Automatically start deployment
    await this.deployIdentityToken();
}
```


11.5.4 STEP 4: TOKEN DEPLOYMENT
────────────────────────────────

PURPOSE:
Generate and register the identity token on the blockchain using the
collected information.

UI ELEMENTS:
```
┌─────────────────────────────────────────────────────┐
│ Step 4: Deploying Identity Token                    │
│                                                     │
│ Mode: Local Transaction (Trustless)                │
│                                                     │
│ Review:                                            │
│  Nickname: JohnDoe                                 │
│  Public Key: GN1abc123...xyz                       │
│  Sacrifice: 10.5 GNC                               │
│  Receipt ID: rec_abc123...xyz                      │
│                                                     │
│ Progress:                                          │
│  ✓ Generating identity token locally               │
│  ✓ Pre-validating command sequence                 │
│  ⏳ Compiling transaction                           │
│  ⏸ Broadcasting to network                         │
│                                                     │
└─────────────────────────────────────────────────────┘
```

PROGRESS TRACKING:

DPT Mode:
```
✓ Generating identity token (genid)
✓ Registering identity token (regid)
✓ Configuring transaction (txconfig)
⏳ Committing to blockchain (Magic Button)
⏸ Waiting for confirmation
```

Local Mode:
```
✓ Generating identity token locally
✓ Pre-validating command sequence
✓ Compiling transaction bytecode
⏳ Broadcasting to network
⏸ Waiting for confirmation
```

CODE FLOW:
```javascript
async deployIdentityToken() {
    // Update UI to show Step 4
    this.mIdentityWizard.currentStep = 4;
    this.renderWizardStep();

    // Get public key from current domain
    const domainDesc = await this.mVMContext.getDomainDetailsA(this.mCurrentDomain);
    const publicKey = domainDesc.publicKey;  // Uint8Array
    const publicKeyBase58 = this.mTools.encodeBase58Check(publicKey);

    try {
        // Route to appropriate deployment method
        if (this.mLocalTransactionMode) {
            await this.deployIdentityTokenLocal(publicKey, publicKeyBase58);
        } else {
            await this.deployIdentityTokenDPT(publicKeyBase58);
        }
    } catch (error) {
        this.handleIdentityTokenDeploymentFailure(error.message);
    }
}
```


11.6 PRE-VALIDATION MECHANICS
────────────────────────────────────────────────────────────────────────────

Pre-validation is a CRITICAL security and UX feature that validates the
complete GridScript command sequence with GRIDNET Core BEFORE local
compilation or commitment.

PURPOSE:
- Catch errors early (before wasting time on compilation)
- Ensure receipt ID is valid and unconsumed
- Verify nickname availability
- Validate token structure and signature
- Check domain ownership and permissions
- Confirm ERG configuration validity

PROCESS:

```
┌─────────────────────────────────────────────────────────────────────────┐
│                       PRE-VALIDATION FLOW                               │
└─────────────────────────────────────────────────────────────────────────┘

1. BUILD COMPLETE COMMAND SEQUENCE
   ┌──────────────────────────────────────┐
   │ bt                                   │
   │ txconfig -setbid 1                   │
   │ txconfig -setlimit 100000000         │
   │ adata58 <base58_encoded_token>       │
   │ regid                                │
   │ rt                                   │
   └──────────────────────────────────────┘
            │
            ▼
2. SEND TO GRIDNET CORE VIA processGridScriptA()
   ┌──────────────────────────────────────┐
   │ mVMContext.processGridScriptA(       │
   │   fullValidationSequence,            │
   │   threadID,                          │
   │   callback                           │
   │ )                                    │
   └──────────────────────────────────────┘
            │
            ▼
3. CORE VALIDATES ENTIRE SEQUENCE
   ┌──────────────────────────────────────┐
   │ - Parse all commands                 │
   │ - Execute in VM context              │
   │ - Check receipt consumption          │
   │ - Verify token structure (BER)       │
   │ - Check nickname availability        │
   │ - Validate domain ownership          │
   │ - Verify ERG configuration           │
   │ - Run all regID() security checks    │
   └──────────────────────────────────────┘
            │
            ├─── SUCCESS (status = 0) ──────┐
            │                                │
            └─── FAILURE (status != 0) ─────┤
                                            │
                                            ▼
4. HANDLE RESULT
   ┌──────────────────────────────────────┐
   │ if (status === 0) {                  │
   │   // Proceed with compilation        │
   │ } else {                             │
   │   // Show error, abort deployment    │
   │ }                                    │
   └──────────────────────────────────────┘
```

VALIDATION CHECKS PERFORMED BY CORE:

Receipt ID Validation:
  ✓ Receipt exists on blockchain
  ✓ Receipt corresponds to valid transaction
  ✓ Receipt has not been consumed by another identity token
  ✓ Receipt transaction succeeded (not failed)

Sacrifice Validation:
  ✓ Sacrificed value > 0
  ✓ Transaction type includes sacrifice operation
  ✓ Value matches token claim

Token Structure Validation:
  ✓ BER decoding succeeds
  ✓ All required fields present
  ✓ Field types correct (BigInt, Uint8Array, etc.)
  ✓ Token type valid (Stake, PoW, Hybrid)
  ✓ Public key format valid

Nickname Validation:
  ✓ Nickname not already taken
  ✓ Nickname meets length requirements
  ✓ Nickname meets character requirements

Domain Validation:
  ✓ Caller owns the domain
  ✓ Domain not already has identity token
  ✓ Domain is active and valid

ERG Configuration Validation:
  ✓ ERG bid is valid value
  ✓ ERG limit is sufficient for operation
  ✓ Caller has sufficient balance

Security Validation:
  ✓ Signature verification (if token signed)
  ✓ No double-registration attempts
  ✓ Thread state consistency

EXAMPLE VALIDATION RESULT:

Success:
```javascript
{
    status: 0,
    errorMessage: null,
    result: <execution_result>
}
```

Failure:
```javascript
{
    status: -1,
    errorMessage: "Receipt ID has already been consumed by another identity token",
    result: null
}
```

WHY PRE-VALIDATION MATTERS:

WITHOUT Pre-Validation:
  1. User waits for local compilation (~1-2 seconds)
  2. Transaction broadcasts to network
  3. Transaction gets rejected by Core
  4. User sees error AFTER wasting time and bandwidth
  5. No helpful error message (just "transaction failed")

WITH Pre-Validation:
  1. Validation happens immediately (~200ms)
  2. Detailed error message from Core
  3. No compilation or broadcast on error
  4. User gets instant, actionable feedback
  5. Saves time, bandwidth, and improves UX


11.7 CALLBACK HANDLING AND RESULT NOTIFICATION
────────────────────────────────────────────────────────────────────────────

11.7.1 DPT MODE CALLBACKS
──────────────────────────

DPT mode uses the DFS Protocol for commit result notification.

CALLBACK FLOW:

```
Wallet                        CVMContext                   GRIDNET Core
  │                                │                             │
  │ commitActions()                │                             │
  ├────────────────────────────────>                             │
  │                                │                             │
  │                                │ WebSocket: DFS Commit       │
  │                                ├─────────────────────────────>
  │                                │                             │
  │                                │  ... blockchain processing ..│
  │                                │                             │
  │                                │ ◄─ commitSuccess/Aborted ───┤
  │                                │                             │
  │ onDFSMessage(commitSuccess)    │                             │
  │◄────────────────────────────────                             │
  │                                                              │
  │ handleIdentityTokenDeploymentSuccess()                       │
  └──────────────────────────────────────────────────────────────┘
```

IMPLEMENTATION:

```javascript
// In wallet.js
onDFSMessage(cmd, param) {
    switch(cmd) {
        case eDFSCmdType.commitSuccess:
            // Check if this is an identity token deployment
            if (this.mIdentityWizard && this.mIdentityWizard.waitingForCommit) {
                const receiptID = param.receiptID;
                this.handleIdentityTokenDeploymentSuccess(receiptID);
            }
            // Check if this is a wallet-issued sacrifice transaction
            else if (this.mIdentityWizard &&
                     this.mIdentityWizard.isWalletIssued &&
                     !this.mIdentityWizard.sacrificeReceiptID) {
                // Capture receipt ID from sacrifice transaction
                this.mIdentityWizard.sacrificeReceiptID = param.receiptID;
                // Verification polling will handle the rest
            }
            // Regular transaction handling
            else {
                this.handleTransactionSuccess(param);
            }
            break;

        case eDFSCmdType.commitAborted:
            if (this.mIdentityWizard && this.mIdentityWizard.waitingForCommit) {
                const reason = param.reason || 'Unknown error';
                this.handleIdentityTokenDeploymentFailure(reason);
            } else {
                this.handleTransactionFailure(param);
            }
            break;
    }
}

handleIdentityTokenDeploymentSuccess(receiptID) {
    // Clear waiting state
    this.mIdentityWizard.waitingForCommit = false;

    // Show success UI
    const successHTML = `
        <div class="identity-success">
            <div class="success-icon">✓</div>
            <h2>Identity Token Deployed Successfully!</h2>
            <p>Your identity token has been registered on the blockchain.</p>
            <div class="token-details">
                <p><strong>Nickname:</strong> ${this.mIdentityWizard.nickname}</p>
                <p><strong>Receipt ID:</strong> ${receiptID}</p>
            </div>
            <button onclick="wallet.loadIdentityStatus()">View Identity Token</button>
        </div>
    `;

    document.querySelector('#identity-wizard-container').innerHTML = successHTML;

    // Refresh identity data
    this.refreshDomainDetails();
}

handleIdentityTokenDeploymentFailure(reason) {
    this.mIdentityWizard.waitingForCommit = false;

    const errorHTML = `
        <div class="identity-error">
            <div class="error-icon">✗</div>
            <h2>Identity Token Deployment Failed</h2>
            <p class="error-reason">${reason}</p>
            <button onclick="wallet.mIdentityWizard.currentStep = 3; wallet.renderWizardStep();">
                Try Again
            </button>
            <button onclick="wallet.closeIdentityWizard()">Cancel</button>
        </div>
    `;

    document.querySelector('#identity-wizard-container').innerHTML = errorHTML;
}
```


11.7.2 LOCAL MODE RESULT HANDLING
──────────────────────────────────

Local mode gets immediate results from submitPreCompiledTransactionA().

```javascript
async deployIdentityTokenLocal(publicKey, publicKeyBase58) {
    // ... token generation, validation, compilation ...

    const submitResult = await this.mVMContext.submitPreCompiledTransactionA(
        base64Bytecode,
        this.mTools.stringToByteVector(sourceCode),
        this
    );

    if (!submitResult || !submitResult.success) {
        // Immediate failure notification
        throw new Error(`Submission failed: ${submitResult?.error || 'Unknown error'}`);
    }

    // Immediate success notification (no DFS callback needed)
    this.handleIdentityTokenDeploymentSuccess(submitResult.receiptID);
}
```

KEY DIFFERENCE:
- DPT Mode: Asynchronous callback via onDFSMessage()
- Local Mode: Synchronous result from submitPreCompiledTransactionA()


11.8 ERROR HANDLING AND EDGE CASES
────────────────────────────────────────────────────────────────────────────

COMMON ERROR SCENARIOS:

1. RECEIPT ID ALREADY CONSUMED
```
Error: "Receipt ID has already been consumed by another identity token"
Cause: Trying to reuse a receipt that's already registered
Solution: Create new sacrificial transaction
Recovery: Go back to Step 1
```

2. INVALID RECEIPT ID FORMAT
```
Error: "Invalid receipt ID format"
Cause: User provided malformed base58 string
Solution: Verify receipt ID from blockchain explorer
Recovery: Re-enter correct receipt ID
```

3. TRANSACTION NOT FOUND
```
Error: "Transaction not found on blockchain"
Cause: Receipt ID doesn't correspond to any transaction
Solution: Verify transaction was actually broadcast
Recovery: Check blockchain explorer, provide different receipt
```

4. ZERO SACRIFICED VALUE
```
Error: "Invalid sacrifice: No GNC was consumed"
Cause: Transaction succeeded but didn't include sacrifice operation
Solution: Create proper sacrificial transaction
Recovery: Go back to Step 1
```

5. NICKNAME ALREADY TAKEN
```
Error: "Nickname 'JohnDoe' is already registered"
Cause: Another user already claimed this nickname
Solution: Choose different nickname
Recovery: Go back to Step 3
```

6. DOMAIN ALREADY HAS TOKEN
```
Error: "Domain already has an identity token registered"
Cause: Trying to register second token for same domain
Solution: Cannot register multiple tokens per domain
Recovery: View existing token, cannot proceed
```

7. INSUFFICIENT BALANCE (ERG)
```
Error: "Insufficient balance to pay ERG fees"
Cause: Domain doesn't have enough GNC for transaction fees
Solution: Fund domain with GNC
Recovery: Cancel wizard, fund domain, try again
```

8. PRE-VALIDATION TIMEOUT
```
Error: "Pre-validation request timed out"
Cause: Network issue or Core not responding
Solution: Check network connection
Recovery: Retry deployment
```

9. COMPILATION FAILURE (Local Mode)
```
Error: "Compilation failed: Unexpected token"
Cause: Invalid GridScript syntax (should never happen)
Solution: Bug in token serialization
Recovery: Report bug, use DPT mode as workaround
```

10. COMMITMENT TIMEOUT (DPT Mode)
```
Error: "Commitment timeout - no response from blockchain"
Cause: Network congestion or Core restart
Solution: Wait and retry
Recovery: Go back to Step 4, try again
```

ERROR RECOVERY STRATEGY:

```javascript
try {
    await this.deployIdentityToken();
} catch (error) {
    console.error('Identity token deployment error:', error);

    // Categorize error
    if (error.message.includes('already consumed')) {
        // Cannot recover - need new sacrifice
        this.showError(error.message, {
            recoveryAction: 'Create New Sacrifice',
            recoveryStep: 1
        });
    } else if (error.message.includes('already registered') ||
               error.message.includes('already taken')) {
        // Can recover - just change nickname
        this.showError(error.message, {
            recoveryAction: 'Choose Different Nickname',
            recoveryStep: 3
        });
    } else if (error.message.includes('Insufficient balance')) {
        // Cannot recover within wizard
        this.showError(error.message, {
            recoveryAction: 'Fund Domain',
            exitWizard: true
        });
    } else {
        // Generic retry
        this.showError(error.message, {
            recoveryAction: 'Try Again',
            recoveryStep: 4
        });
    }
}
```


11.9 SECURITY CONSIDERATIONS
────────────────────────────────────────────────────────────────────────────

CRYPTOGRAPHIC SECURITY:

Public Key Integrity:
  - Public key extracted from CDomainDesc (authoritative source)
  - Never allow user input for public key
  - Verified against domain ownership on Core side

Private Key Security:
  - Private keys never transmitted to browser (headless mode)
  - QR code signature requests encrypted
  - Keychain-based signing when available

Receipt ID Authenticity:
  - Always validated against blockchain state
  - Cannot forge or reuse consumed receipts
  - Core enforces one-time-use policy

ECONOMIC SECURITY:

Sybil Resistance:
  - Sacrificial transaction creates economic barrier
  - Minimum 1 GNC sacrifice enforced
  - Higher sacrifice = stronger commitment signal

Spam Prevention:
  - One identity token per domain maximum
  - Cannot delete/recreate tokens
  - Nickname permanence discourages abuse

VALIDATION SECURITY:

Pre-Validation Defense:
  - All validation happens on trusted Core
  - Browser cannot bypass security checks
  - Server-side enforcement of all rules

Double-Registration Prevention:
  - Receipt consumption tracked in blockchain state
  - Atomic check-and-set during registration
  - Race condition protection via blockchain consensus

TRANSACTION SECURITY:

Local Mode:
  - Compilation deterministic and verifiable
  - Bytecode includes checksums (SHA-256)
  - Pre-validation prevents invalid transactions

DPT Mode:
  - Thread isolation prevents interference
  - genid/regid executed atomically
  - Magic Button ensures proper commitment flow

NETWORK SECURITY:

WebSocket Security:
  - TLS encryption for all communications
  - VM Meta Data Protocol authenticated
  - DFS Protocol signed by Core

Man-in-the-Middle Protection:
  - Base58Check encoding includes checksums
  - Receipt IDs cryptographically bound to transactions
  - Public keys verified against blockchain state


11.10 INTEGRATION WITH WALLET COMPONENTS
────────────────────────────────────────────────────────────────────────────

IDENTITY TAB INTEGRATION:

Navigation:
```javascript
// Added to navigation array in wallet.js (line ~6902)
{
    id: 'identity',
    tooltip: 'Identity Token',
    icon: `<svg>...</svg>`  // User icon
}

// Tab creation in createTabs() (line ~6985)
this.mElements.tabs.identity = this.createIdentityTab();

// Tab switching in changeTab() (line ~18764)
} else if (tabId === 'identity') {
    this.loadIdentityStatus();
}
```

EXISTING TOKEN DISPLAY:

```javascript
async loadIdentityStatus() {
    const identityContainer = document.querySelector('#identity-tab-content');
    identityContainer.innerHTML = '<div class="loading">Loading...</div>';

    const domainDesc = await this.mVMContext.getDomainDetailsA(this.mCurrentDomain);

    if (domainDesc && domainDesc.identityToken) {
        // Display existing token
        this.showExistingIdentityToken(domainDesc.identityToken);
    } else {
        // Show wizard to create one
        this.showIdentityWizard();
    }
}

showExistingIdentityToken(token) {
    const html = `
        <div class="existing-identity-token">
            <h2>Your Identity Token</h2>
            <div class="token-info">
                <div class="info-row">
                    <span class="label">Nickname:</span>
                    <span class="value">${token.nickname}</span>
                </div>
                <div class="info-row">
                    <span class="label">Public Key:</span>
                    <span class="value mono">${token.publicKeyTxt}</span>
                </div>
                <div class="info-row">
                    <span class="label">Stake:</span>
                    <span class="value">${token.stakeTxt}</span>
                </div>
                <div class="info-row">
                    <span class="label">Type:</span>
                    <span class="value">${this.getTokenTypeName(token.type)}</span>
                </div>
                <div class="info-row">
                    <span class="label">Rank:</span>
                    <span class="value">${token.rank}</span>
                </div>
            </div>
            <p class="note">
                Identity tokens are permanent and cannot be modified or deleted.
            </p>
        </div>
    `;

    document.querySelector('#identity-existing-container').innerHTML = html;
    document.querySelector('#identity-existing-container').style.display = 'block';
    document.querySelector('#identity-wizard-container').style.display = 'none';
}
```

CIDENTITYTOKEN CLASS USAGE:

```javascript
import { CIdentityToken } from '/lib/IdentityToken.js';
import { eIdentityTokenType } from '/lib/enums.js';

// Construction (Local Mode)
const token = new CIdentityToken(
    eIdentityTokenType.Stake,     // type
    publicKey,                     // pubKey (Uint8Array)
    0,                             // pow
    sacrificedValue,               // consumedCoins (BigInt)
    "",                            // IOTAddress
    receiptIDBytes,                // receiptID (Uint8Array)
    new Uint8Array(),              // additionalData
    nickname                       // friendlyID
);

// Serialization
const packedData = token.getPackedData();  // Returns Uint8Array (BER encoded)

// Base58Check encoding for GridScript
const base58Token = this.mTools.base58CheckEncode(packedData);

// Deserialization (from CDomainDesc)
const existingToken = domainDesc.identityToken;  // Already instantiated
const nickname = existingToken.nickname;
const publicKeyTxt = existingToken.publicKeyTxt;
const stakeTxt = existingToken.stakeTxt;
```

CVMCONTEXT INTEGRATION:

```javascript
// Get domain details with identity token
const domainDesc = await this.mVMContext.getDomainDetailsA(this.mCurrentDomain);
const identityToken = domainDesc.identityToken;  // CIdentityToken or null

// Execute GridScript commands
const result = await this.mVMContext.processGridScriptA(
    gridScriptCode,
    this.getThreadID,
    this
);

// Submit pre-compiled transaction (Local Mode)
const submitResult = await this.mVMContext.submitPreCompiledTransactionA(
    base64Bytecode,
    sourceCodeBytes,
    this
);

// Get transaction details for verification
const txDesc = await this.mVMContext.getTransactionDetailsA(receiptID);
const sacrificedValue = txDesc.sacrificedValue;

// Add consensus task (DPT Mode)
const task = new CConsensusTask('Identity Token Registration');
this.mVMContext.addConsensusTask(task);

// Commit via Magic Button (DPT Mode)
this.mVMContext.getMagicButton.commitActions();
```

CTOOLS INTEGRATION:

```javascript
// Base58Check encoding/decoding
const base58 = this.mTools.base58CheckEncode(uint8Array);
const bytes = this.mTools.base58CheckDecode(base58String);

// GNC conversion
const atto = this.mTools.GNCToAtto(gncAmount);
const gnc = this.mTools.attoToGNC(attoAmount);
const gncStr = this.mTools.attoToGNCStr(attoAmount);

// Formatting
const formatted = this.mTools.formatGNCValue(attoAmount);

// String/Byte conversion
const bytes = this.mTools.stringToBytes(string);
const byteVector = this.mTools.stringToByteVector(string);
const string = this.mTools.arrayBufferToString(arrayBuffer);

// BigInt conversion
const bigInt = this.mTools.arrayBufferToBigInt(arrayBuffer);
const bytes = this.mTools.BigIntToBytes(bigInt);
```


11.11 TESTING AND VALIDATION CHECKLIST
────────────────────────────────────────────────────────────────────────────

PRE-DEPLOYMENT TESTING:

□ UI/UX Testing:
  □ All 4 wizard steps render correctly
  □ Step indicators update properly
  □ Transaction mode badge shows correct mode
  □ Loading states display during async operations
  □ Error messages are clear and actionable
  □ Success screen displays token details
  □ Wizard can be closed/canceled at any step
  □ Back navigation works between steps

□ Sacrifice Transaction Testing (DPT Mode):
  □ Create new sacrifice with valid amount
  □ Transaction broadcasts to Core
  □ Receipt ID captured in onDFSMessage callback
  □ Verification polling starts automatically
  □ Transaction status updates correctly
  □ Sacrificed value > 0 validated
  □ Progress advances to Step 3 on success

□ Sacrifice Transaction Testing (Local Mode):
  □ Create new sacrifice with valid amount
  □ Transaction compiles locally
  □ Transaction broadcasts to network
  □ Receipt ID returned from submission
  □ Verification polling starts automatically
  □ Transaction status updates correctly
  □ Sacrificed value > 0 validated
  □ Progress advances to Step 3 on success

□ User-Provided Receipt Testing:
  □ Valid existing receipt ID accepted
  □ Invalid receipt ID rejected with error
  □ Non-existent receipt ID rejected
  □ Already-consumed receipt ID rejected
  □ Zero-sacrifice receipt ID rejected
  □ Verification completes immediately for valid receipts

□ Nickname Testing:
  □ Nickname with < 3 characters rejected
  □ Valid nickname (≥ 3 chars) accepted
  □ Taken nickname rejected by Core
  □ Special characters handled correctly
  □ Unicode characters supported
  □ Permanence warning displayed

□ Token Deployment Testing (DPT Mode):
  □ genid command executes successfully
  □ regid command executes successfully
  □ txconfig commands execute successfully
  □ commitActions() called correctly
  □ onDFSMessage receives commitSuccess
  □ Success handler displays correct info
  □ Failure handler shows error message
  □ waitingForCommit state managed correctly

□ Token Deployment Testing (Local Mode):
  □ CIdentityToken constructed with correct fields
  □ Token serialization (getPackedData) succeeds
  □ Base58Check encoding correct
  □ Pre-validation command sequence correct
  □ Pre-validation succeeds for valid input
  □ Pre-validation fails for invalid input
  □ GridScriptCompiler compiles successfully
  □ Bytecode checksum added correctly
  □ submitPreCompiledTransactionA succeeds
  □ Success handler displays correct info
  □ Failure handler shows error message

□ Error Handling Testing:
  □ Network errors display user-friendly messages
  □ Validation errors provide recovery options
  □ Blockchain errors propagate correctly
  □ Timeout errors handled gracefully
  □ Edge cases (empty inputs, etc.) handled
  □ Error recovery actions work correctly

□ Integration Testing:
  □ Existing token displayed when present
  □ Wizard hidden when token exists
  □ Identity tab navigation works
  □ Refresh after deployment shows new token
  □ Token details displayed correctly
  □ CVMContext integration working
  □ CTools methods working correctly

□ Security Testing:
  □ Public key from authoritative source only
  □ Private key never exposed
  □ Receipt ID cannot be forged
  □ Pre-validation catches security issues
  □ Double-registration prevented
  □ Consumed receipts rejected
  □ Domain ownership validated


11.12 GRIDSCRIPT COMMAND REFERENCE
────────────────────────────────────────────────────────────────────────────

IDENTITY TOKEN COMMANDS:

genid -p <public_key> -f <friendly_name> -r <receipt_id>
────────────────────────────────────────────────────────────────────────────
Generates an identity token server-side (DPT Mode only).

Arguments:
  -p <public_key>      Base58Check encoded public key
  -f <friendly_name>   Human-readable nickname (permanent)
  -r <receipt_id>      Base58Check encoded receipt from sacrifice transaction

Pre-conditions:
  - Must be in user thread context (not system thread)
  - Receipt ID must exist and not be consumed
  - Sacrificed value must be > 0
  - Friendly name must not be taken
  - Domain must not already have identity token

Side effects:
  - Creates CIdentityToken in thread context
  - Marks receipt as consumed (pending commit)
  - Associates nickname with public key (pending commit)

Example:
  genid -p GN1abc123...xyz -f JohnDoe -r rec_def456...uvw


regid
────────────────────────────────────────────────────────────────────────────
Registers an identity token to the blockchain.

Arguments: None (uses token from stack or thread context)

Pre-conditions:
  DPT Mode: genid must have been called in same thread
  Local Mode: Serialized CIdentityToken must be on stack (via adata58)

Side effects:
  - Commits identity token to blockchain state
  - Consumes sacrificial transaction receipt
  - Registers nickname globally
  - Associates token with domain

Example (DPT Mode):
  genid -p GN1... -f JohnDoe -r rec_...
  regid

Example (Local Mode):
  adata58 <base58_serialized_token>
  regid


sacrifice <amount>
────────────────────────────────────────────────────────────────────────────
Permanently burns GNC to prove economic commitment.

Arguments:
  <amount>   Amount of GNC to sacrifice in attos (BigInt)

Pre-conditions:
  - Domain must have sufficient balance
  - Amount must be > 0
  - Must be in user thread context

Side effects:
  - Reduces domain balance by <amount>
  - GNC permanently destroyed (not transferred)
  - Transaction marked as sacrificial
  - Receipt can be used for identity token registration

Example:
  sacrifice 1000000000000000000   # Sacrifice 1 GNC


adata58 <base58_data>
────────────────────────────────────────────────────────────────────────────
Pushes base58-encoded binary data onto the stack.

Arguments:
  <base58_data>   Base58Check encoded binary data

Pre-conditions:
  - Data must be valid Base58Check format
  - Data size must not exceed maximum stack item size

Side effects:
  - Decodes base58 to binary
  - Pushes binary data onto stack

Usage with Identity Tokens:
  adata58 <base58_serialized_CIdentityToken>
  regid    # Pops token from stack and registers it

Example:
  adata58 GRIDNETIdentityToken123abc...xyz


TRANSACTION CONFIGURATION COMMANDS:

txconfig -setbid <value>
────────────────────────────────────────────────────────────────────────────
Sets the ERG price (bid) for the transaction.

Arguments:
  <value>   ERG price in attos per ERG unit (typically 1)

Example:
  txconfig -setbid 1


txconfig -setlimit <value>
────────────────────────────────────────────────────────────────────────────
Sets the maximum ERG units the transaction can consume.

Arguments:
  <value>   Maximum ERG units (typically 100000000 for identity tokens)

Example:
  txconfig -setlimit 100000000


THREAD CONTROL COMMANDS:

bt
────────────────────────────────────────────────────────────────────────────
Begins a new transaction in the current thread.

Pre-conditions:
  - Thread must not already have active transaction

Side effects:
  - Initializes transaction context
  - Prepares thread for command execution


rt
────────────────────────────────────────────────────────────────────────────
Marks the thread as ready for commitment.

Pre-conditions:
  - bt must have been called
  - All transaction commands must have succeeded

Side effects:
  - Thread enters ready state
  - Awaits commitActions() call


ct
────────────────────────────────────────────────────────────────────────────
Commits all ready threads (Magic Button).

Triggered by: this.mVMContext.getMagicButton.commitActions()

Pre-conditions:
  - At least one thread in ready state

Side effects:
  - Broadcasts all ready transactions to blockchain
  - Triggers authentication flow if needed
  - Sends DFS callbacks on success/failure


11.13 COMPLETE CODE EXAMPLE
────────────────────────────────────────────────────────────────────────────

Full end-to-end example of Identity Token deployment in Local Mode:

```javascript
// ═══════════════════════════════════════════════════════════════════════
// IDENTITY TOKEN DEPLOYMENT - LOCAL MODE COMPLETE EXAMPLE
// ═══════════════════════════════════════════════════════════════════════

import { CIdentityToken } from '/lib/IdentityToken.js';
import { eIdentityTokenType } from '/lib/enums.js';

class IdentityTokenDeployer {
    constructor(wallet) {
        this.wallet = wallet;
        this.mVMContext = wallet.mVMContext;
        this.mTools = wallet.mTools;
        this.mCurrentDomain = wallet.mCurrentDomain;
    }

    /**
     * Complete deployment flow
     */
    async deploy(nickname, sacrificeAmount) {
        try {
            // ─────────────────────────────────────────────────────────────
            // STEP 1: CREATE SACRIFICIAL TRANSACTION
            // ─────────────────────────────────────────────────────────────
            console.log('Step 1: Creating sacrificial transaction...');

            const amountAtto = this.mTools.GNCToAtto(sacrificeAmount);

            // Build sacrifice transaction
            let sacrificeCmd = `bt\n`;
            sacrificeCmd += `txconfig -setbid 1\n`;
            sacrificeCmd += `txconfig -setlimit 100000000\n`;
            sacrificeCmd += `sacrifice ${amountAtto.toString()}\n`;
            sacrificeCmd += `rt`;

            // Compile
            const compiler = new GridScriptCompiler(this.mCurrentDomain);
            const compileResult = compiler.compile(sacrificeCmd);
            const bytecode = await GridScriptCompiler.base64CheckEncode(
                compileResult.bytecode
            );

            // Submit
            const sacrificeResult = await this.mVMContext.submitPreCompiledTransactionA(
                bytecode,
                this.mTools.stringToByteVector(sacrificeCmd),
                this
            );

            if (!sacrificeResult.success) {
                throw new Error('Sacrifice transaction failed');
            }

            const sacrificeReceiptID = sacrificeResult.receiptID;
            console.log(`✓ Sacrifice transaction created: ${sacrificeReceiptID}`);


            // ─────────────────────────────────────────────────────────────
            // STEP 2: WAIT FOR CONFIRMATION
            // ─────────────────────────────────────────────────────────────
            console.log('Step 2: Waiting for transaction confirmation...');

            await this.waitForConfirmation(sacrificeReceiptID);
            console.log('✓ Transaction confirmed');


            // ─────────────────────────────────────────────────────────────
            // STEP 3: VERIFY SACRIFICE
            // ─────────────────────────────────────────────────────────────
            console.log('Step 3: Verifying sacrifice...');

            const txDesc = await this.mVMContext.getTransactionDetailsA(
                sacrificeReceiptID
            );
            const sacrificedValue = txDesc.sacrificedValue || BigInt(0);

            if (sacrificedValue <= BigInt(0)) {
                throw new Error('Invalid sacrifice: No GNC was consumed');
            }

            console.log(`✓ Verified sacrifice: ${this.mTools.attoToGNCStr(sacrificedValue)} GNC`);


            // ─────────────────────────────────────────────────────────────
            // STEP 4: GENERATE IDENTITY TOKEN LOCALLY
            // ─────────────────────────────────────────────────────────────
            console.log('Step 4: Generating identity token...');

            const domainDesc = await this.mVMContext.getDomainDetailsA(
                this.mCurrentDomain
            );
            const publicKey = domainDesc.publicKey;  // Uint8Array
            const receiptIDBytes = this.mTools.base58CheckDecode(sacrificeReceiptID);

            const identityToken = new CIdentityToken(
                eIdentityTokenType.Stake,    // type
                publicKey,                    // pubKey
                0,                            // pow
                sacrificedValue,              // consumedCoins
                "",                           // IOTAddress
                receiptIDBytes,               // receiptID
                new Uint8Array(),             // additionalData
                nickname                      // friendlyID
            );

            const packedToken = identityToken.getPackedData();
            const tokenBase58 = this.mTools.base58CheckEncode(packedToken);

            console.log('✓ Identity token generated');


            // ─────────────────────────────────────────────────────────────
            // STEP 5: PRE-VALIDATE REGISTRATION
            // ─────────────────────────────────────────────────────────────
            console.log('Step 5: Pre-validating registration...');

            let validationSequence = `bt\n`;
            validationSequence += `txconfig -setbid 1\n`;
            validationSequence += `txconfig -setlimit 100000000\n`;
            validationSequence += `adata58 ${tokenBase58}\n`;
            validationSequence += `regid\n`;
            validationSequence += `rt`;

            const validationResult = await this.mVMContext.processGridScriptA(
                validationSequence,
                this.wallet.getThreadID,
                this
            );

            if (!validationResult || validationResult.status !== 0) {
                throw new Error(
                    `Pre-validation failed: ${validationResult?.errorMessage}`
                );
            }

            console.log('✓ Pre-validation succeeded');


            // ─────────────────────────────────────────────────────────────
            // STEP 6: COMPILE REGISTRATION TRANSACTION
            // ─────────────────────────────────────────────────────────────
            console.log('Step 6: Compiling registration transaction...');

            const regCompileResult = compiler.compile(validationSequence);
            const regBytecode = await GridScriptCompiler.base64CheckEncode(
                regCompileResult.bytecode
            );

            console.log('✓ Registration compiled');


            // ─────────────────────────────────────────────────────────────
            // STEP 7: SUBMIT REGISTRATION
            // ─────────────────────────────────────────────────────────────
            console.log('Step 7: Submitting registration...');

            const regResult = await this.mVMContext.submitPreCompiledTransactionA(
                regBytecode,
                this.mTools.stringToByteVector(validationSequence),
                this
            );

            if (!regResult || !regResult.success) {
                throw new Error(`Registration failed: ${regResult?.error}`);
            }

            console.log(`✓ Registration submitted: ${regResult.receiptID}`);


            // ─────────────────────────────────────────────────────────────
            // STEP 8: WAIT FOR REGISTRATION CONFIRMATION
            // ─────────────────────────────────────────────────────────────
            console.log('Step 8: Waiting for registration confirmation...');

            await this.waitForConfirmation(regResult.receiptID);
            console.log('✓ Registration confirmed');


            // ─────────────────────────────────────────────────────────────
            // DONE!
            // ─────────────────────────────────────────────────────────────
            console.log('\n═══════════════════════════════════════════════════');
            console.log('  IDENTITY TOKEN DEPLOYED SUCCESSFULLY!');
            console.log('═══════════════════════════════════════════════════');
            console.log(`Nickname: ${nickname}`);
            console.log(`Stake: ${this.mTools.attoToGNCStr(sacrificedValue)} GNC`);
            console.log(`Sacrifice Receipt: ${sacrificeReceiptID}`);
            console.log(`Registration Receipt: ${regResult.receiptID}`);
            console.log('═══════════════════════════════════════════════════\n');

            return {
                success: true,
                nickname: nickname,
                stake: sacrificedValue,
                sacrificeReceipt: sacrificeReceiptID,
                registrationReceipt: regResult.receiptID
            };

        } catch (error) {
            console.error('Identity token deployment failed:', error);
            throw error;
        }
    }

    /**
     * Helper: Wait for transaction confirmation
     */
    async waitForConfirmation(receiptID, maxWaitSeconds = 120) {
        return new Promise((resolve, reject) => {
            let elapsed = 0;

            const interval = setInterval(async () => {
                const txDesc = await this.mVMContext.getTransactionDetailsA(receiptID);

                if (!txDesc) {
                    elapsed += 2;
                    if (elapsed >= maxWaitSeconds) {
                        clearInterval(interval);
                        reject(new Error('Transaction confirmation timeout'));
                    }
                    return;
                }

                const status = txDesc.status;

                if (status === 'Success' || status === 'Confirmed') {
                    clearInterval(interval);
                    resolve(txDesc);
                } else if (status === 'Failed') {
                    clearInterval(interval);
                    reject(new Error('Transaction failed'));
                } else {
                    elapsed += 2;
                    if (elapsed >= maxWaitSeconds) {
                        clearInterval(interval);
                        reject(new Error('Transaction confirmation timeout'));
                    }
                }
            }, 2000);  // Poll every 2 seconds
        });
    }
}

// ═══════════════════════════════════════════════════════════════════════
// USAGE EXAMPLE
// ═══════════════════════════════════════════════════════════════════════

async function example() {
    const deployer = new IdentityTokenDeployer(wallet);

    try {
        const result = await deployer.deploy(
            'JohnDoe',   // nickname
            10.5         // sacrifice amount in GNC
        );

        console.log('Deployment result:', result);
    } catch (error) {
        console.error('Deployment error:', error);
    }
}
```


================================================================================
12. WEB WORKER ARCHITECTURE FOR BER DECODING
================================================================================

12.1 OVERVIEW
────────────────────────────────────────────────────────────────────────────

As of 2025-01-26, GRIDNET OS Wallet implements Web Worker-based BER decoding
to eliminate the 22-second UI freeze that occurred during wallet unlock. This
architecture offloads CPU-intensive ASN.1/BER parsing to a background thread,
maintaining UI responsiveness while processing blockchain data.

KEY COMPONENTS:
- BERDecoderWorker.js: Web Worker that performs BER decoding
- BERDecoderProxy.js: Main thread interface for worker communication
- VMContextStub.js: Minimal CVMContext mock for worker environment


12.2 THE PROBLEM: WHY BER DECODING BLOCKS THE UI
────────────────────────────────────────────────────────────────────────────

BER (Basic Encoding Rules) is the binary serialization format used by GRIDNET
Core to encode VM Meta Data Protocol responses. Decoding is CPU-intensive:

1. DEEP RECURSION
   Each BER decode creates ~95 nested function calls to parse the hierarchical
   ASN.1 structure (SEQUENCE → fields → nested SEQUENCE → ...)

2. NO NATIVE OPTIMIZATION
   Unlike JSON.parse() (optimized in browser C++ layer), ASN.1 parsing runs in
   pure JavaScript with no acceleration

3. TRANSACTION PROCESSING
   Decoding SearchResults with 10 transactions:
   - 95 calls per transaction × 10 = 950 function calls
   - Plus nested structures, computed properties
   - Total: 1,000-2,000+ synchronous function calls
   - Result: 22-second main thread block

IMPACT: Browser becomes unresponsive, displays "script timeout" warnings,
and users cannot interact with wallet during unlock.


12.3 ARCHITECTURE: DATA FLOW THROUGH WEB WORKER
────────────────────────────────────────────────────────────────────────────

┌─────────────────────────────────────────────────────────────────────────┐
│ PHASE 1: DATA ARRIVES FROM CORE                                        │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  GRIDNET Core                                                           │
│    │                                                                    │
│    ├─► Execute GridScript (domainDetails, searchResults, etc.)         │
│    ├─► Serialize result using CMetaGenerator (C++)                     │
│    │   └─► Produces BER-encoded binary data                            │
│    └─► Send via WebSocket (VM Meta Data Protocol)                      │
│                                                                         │
│  Browser receives: ArrayBuffer with BER-encoded data                   │
└─────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────┐
│ PHASE 2: MAIN THREAD DISPATCHES TO WORKER                              │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  CVMContext.processVMMetaDataMsg(msg)                                   │
│    │                                                                    │
│    ├─► Extract BER data from WebSocket message                         │
│    │                                                                    │
│    ├─► Identify entry type (searchResults, domainDetails, etc.)        │
│    │                                                                    │
│    └─► Call: await mBERDecoder.decodeSearchResults(berData, options)   │
│                                                                         │
│  BERDecoderProxy._sendRequest()                                         │
│    │                                                                    │
│    ├─► Generate unique request ID                                      │
│    ├─► Create Promise with resolve/reject handlers                     │
│    ├─► Store in pendingRequests Map                                    │
│    └─► worker.postMessage({                                            │
│           action: 'decode',                                            │
│           id: requestId,                                               │
│           type: 'SearchResults',                                       │
│           data: arrayBuffer,  // Cloned automatically                  │
│           options: { currentHeight, currentKeyHeight }                 │
│        })                                                              │
│                                                                         │
│  ✓ Main thread continues, UI remains responsive                        │
└─────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────┐
│ PHASE 3: WORKER PERFORMS BER DECODING                                  │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  BERDecoderWorker.handleDecodeRequest(message)                          │
│    │                                                                    │
│    ├─► Extract: id, type, data, options                                │
│    │                                                                    │
│    ├─► Update VMContextStub cached heights (for tx confirmations)      │
│    │                                                                    │
│    ├─► EXPENSIVE: CSearchResults.instantiate(arrayBuffer)              │
│    │      │                                                             │
│    │      ├─► ASN1.fromBER(buffer)                                     │
│    │      │   └─► 95 nested calls to parse SEQUENCE structure          │
│    │      │                                                             │
│    │      ├─► For each transaction in results:                         │
│    │      │   └─► CTransactionDesc.fromASN1(parsed)                    │
│    │      │       └─► 95 more nested calls per transaction             │
│    │      │                                                             │
│    │      └─► Returns: CSearchResults instance (with methods)          │
│    │                                                                    │
│    ├─► SERIALIZE: serializeSearchResults(instance)                     │
│    │      │                                                             │
│    │      └─► Extract all fields to plain JavaScript object:           │
│    │          {                                                         │
│    │            _type: 'CSearchResults',                                │
│    │            results: [                                              │
│    │              {                                                     │
│    │                index: 0,                                           │
│    │                value: {                                            │
│    │                  _type: 'CTransactionDesc',                        │
│    │                  result: 0,                                        │
│    │                  value: '1000000',  // BigInt → string             │
│    │                  sender: '1ABC...',                                │
│    │                  blockID: [1,2,3],  // Uint8Array → array         │
│    │                  status: 'Confirmed',                              │
│    │                  ...                                               │
│    │                }                                                   │
│    │              }                                                     │
│    │            ],                                                      │
│    │            totalCount: 10,                                         │
│    │            currentPage: 1,                                         │
│    │            itemsPerPage: 10                                        │
│    │          }                                                         │
│    │                                                                    │
│    └─► self.postMessage({                                              │
│           id: requestId,                                               │
│           success: true,                                               │
│           data: plainObject  // Structured Clone Algorithm             │
│        })                                                              │
│                                                                         │
│  WHY SERIALIZE?                                                         │
│  Web Workers cannot transfer:                                          │
│  ❌ Class instances with methods                                        │
│  ❌ Functions                                                           │
│  ❌ Prototypes                                                          │
│  ❌ Getters/setters                                                     │
│                                                                         │
│  Only plain data structures can cross the worker boundary.             │
└─────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────┐
│ PHASE 4: MAIN THREAD RECONSTRUCTS CLASS INSTANCES                      │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  BERDecoderProxy._handleWorkerMessage(event)                            │
│    │                                                                    │
│    ├─► Extract: id, success, data                                      │
│    │                                                                    │
│    ├─► Retrieve pending request from Map using id                      │
│    │                                                                    │
│    └─► RECONSTRUCT: _reconstructInstance(data)                         │
│           │                                                             │
│           ├─► Identify type from data._type                            │
│           │                                                             │
│           └─► _reconstructSearchResults(data)                          │
│                  │                                                      │
│                  ├─► For each result:                                  │
│                  │   │                                                  │
│                  │   └─► _reconstructTransactionDesc(resultData)       │
│                  │          │                                           │
│                  │          ├─► new CTransactionDesc(                  │
│                  │          │     data.result,                         │
│                  │          │     BigInt(data.value),  // string → BigInt │
│                  │          │     data.sender,                         │
│                  │          │     data.receiver,                       │
│                  │          │     BigInt(data.ERGUsed),                │
│                  │          │     ...                                  │
│                  │          │     new Uint8Array(data.blockID)  // array → Uint8Array │
│                  │          │   )                                      │
│                  │          │                                           │
│                  │          ├─► Set properties:                        │
│                  │          │   instance.bytecodeVersion = data.bytecodeVersion │
│                  │          │                                           │
│                  │          └─► Cache computed values:                 │
│                  │              instance._cachedStatus = data.status   │
│                  │              instance._cachedFee = BigInt(data.fee) │
│                  │                                                      │
│                  └─► new CSearchResults(                               │
│                         reconstructedResults,                          │
│                         data.totalCount,                               │
│                         data.currentPage,                              │
│                         data.itemsPerPage                              │
│                      )                                                 │
│                                                                         │
│  Result: Full class instances with all methods, getters, setters       │
│                                                                         │
│  pending.resolve(reconstructed) ─► Promise resolves                    │
└─────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────┐
│ PHASE 5: VMCONTEXT DISPATCHES DATA                                     │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  CVMContext.processBlockchainStatisticsSection()                        │
│    │                                                                    │
│    ├─► Receives: CSearchResults instance (fully reconstructed)         │
│    │                                                                    │
│    ├─► processSearchResults(searchResults)                             │
│    │   └─► Internal processing, statistics updates                     │
│    │                                                                    │
│    └─► notifyNewSearchResults({                                        │
│           reqID: requestId,                                            │
│           results: searchResults,                                      │
│           processID: processID                                         │
│        })                                                              │
│                                                                         │
│  CVMContext.notifyNewSearchResults(arg)                                 │
│    │                                                                    │
│    ├─► resolvePendingRequest(reqID, arg.results, 'searchResults')     │
│    │   └─► Wallet's await completes, receives CSearchResults           │
│    │                                                                    │
│    └─► Trigger event listeners                                         │
│        └─► Wallet UI updates with transaction data                     │
└─────────────────────────────────────────────────────────────────────────┘


12.4 CRITICAL IMPLEMENTATION DETAILS
────────────────────────────────────────────────────────────────────────────

12.4.1 Avoiding Race Conditions
─────────────────────────────

PROBLEM: Originally, GridScript requests were resolved BEFORE BER decoding
completed, causing "No request found" errors.

BEFORE (BROKEN):
```javascript
// GridScript response arrives with BER metadata
processBlockchainStatisticsSection(entries, msg).catch(...);  // Fire-and-forget!

// Code continues immediately...
this.resolvePendingRequest(reqID, data, 'gridScript');  // ❌ Resolves & deletes!

// Later, when BER decoding finishes...
notifyNewDomainDetails(data);  // Tries to resolve again
  └─► resolvePendingRequest(reqID, data, 'domainDetails');  // ❌ Request gone!
```

AFTER (FIXED):
```javascript
// AWAIT the async BER decoding
await this.processBlockchainStatisticsSection(entries, msg).catch(...);

// NOW check if request still needs resolution
if (this.mPendingRequests.has(reqID)) {
    // Only resolve if not already resolved by metadata processing
    this.resolvePendingRequest(reqID, data, 'gridScript');
}
```

This required making processVMMetaDataMsg() async:
```javascript
async processVMMetaDataMsg(msg) {
    // Can now use await for worker operations
}
```


12.4.2 ArrayBuffer vs Uint8Array
─────────────────────────────────

The ASN.1 library's fromBER() internally uses:
```javascript
new Uint8Array(buffer, offset, length)
```

This signature requires ArrayBuffer as first argument, not Uint8Array:

```javascript
// Worker receives data (might be Uint8Array after postMessage)
const bufferData = data instanceof ArrayBuffer ? data :
                  data instanceof Uint8Array ? data.buffer : data;

// Now pass ArrayBuffer to instantiate
instance = CSearchResults.instantiate(bufferData);
```


12.4.3 CVMContext Dependency in Worker
───────────────────────────────────────

SearchResults.instantiate() needs CVMContext for blockchain height queries
(to calculate transaction confirmations). Solution:

1. Created VMContextStub with minimal implementation
2. Made it globally available in worker:
```javascript
import VMContextStub from '/lib/VMContextStub.js';

if (typeof CVMContext === 'undefined') {
    globalThis.CVMContext = VMContextStub;
}
```

3. Update heights before instantiation:
```javascript
if (options?.currentHeight !== undefined) {
    const ctx = VMContextStub.getInstance();
    ctx.cachedHeight = options.currentHeight;
    ctx.cachedKeyHeight = options.currentKeyHeight;
}

instance = CSearchResults.instantiate(bufferData);
```


12.4.4 Window Object Polyfill
──────────────────────────────

Many GRIDNET libraries check for window at module load:
```javascript
// ❌ Crashes in worker
Object.entries(enums).forEach(([name, enums]) => {
    window[name] = enums;
});
```

Solution: Add conditional checks in all affected files:
```javascript
if (typeof window !== 'undefined') {
    Object.entries(enums).forEach(([name, enums]) => {
        window[name] = enums;
    });
}
```

Files modified: NetMsg.js, tools.js, VMContextPartial.js, toolsStub.js,
trieNode.js, enums.js


12.4.5 API Compatibility
─────────────────────────

CRITICAL: All metadata object APIs remained UNCHANGED:
- CTransactionDesc: No constructor or method changes
- CSearchResults: No public interface changes
- CDomainDesc: No getter/setter changes
- CBlockDesc: No property changes

This was mandatory because these objects are used by multiple dApps across
GRIDNET OS ecosystem.


12.5 PERFORMANCE IMPACT
────────────────────────────────────────────────────────────────────────────

BEFORE WEB WORKERS:
- Wallet unlock: 22+ seconds UI freeze
- Browser warnings: "Page unresponsive"
- User interaction: Completely blocked
- Main thread FPS: 0

AFTER WEB WORKERS:
- Wallet unlock: <500ms perceived response
- Browser warnings: None
- User interaction: Fully responsive
- Main thread FPS: 60

The actual decoding time remains ~22 seconds, but it happens in the background
while the UI stays responsive. Users perceive instant response.


12.6 SUPPORTED DECODE OPERATIONS
────────────────────────────────────────────────────────────────────────────

The Web Worker supports these BER decode types:

1. SearchResults (CSearchResults)
   - Used for: Transaction search, domain search, block search
   - Contains: Nested CTransactionDesc, CBlockDesc, or CDomainDesc instances
   - Complexity: High (nested structures)

2. TransactionDesc (CTransactionDesc)
   - Used for: Individual transaction details
   - Contains: Transaction fields, status, confirmations, fees
   - Complexity: Medium (20+ fields, BigInt conversions)

3. DomainDesc (CDomainDesc)
   - Used for: Account/domain details, balance queries
   - Contains: Balance, transaction counts, nonce, perspectives
   - Complexity: Medium (15+ fields, BigInt conversions)

4. BlockDesc (CBlockDesc)
   - Used for: Block information
   - Contains: Height, hash, timestamp, miner, reward
   - Complexity: Low (10 fields)

5. IdentityToken (CIdentityToken)
   - Used for: Identity token data
   - Contains: Token metadata
   - Complexity: Low

NOT SUPPORTED IN WORKER:
- CKeyChain: Requires crypto operations (CX25519) and handles private keys
  (must stay on main thread for security)
- COperationStatus: Rarely a bottleneck, not worth worker overhead


12.7 FILE STRUCTURE
────────────────────────────────────────────────────────────────────────────

NEW FILES:
lib/
├── BERDecoderWorker.js         (361 lines) - Web Worker implementation
├── BERDecoderProxy.js          (357 lines) - Main thread proxy
└── VMContextStub.js            (570 lines) - Worker environment mock

MODIFIED FILES:
lib/
├── VMContext.js                - Added BERDecoderProxy integration
│                               - Made processVMMetaDataMsg async
│                               - Fixed await on metadata processing
├── NetMsg.js                   - Added window existence check
├── tools.js                    - Added window existence check
├── VMContextPartial.js         - Added window existence check
├── toolsStub.js                - Added window existence check
├── trieNode.js                 - Added window existence check
└── enums.js                    - Added window existence check

UNCHANGED FILES (API Preserved):
lib/
├── TransactionDesc.js          - No changes
├── SearchResults.js            - No changes
├── BlockDesc.js                - No changes
├── DomainDesc.js               - No changes
└── IdentityToken.js            - No changes


12.8 CODE EXAMPLES
────────────────────────────────────────────────────────────────────────────

12.8.1 Using BERDecoderProxy in CVMContext
───────────────────────────────────────────

```javascript
import { BERDecoderProxy } from './BERDecoderProxy.js';

class CVMContext {
    constructor() {
        // Initialize BER decoder proxy
        this.mBERDecoder = BERDecoderProxy.getInstance();
    }

    async processBlockchainStatisticsSection(entries, msg) {
        for (let i = 0; i < entries.length; i++) {
            const entry = entries[i];
            const entryType = entry.getType;
            const dataFields = entry.getFields;

            switch (entryType) {
                case eVMMetaEntryType.searchResults:
                    // Offload to worker
                    const searchResults = await this.mBERDecoder.decodeSearchResults(
                        dataFields[0],
                        {
                            currentHeight: this.getCachedHeight(false),
                            currentKeyHeight: this.getCachedHeight(true)
                        }
                    );

                    // Process decoded results
                    this.processSearchResults(searchResults);
                    this.notifyNewSearchResults({
                        reqID: entry.getReqID,
                        results: searchResults,
                        processID: entry.getProcessID
                    });
                    break;

                case eVMMetaEntryType.domainDetails:
                    // Offload to worker
                    const domainDesc = await this.mBERDecoder.decodeDomainDesc(
                        dataFields[0]
                    );

                    // Update UI
                    this.notifyNewDomainDetails({
                        reqID: entry.getReqID,
                        data: domainDesc,
                        processID: entry.getProcessID
                    });
                    break;
            }
        }
    }
}
```


12.8.2 Worker Serialization Example
────────────────────────────────────

```javascript
// In BERDecoderWorker.js

function serializeTransactionDesc(instance) {
    return {
        _type: 'CTransactionDesc',
        // Primitive types: pass directly
        result: instance.result,
        sender: instance.sender,
        receiver: instance.receiver,
        nonce: instance.nonce,
        height: instance.height,

        // BigInt: convert to string
        value: instance.value.toString(),
        ERGUsed: instance.ERGUsed.toString(),
        ERGPrice: instance.ERGPrice.toString(),

        // Uint8Array: convert to array
        blockID: Array.from(instance.blockID),

        // Array: pass directly (Structured Clone handles it)
        log: instance.log,

        // Getter properties (not methods!)
        bytecodeVersion: instance.bytecodeVersion,
        status: instance.status,
        confirmations: instance.confirmations,

        // Computed property that returns BigInt
        fee: instance.fee ? instance.fee.toString() : '0'
    };
}
```


12.8.3 Main Thread Reconstruction Example
──────────────────────────────────────────

```javascript
// In BERDecoderProxy.js

_reconstructTransactionDesc(data) {
    const instance = new CTransactionDesc(
        data.result,
        BigInt(data.value),              // string → BigInt
        data.sender,
        data.receiver,
        BigInt(data.ERGUsed),            // string → BigInt
        BigInt(data.ERGPrice),           // string → BigInt
        data.verifiableID,
        BigInt(data.sacrificedValue),
        data.sourceCode,
        BigInt(data.ERGLimit),
        data.nonce,
        data.confirmedTimestamp,
        data.unconfirmedTimestamp,
        data.type,
        BigInt(data.tax),
        data.log,
        data.height,
        data.keyHeight,
        data.parsingResultValid,
        new Uint8Array(data.blockID),    // array → Uint8Array
        data.sizeInBytes
    );

    // Set ES6 property (not method call!)
    if (data.bytecodeVersion !== undefined) {
        instance.bytecodeVersion = data.bytecodeVersion;
    }

    // Cache computed values to avoid recalculation
    if (data.status !== undefined) {
        instance._cachedStatus = data.status;
    }
    if (data.confirmations !== undefined) {
        instance._cachedConfirmations = data.confirmations;
    }
    if (data.fee !== undefined) {
        instance._cachedFee = BigInt(data.fee);
    }

    return instance;
}
```


12.9 ERROR HANDLING
────────────────────────────────────────────────────────────────────────────

The architecture includes comprehensive error handling at every level:

1. WORKER LEVEL
```javascript
try {
    instance = CSearchResults.instantiate(bufferData);
    const serialized = serializeInstance(instance, type);
    self.postMessage({ id, success: true, data: serialized });
} catch (error) {
    self.postMessage({
        id,
        success: false,
        error: {
            message: error.message,
            stack: error.stack
        }
    });
}
```

2. PROXY LEVEL
```javascript
if (success) {
    try {
        const reconstructed = this._reconstructInstance(data);
        pending.resolve(reconstructed);
    } catch (e) {
        console.error('[BERDecoderProxy] Reconstruction error:', e);
        pending.reject(e);
    }
} else {
    pending.reject(new Error(error.message));
}
```

3. VMCONTEXT LEVEL
```javascript
await this.processBlockchainStatisticsSection(entries, msg).catch(err => {
    console.error('[VMContext] Error processing statistics:', err);
    this.mTools.logEvent(
        `Error processing blockchain statistics: ${err.message}`,
        eLogEntryCategory.localSystem,
        1,
        eLogEntryType.error
    );
});
```


12.10 FUTURE ENHANCEMENTS
────────────────────────────────────────────────────────────────────────────

12.10.1 Transferable Objects
─────────────────────────────

Currently, ArrayBuffers are cloned. Future optimization:

```javascript
// Transfer ownership (zero-copy)
this.worker.postMessage(
    { data: arrayBuffer },
    [arrayBuffer]  // Transferable list
);
```

TRADE-OFF: Main thread loses access to buffer after transfer.


12.10.2 Worker Pool
────────────────────

For concurrent decode operations:

```javascript
class BERDecoderPool {
    constructor(workerCount = navigator.hardwareConcurrency || 4) {
        this.workers = Array.from(
            { length: workerCount },
            () => new Worker('/lib/BERDecoderWorker.js', { type: 'module' })
        );
        this.nextWorkerIndex = 0;
    }

    getNextWorker() {
        const worker = this.workers[this.nextWorkerIndex];
        this.nextWorkerIndex = (this.nextWorkerIndex + 1) % this.workers.length;
        return worker;
    }
}
```


12.10.3 Progressive Decoding
─────────────────────────────

For very large datasets, stream results:

```javascript
// Worker sends partial results
for (let i = 0; i < transactionCount; i++) {
    const tx = decodeTransaction(data, offset);
    self.postMessage({
        id,
        type: 'partial',
        index: i,
        data: serializeTransaction(tx)
    });
}

// UI updates incrementally as transactions arrive
```


12.11 DEBUGGING AND MONITORING
────────────────────────────────────────────────────────────────────────────

Enable detailed logging:

```javascript
// In BERDecoderWorker.js
console.log(`[BERDecoderWorker] Received ${type} request #${id}`);
console.log(`[BERDecoderWorker] Data type: ${data.constructor.name}`);
console.log(`[BERDecoderWorker] Byte length: ${data.byteLength}`);

// In BERDecoderProxy.js
console.log(`[BERDecoderProxy] Sending ${type} request #${id}`);
console.log(`[BERDecoderProxy] Received response - success: ${success}`);
console.log(`[BERDecoderProxy] Reconstructed ${data._type}`);

// In VMContext.js
console.log('[VMContext] Decoding SearchResults, dataFields[0] type:',
            dataFields[0]?.constructor?.name);
console.log('[VMContext] Received SearchResults from worker:',
            searchResults?.constructor?.name);
```

Monitor performance:

```javascript
const startTime = performance.now();
const results = await this.mBERDecoder.decodeSearchResults(data);
const endTime = performance.now();
console.log(`BER decode took ${endTime - startTime}ms`);
```


12.12 TESTING
────────────────────────────────────────────────────────────────────────────

12.12.1 Unit Testing Worker
────────────────────────────

```javascript
// Test serialization/reconstruction
const original = new CTransactionDesc(...);
const serialized = serializeTransactionDesc(original);
const reconstructed = reconstructTransactionDesc(serialized);

assert.equal(original.result, reconstructed.result);
assert.equal(original.value, reconstructed.value);
assert.deepEqual(Array.from(original.blockID), Array.from(reconstructed.blockID));
```

12.12.2 Integration Testing
────────────────────────────

```javascript
// Test full decode pipeline
const berData = /* ... ArrayBuffer with BER data ... */;
const proxy = BERDecoderProxy.getInstance();

const decoded = await proxy.decodeSearchResults(berData, {
    currentHeight: 100000,
    currentKeyHeight: 10000
});

assert(decoded instanceof CSearchResults);
assert.equal(decoded.getResultCount(), 10);
assert(decoded.getResult(0).getValue() instanceof CTransactionDesc);
```


12.13 MAINTENANCE NOTES
────────────────────────────────────────────────────────────────────────────

WHEN ADDING NEW METADATA TYPES:

1. Add type constant in BERDecoderWorker.js:
```javascript
const BER_DECODE_TYPES = {
    NEW_TYPE: 'NewType',
    // ...
};
```

2. Add serialization function:
```javascript
function serializeNewType(instance) {
    return {
        _type: 'CNewType',
        // ... all fields
    };
}
```

3. Add reconstruction in BERDecoderProxy.js:
```javascript
_reconstructNewType(data) {
    return new CNewType(
        // ... constructor params
    );
}
```

4. Add decode method in BERDecoderProxy.js:
```javascript
async decodeNewType(data, options = {}) {
    return this._sendRequest('NewType', data, options);
}
```

5. Use in VMContext.js:
```javascript
const instance = await this.mBERDecoder.decodeNewType(dataFields[0]);
```

IMPORTANT: Maintain API compatibility of metadata objects!


================================================================================
END OF DOCUMENTATION
================================================================================

For additional support:
  - GRIDNET OS Documentation: https://mag.gridnet.org
  - GitHub Issues: https://github.com/GRIDNETOS/GRIDNETOS/issues
  - Community Forum: https://talk.gridnet.org

Last Updated: 2025-01-26
Document Version: 2.3



13. GRIDNET OS CURTAIN WHITELIST SYSTEM
================================================================================

13.1 OVERVIEW
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

The GRIDNET OS Curtain is a loading animation that appears when significant DOM
changes are detected in a dApp window. While useful for indicating complex
operations, it can interfere with interactive UI elements like sliders and
spinners that cause frequent DOM mutations during normal user interaction.

The Curtain Whitelist System provides an API for dApps to filter out mutations
from specific elements, preventing unnecessary curtain animations.


13.2 HOW THE CURTAIN WORKS
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

CWindow uses a MutationObserver to monitor DOM changes:

1. MutationObserver watches all DOM changes in the window (childList, subtree)
2. Each mutation increments a counter (bucket counter)
3. When counter exceeds threshold (default: 10), curtain is displayed
4. Counter resets after a time window (default: 2000ms)

WITHOUT WHITELISTING:
- Dragging a slider â†’ Updates display values â†’ 10+ mutations â†’ Curtain shows
- Using spinner buttons â†’ Updates input â†’ Multiple mutations â†’ Curtain shows
- Live balance updates â†’ Updates multiple elements â†’ Curtain shows


13.3 WHITELIST API
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

13.3.1 addCurtainWhitelist(pattern)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Register elements whose mutations should NOT trigger the curtain.

PARAMETERS:
- pattern.classNames: Array of CSS class names to whitelist
- pattern.ids: Array of element IDs to whitelist (supports partial matching)
- pattern.tags: Array of HTML tag names to whitelist
- pattern.maxDepth: Max parent levels to check (default: 5)

EXAMPLE - Wallet Constructor:
```javascript
constructor(positionX, positionY, width, height, data, dataType, filePath, thread) {
    super(positionX, positionY, width, height, ...);

    // Whitelist interactive elements
    this.addCurtainWhitelist({
        classNames: [
            'amount-slider-handle',
            'number-spinner-btn',
            'balance-highlight'
        ],
        ids: [
            'calc-total-value',
            'available-balance-value'
        ],
        maxDepth: 5
    });
}
```

13.3.2 clearCurtainWhitelist()
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Remove all whitelist patterns. Useful for debugging or reconfiguration.

```javascript
this.clearCurtainWhitelist();
```


13.4 RECURSIVE WHITELISTING
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

The whitelist system is RECURSIVE - it checks up to maxDepth parent levels.
This means whitelisting a container automatically covers all its children.

EXAMPLE:
```html
<div id="balance-display">          <!-- Whitelisted by ID -->
  <span class="amount">             <!-- Automatically whitelisted -->
    <strong>100.00</strong>          <!-- Automatically whitelisted -->
  </span>
</div>
```

Whitelisting the DIV automatically filters mutations on the SPAN and STRONG.


13.5 PATTERN MATCHING RULES
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

CLASS NAMES:
- Uses element.classList.contains(className)
- Exact match required
- Example: 'balance-highlight' matches <div class="balance-highlight">

IDS:
- Uses element.id === id OR element.id.includes(id)
- Supports partial matching
- Example: 'balance' matches <div id="available-balance-value">

TAGS:
- Uses element.tagName === tag.toUpperCase()
- Case-insensitive
- Example: 'div' matches <DIV>


13.6 DEBUGGING
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Enhanced logging shows what triggers the curtain:

FILTERED MUTATIONS (Whitelisted):
```
[Observer(PID:1001)]: Filtered WHITELISTED mutation on: amount-slider-handle type: childList
```

MUTATIONS THAT PASS THROUGH:
```
[Observer(PID:1001)]: Child mutation detected on: DIV#some-element.some-class
```

CURTAIN TRIGGER:
```
Showing curtain - REASON: Threshold reached (12/10). Triggering mutations:
  [childList on DIV#container, +2/-0 nodes],
  [childList on SPAN.text, +1/-1 nodes]
```


13.7 WHEN TO WHITELIST
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

ALWAYS WHITELIST:
âœ“ Slider handles and tracks
âœ“ Spinner buttons (up/down arrows)
âœ“ Live-updating displays (balance counters, calculated values)
âœ“ Real-time data feeds
âœ“ Animation containers

NEVER WHITELIST:
âœ— Page structure changes (navigation, modals)
âœ— Data loading operations (transaction lists, search results)
âœ— Complex UI rebuilds (tab switching, view changes)

The goal is to filter out high-frequency interactive mutations while preserving
the curtain for meaningful operations.


13.8 IMPLEMENTATION DETAILS
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

FLOW:
1. Mutation occurs
2. observerCallback() called by MutationObserver
3. For each mutation:
   a. Check if isWhitelistedMutation()
   b. If whitelisted â†’ skip (don't increment counter)
   c. If not whitelisted â†’ increment counter
4. If counter >= threshold â†’ showCurtain()

KEY METHODS (lib/window.js):
- addCurtainWhitelist() - Register patterns
- clearCurtainWhitelist() - Clear all patterns
- isWhitelistedMutation() - Check if mutation matches pattern
- isWhitelistedElement() - Recursive element matching
- observerCallback() - Main mutation handler
- showCurtain() - Display curtain with reason


13.9 PERFORMANCE CONSIDERATIONS
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

OPTIMIZATION:
- First match wins (short-circuits)
- Parent traversal limited to maxDepth (default: 5)
- Element checks use native DOM APIs (classList.contains, etc.)

OVERHEAD:
- Minimal: ~0.1ms per mutation check
- Whitelist check only runs if patterns registered
- No impact if no patterns registered


13.10 EXAMPLE - COMPLETE IMPLEMENTATION
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

```javascript
class CMyDApp extends CWindow {
    constructor(positionX, positionY, width, height, ...) {
        super(positionX, positionY, width, height, ...);

        // Register whitelist immediately after super()
        this.addCurtainWhitelist({
            classNames: [
                // Interactive controls
                'slider-handle',
                'spinner-button',
                'number-input-wrapper',

                // Live displays
                'live-counter',
                'auto-update',
                'real-time-data'
            ],
            ids: [
                // Specific elements
                'main-balance-display',
                'calculated-total',
                'progress-indicator'
            ],
            maxDepth: 5
        });

        this.initializeUI();
    }
}
```


13.11 WALLET IMPLEMENTATION
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

The Wallet dApp whitelists:

INTERACTIVE ELEMENTS:
- amount-slider-handle, amount-slider-track, amount-slider-fill
- number-spinner-btn, number-spinner-buttons, number-input-wrapper

LIVE DISPLAYS:
- balance-detail-value, balance-highlight, balance-value-main
- slider-max-label

CALCULATED VALUES:
- calc-tokens-per-bank, calc-total-value
- send-total-value, send-remaining-balance

DASHBOARD:
- available-balance-value, locked-balance-value, total-balance-value
- dashboard-active-pools-count, dashboard-pools-balance

See: dApps/Wallet/wallet.js constructor (lines 2637-2723)


13.12 TROUBLESHOOTING
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

PROBLEM: Curtain still shows during slider drag
SOLUTION: Check console for unwhitelisted mutations, add those elements to whitelist

PROBLEM: Whitelist not working
SOLUTION: Ensure addCurtainWhitelist() called AFTER super() and BEFORE UI initialization

PROBLEM: Too many elements whitelisted
SOLUTION: Curtain won't show for legitimate operations. Be selective - only whitelist
         high-frequency interactive elements, not structural changes.

PROBLEM: Need to debug what's triggering curtain
SOLUTION: Check console logs for:
         - "Filtered WHITELISTED mutation" (working correctly)
         - "Child mutation detected on" (passing through)
         - "Showing curtain - REASON" (threshold reached with details)


================================================================================
