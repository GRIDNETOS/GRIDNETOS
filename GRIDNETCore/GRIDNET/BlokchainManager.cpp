#include "BlockchainManager.h"
#include "BlockchainManager.h"
#include "BlockchainManager.h"
#include "BlockVerificationResult.h"
#include <algorithm>
#include <cmath>

#include "WorkManager.h"
#include "Receipt.h"
#include "keyChain.h"
#include "conio.h"
#include "mainTests.h"
#include <limits> 
#include "GridScriptParser.h"
#include "ScriptEngine.h"
#include "TransactionDesc.hpp"
#include "BlockDesc.hpp"
#include "enums.h"
#include <algorithm> 
#include <algorithm> 
#include "FinalAction.h"
#include "Verifiable.h"
#include "NetworkManager.h"
#include "Block.h"
#include "SolidStorage.h"
#include "CStateDomainManager.h"
#include "WorkManager.h"
#include "TrieDB.h"
#include "Settings.h"
#include "SearchFilter.hpp"
#include "FlashingProgressManager.hpp"
#include "keyChain.h"
#include "oclengine.h"
#include "transactionmanager.h"
#include "SearchResults.hpp"
#include "CryptoFactory.h"
#include "transaction.h"
#include "CGlobalSecSettings.h"
#include "BlockHeader.h"
#include "GRIDNET.h"
#include "OperatorSecurityInfo.hpp"
#include "DataConcatenator.h"
#include "BlokchainManager.h"
#include "GridScriptCompiler.h"
#include "StatusBarHub.h"
#include "conversation.h"
#include "DTIServer.h"
#include "WWWServer.h"
#include "CBCheckpoint.h"
#include "UDTConversationsServer.h"
#include "BreakpointFactory.hpp"
#include "SynchronizedLocker.hpp"
#include "ThreadPool.h"
#include "CMDExecutor.h"
#define LOG_CP_CHUNKS 0
#define USE_MT_CHAINPROOF_VALIDATION 1
#define DO_MT_TRIEDB_TESTS 0
#define DO_MT_CHAINPROOF_VALIDATION_TESTS 0
#define MAX_VITALS_REFRESH_RATE 5//seconds
#define CONNECTIVITY_WARNING_THRESHOLD 3//below that # of DSM connections warning is shown
#define EASY_RAM_GB_REQUIRED 2
#define ENABLE_INTER_BATCH_CACHE_VERIFICATION_TEST 1
#define ENABLE_INNER_BATCHCACHE_VERIFICATION_TEST 1
#define ENABLE_CACHE_VERIFICATION_LOOP_DETECTION_TEST 1
#define CACHE_REPORT_EVERY_BLOCKS 25
#define MIN_TIME_INTERVAL_FOR_EMA_UPDATE 3
const uint64_t BYTES_PER_MEGABYTE = 1024 * 1024;
const uint64_t BYTES_PER_KILOBYTE = 1024;
#define max(a,b)            (((a) > (b)) ? (a) : (b))
std::recursive_mutex  CBlockchainManager::sStaticPointersGuardian;
std::mutex   CBlockchainManager::sFactoryProductionLockGuardian;
bool  CBlockchainManager::sTestNetInstanceInited = false;
bool  CBlockchainManager::sLiveInstanceInited = false;
bool  CBlockchainManager::sLIVESandBoxInstanceInited = false;
bool  CBlockchainManager::sTestSandBoxInstanceInited = false;
bool  CBlockchainManager::sLocalTestsInstanceInited = false;
bool CBlockchainManager::sMissionAbort = false;
std::mutex CBlockchainManager::sFieldsGuardian;
std::shared_ptr<CBlockchainManager> CBlockchainManager::sTestNetInstance = nullptr;
std::shared_ptr<CBlockchainManager> CBlockchainManager::sLiveInstance = nullptr;
std::shared_ptr<CBlockchainManager> CBlockchainManager::sTestSandBoxInstance = nullptr;
std::shared_ptr<CBlockchainManager> CBlockchainManager::sLIVESandBoxInstance = nullptr;
std::shared_ptr<CBlockchainManager> CBlockchainManager::sLocalTestsInstance = nullptr;

size_t CBlockchainManager::getLastTimeValidBlockProcessed()
{
	std::lock_guard<std::mutex> lock(mStatisticsDataGuardian);
	return mLastTimeValidBlockProcessed;
}

void  CBlockchainManager::pingLastTimeValidBlockProcessed()
{
	std::lock_guard<std::mutex> lock(mStatisticsDataGuardian);
	mLastTimeValidBlockProcessed = std::time(0);
}

std::string CBlockchainManager::getDefaultRealmName()
{
	std::lock_guard<std::mutex> lock1(mModeGuardian);

	switch (mMode)
	{
	case eBlockchainMode::LIVE:
		return "live";
		break;
	case eBlockchainMode::TestNet:
		return "test";
		break;
	case eBlockchainMode::LIVESandBox:
		return "live";
		break;
	case eBlockchainMode::TestNetSandBox:
		return "test";
		break;
	case eBlockchainMode::LocalData:
		return "local";
		break;
	case eBlockchainMode::Unknown:
		return "unknown";
		break;
	default:
		break;
	}
	return "unknown";
}

uint64_t CBlockchainManager::getAverageSMAKeyBlockInterval()
{
	std::lock_guard<std::mutex> lock(mStatisticsDataGuardian);
	return mAverageKeyBlockInteval;
}

uint64_t CBlockchainManager::getJustSavedKeyBlocksCount()
{
	std::lock_guard<std::mutex> lock(mStatisticsDataGuardian);
	return mJustSavedKeyBlocksCount;
}

uint64_t CBlockchainManager::getJustSavedDataBlocksCount()
{
	std::lock_guard<std::mutex> lock(mStatisticsDataGuardian);
	return mJustSavedDataBlocksCount;
}

void CBlockchainManager::incJustSavedKeyBlocksCount()
{
	std::lock_guard<std::mutex> lock(mStatisticsDataGuardian);
	mJustSavedKeyBlocksCount++;
}

void CBlockchainManager::incJustSavedDataBlocksCount()
{
	std::lock_guard<std::mutex> lock(mStatisticsDataGuardian);
	mJustSavedDataBlocksCount++;
}

uint64_t CBlockchainManager::getDiscardedKeyBlocksCount()
{
	std::lock_guard<std::mutex> lock(mStatisticsDataGuardian);
	return mDiscardedKeyBlocksCount;
}

uint64_t CBlockchainManager::getDiscardedDataBlocksCount()
{
	std::lock_guard<std::mutex> lock(mStatisticsDataGuardian);
	return mDiscardedDataBlocksCount;
}

void CBlockchainManager::incDiscardedKeyBlocksCount()
{
	std::lock_guard<std::mutex> lock(mStatisticsDataGuardian);
	mDiscardedKeyBlocksCount++;
}

void CBlockchainManager::incDiscardedDataBlocksCount()
{
	std::lock_guard<std::mutex> lock(mStatisticsDataGuardian);
	mDiscardedDataBlocksCount++;
}

uint64_t CBlockchainManager::getAssumedAsLeaderKeyBlocksCount()
{
	std::lock_guard<std::mutex> lock(mStatisticsDataGuardian);
	return mAssumedAsLeaderKeyBlocksCount;
}

uint64_t CBlockchainManager::getAssumedAsLeaderDataBlocksCount()
{
	std::lock_guard<std::mutex> lock(mStatisticsDataGuardian);
	return mAssumedAsLeaderDataBlocksCount;
}

void CBlockchainManager::incAssumedAsLeaderKeyBlocksCount()
{
	std::lock_guard<std::mutex> lock(mStatisticsDataGuardian);
	mAssumedAsLeaderKeyBlocksCount++;
}

void CBlockchainManager::incAssumedAsLeaderDataBlocksCount()
{
	std::lock_guard<std::mutex> lock(mStatisticsDataGuardian);
	mAssumedAsLeaderDataBlocksCount++;
}

// Warning: this *SMA* value MUST NOT be used for difficulty adjustment purposes use *EMA* instead.
//For informative purposes ONLY.
void CBlockchainManager::setAverageSMAKeyBlockInterval(uint64_t interval)
{
	std::lock_guard<std::mutex> lock(mStatisticsDataGuardian);
	mAverageKeyBlockInteval = interval;
}

// Warning: this *SMA* value MUST NOT be used for difficulty adjustment purposes use *EMA* instead.
//For informative purposes ONLY.
uint64_t CBlockchainManager::getAverageSMADataBlockInterval()
{
	std::lock_guard<std::mutex> lock(mStatisticsDataGuardian);
	return mAverageDataBlockInteval;
}

void CBlockchainManager::setAverageDataBlockInterval(uint64_t interval)
{
	std::lock_guard<std::mutex> lock(mStatisticsDataGuardian);
	mAverageDataBlockInteval = interval;
}

void CBlockchainManager::setVitalsGood(bool areThey)
{
	std::lock_guard<std::mutex> lock(mFieldsGuardian);
	mAllVitalsLookingGood = areThey;
}

bool CBlockchainManager::getAreVitalsGood()
{
	std::lock_guard<std::mutex> lock(mFieldsGuardian);
	return mAllVitalsLookingGood;
}


std::string CBlockchainManager::getVitalsDescription(bool colorize)
{

	size_t now = std::time(0);

	mFieldsGuardian.lock();//optimization
	if ((now - mLastVitalsRefresh) < MAX_VITALS_REFRESH_RATE)
	{
		mFieldsGuardian.unlock();
		return mVitalsStrCache;
	}
	mLastVitalsRefresh = now;

	bool statusReady = false;
	mFieldsGuardian.unlock();
	std::string toRet = "Unknown";
	std::shared_ptr<CTools> tools = getTools();
	std::shared_ptr<CNetworkManager> nm = getNetworkManager();

	bool gridAnalysis = false;
	bool vitalsGood = getAreVitalsGood(); //check overall major vitals

	if (vitalsGood)
	{
		toRet = tools->getColoredString("Good", colorize ? eColor::lightGreen : eColor::none) + " (unconfirmed)";
	}

	if (nm && nm->getIsNetworkTestMode())

	{
		gridAnalysis = true;
		toRet = tools->getColoredString("Grid Analysis Mode", colorize ? eColor::orange : eColor::none);
	}
	else {
		if (CSettings::getIsGlobalAutoConfigInProgress())
		{//initial boostrapping overrides everything else
			toRet = tools->getColoredString("Booting Up (Phase 2)", colorize ? eColor::orange : eColor::none);
			statusReady = true;
		}
		if (!statusReady)
		{
			if (!vitalsGood)
			{
				toRet = tools->getColoredString("Warnings", colorize ? eColor::lightPink : eColor::none);
			}
			else
			{
				//Connectivity Checks - BEGIN

				if (nm != nullptr)
				{//check connectivity
					conversationFlags flags;
					flags.exchangeBlocks = true;
					std::vector<std::shared_ptr<CConversation>> convs = nm->getConversations(flags);

					if (convs.size() == 0)//check # of DMS sync connections
					{
						toRet = tools->getColoredString("No Connectivity", colorize ? eColor::cyborgBlood : eColor::none);
					}
					else if (convs.size() < CONNECTIVITY_WARNING_THRESHOLD)//check # of DMS sync connections
					{
						toRet = tools->getColoredString("Low Connectivity", colorize ? eColor::orange : eColor::none);
					}
					else
					{
						toRet = tools->getColoredString("Good", colorize ? eColor::lightGreen : eColor::none);
					}
				}

				//Connectivity Checks - END



			}
		}
	}
	mFieldsGuardian.lock();

	mVitalsStrCache = toRet;
	mFieldsGuardian.unlock();
	return toRet;
}

bool CBlockchainManager::getDisableDataAnalysis()
{
	std::lock_guard<std::mutex> lock(mFieldsGuardian);
	return mSkipLocalDataAnalysis;
}
void CBlockchainManager::setEnableDataAnalysis(bool doIt = true)
{
	mSkipLocalDataAnalysis = doIt;
}

bool CBlockchainManager::getInNetworkTestingMode()
{
	std::lock_guard<std::mutex> lock(mFieldsGuardian);
	return mNetworkTestingMode;
}
void CBlockchainManager::setInNetworkTestingMode(bool doIt = true)
{
	std::lock_guard<std::mutex> lock(mFieldsGuardian);
	mNetworkTestingMode = doIt;
}

uint64_t CBlockchainManager::getFarAwayCPRequestedTimestamp()
{
	std::lock_guard<std::mutex> lock(mFieldsGuardian);
	return mFarAwayCPRequestedTimestamp;

}

/// <summary>
/// When we want to force chain proof external chain proofs' processing.
/// For instance after current long path was conclused as invalid.
/// </summary>
void CBlockchainManager::clearFarAwayCPRequestedTimestamp()
{
	std::lock_guard<std::mutex> lock(mFieldsGuardian);
	 mFarAwayCPRequestedTimestamp=0;

}


void CBlockchainManager::pingFarAwayCPRequestedTimestamp()
{
	std::lock_guard<std::mutex> lock(mFieldsGuardian);
	mFarAwayCPRequestedTimestamp = std::time(0);
}

bool CBlockchainManager::getIsVitalsMonitorRunning()
{
	std::lock_guard<std::mutex> lock(mFieldsGuardian);
	return mVitalsMonitorRunning;
}

void CBlockchainManager::setIsVitalsMonitorRunning(bool isIt)
{
	std::lock_guard<std::mutex> lock(mFieldsGuardian);

	if (isIt == mVitalsMonitorRunning)
		return;

	if (isIt)
	{
		getTools()->writeLine(getTools()->getColoredString("Vitals Monitor is now ACTIVE", eColor::orange));
	}
	else
	{
		getTools()->writeLine(getTools()->getColoredString("Vitals Monitor is now INACTIVE.", eColor::cyborgBlood));
	}


	mVitalsMonitorRunning = isIt;
}


void CBlockchainManager::setIsVitalsMonitorToBeRunning(bool isIt)
{
	std::lock_guard<std::mutex> lock(mFieldsGuardian);

	if (isIt == mVitalsMinitorIsToBeRunning)
		return;

	if (isIt)
	{
		getTools()->writeLine(getTools()->getColoredString("Enabling Vitals Monitor", eColor::orange));
	}
	else
	{
		getTools()->writeLine(getTools()->getColoredString("Telling Vitals Monitor to shut down.", eColor::cyborgBlood));
	}

	mVitalsMinitorIsToBeRunning = isIt;
}

bool  CBlockchainManager::getIsVitalsMonitorToBeRunning()
{
	std::lock_guard<std::mutex> lock(mFieldsGuardian);
	return mVitalsMinitorIsToBeRunning;
}

uint64_t CBlockchainManager::getLastControllerLoopRun()
{
	std::lock_guard<std::mutex> lock(mFieldsGuardian);
	return mLastControllerLoopRun;
}

void CBlockchainManager::pingtLastControllerLoopRun()
{
	std::lock_guard<std::mutex> lock(mFieldsGuardian);
	mLastControllerLoopRun = std::time(0);
}

uint64_t CBlockchainManager::getVerifiedSyncedWithCSAtHeight()
{
	std::lock_guard<std::mutex> lock(mFieldsGuardian);
	return mVerfiedSyncedWithCSAtHeight;
}
void CBlockchainManager::setVerfiedSyncedWithCSAtHeight(uint64_t height)
{
	std::lock_guard<std::mutex> lock(mFieldsGuardian);
	mVerfiedSyncedWithCSAtHeight = height;
}


uint64_t CBlockchainManager::getCacheBarID()
{
	std::lock_guard<std::mutex> lock(mFieldsGuardian);
	return mCachedFilledInStatusBarID;
}

bool CBlockchainManager::getIsOperatorLeadingAHardFork()
{
	std::lock_guard<std::mutex> lock(mFieldsGuardian);
	return mOperatorLeadingAHardFork;
}

void CBlockchainManager::setIsOperatorLeadingAHardFork(bool isHe)
{
	std::shared_ptr<CTools> tools = getTools();
	std::lock_guard<std::mutex> lock(mFieldsGuardian);
	mOperatorLeadingAHardFork = isHe;

	if (mOperatorLeadingAHardFork != isHe)
	{

		tools->writeLine(tools->getColoredString("Hard-Fork Lead Mode has been", eColor::orange) +
			tools->getColoredString(isHe ? "ENABLED" : "DISABLED", eColor::lightGreen), true, true, eViewState::GridScriptConsole, "Hard Fork", false);

	}
}

void CBlockchainManager::setIsForkingAlternativeHistory(bool isIt)
{
	std::lock_guard<std::mutex> lock(mFieldsGuardian);
	mLeadingAlternativeHistory = isIt;

}
bool CBlockchainManager::getIsForkingAlternativeHistory()
{
	std::lock_guard<std::mutex> lock(mFieldsGuardian);
	return mLeadingAlternativeHistory;

}


/**
 * @brief Retrieves the block ID at a specified depth in the verified chain.
 *
 * This method accesses the mVerifiedChainProofDouble to get the block ID.
 * Depth is measured from the top of the chain, where 0 is the latest block.
 *
 * @param depth The depth of the block whose ID is to be retrieved.
 * @return std::vector<uint8_t> The block ID at the specified depth, or an empty vector if out of bounds.
 *
 * Thread safety: This method is thread-safe, using a recursive mutex for synchronization.
 *
 * Note: This method assumes that mVerifiedChainProofDouble is ordered from oldest to newest,
 * hence the need to reverse the index when accessing.
 * Notice: See getBlockIDAtKeyHeight().
 */
std::vector<uint8_t> CBlockchainManager::getBlockIDAtDepth(uint64_t depth)
{
	// Thread Safety - BEGIN
	std::lock_guard<ExclusiveWorkerMutex> lock(mVerifiedPathDoubleGuardian);
	// Thread Safety - END

	// Validation - BEGIN
	if (depth >= mVerifiedChainProofDouble.size())
	{
		return std::vector<uint8_t>();  // Return an empty vector if depth is out of bounds
	}
	// Validation - END

	// Retrieval - BEGIN
	// Calculate the index, considering the reverse ordering of mVerifiedChainProofDouble
	size_t index = mVerifiedChainProofDouble.size() - 1 - depth;
	return mVerifiedChainProofDouble[index];
	// Retrieval - END
}

bool CBlockchainManager::getIsRestartNeeded()
{
	std::lock_guard<std::mutex> lock(mFieldsGuardian);

	return mRestartNeeded;
}

void CBlockchainManager::setIsRestartNeeded(bool isIt)
{
	std::lock_guard<std::mutex> lock(mFieldsGuardian);

	mRestartNeeded = isIt;
}

uint64_t CBlockchainManager::getLastTimeBlockCacheCleaned()
{
	std::lock_guard<std::mutex> lock(mFieldsGuardian);
	return mLastTimeBlockCacheCleared;
}

void CBlockchainManager::pingLastTimeBlockCacheCleaned()
{
	std::lock_guard<std::mutex> lock(mFieldsGuardian);
	mLastTimeBlockCacheCleared = std::time(0);
}

// Block Unordered Cache Methods - BEGIN

/**
 * @brief Adds a block to the LRU cache. If the block already exists, it is
 *        marked as most recently used. If inserting a new block causes the
 *        cache size to exceed the configured maximum, the least recently
 *        used (LRU) block is evicted.
 *
 * @param block Shared pointer to the block to be cached.
 */
void CBlockchainManager::addBlockToUnorderedCache(const std::shared_ptr<CBlock>& block)
{
	if (!block) {
		// If the incoming block pointer is invalid, do nothing.
		return;
	}

	// Obtain the block ID. Some code paths may generate IDs of different lengths;
	// we enforce a consistent 32-byte ID if possible. Otherwise, just re-fetch it.
	const std::vector<uint8_t> rawID = block->getID();
	std::vector<uint8_t> blockID = (rawID.size() == 32) ? rawID : block->getID();

	// Exclusive lock because we are modifying the cache.
	std::unique_lock<std::shared_mutex> lock(mBlockUnorderedCacheMutex);

	auto it = mBlockUnorderedCacheMap.find(blockID);
	if (it != mBlockUnorderedCacheMap.end()) {
		// Block is already in cache; move it to the end (most recently used).
		mBlockUnorderedCacheOrder.erase(it->second.second);
		mBlockUnorderedCacheOrder.push_back(blockID);
		it->second.second = std::prev(mBlockUnorderedCacheOrder.end());
		return;
	}

	// The block is not yet in the cache; add it.
	mBlockUnorderedCacheOrder.push_back(blockID);
	auto listIt = std::prev(mBlockUnorderedCacheOrder.end());
	mBlockUnorderedCacheMap.emplace(blockID, std::make_pair(block, listIt));

	// If we've exceeded the max size, evict the LRU entry (front of list).
	if (mBlockUnorderedCacheMap.size() > mBlockUnorderedCacheMaxSize) {
		const std::vector<uint8_t>& oldestBlockID = mBlockUnorderedCacheOrder.front();
		mBlockUnorderedCacheMap.erase(oldestBlockID);
		mBlockUnorderedCacheOrder.pop_front();
	}
}

/**
 * @brief Removes a block from the cache by its ID. If the block is found,
 *        it is erased from both the map and the LRU ordering list.
 *
 * @param blockID Vector of bytes representing the block's ID.
 */
void CBlockchainManager::removeBlockFromUnorderedCache(const std::vector<uint8_t>& blockID)
{
	std::unique_lock<std::shared_mutex> lock(mBlockUnorderedCacheMutex);

	auto it = mBlockUnorderedCacheMap.find(blockID);
	if (it != mBlockUnorderedCacheMap.end()) {
		// Erase from the LRU ordering list.
		mBlockUnorderedCacheOrder.erase(it->second.second);
		// Erase from the map.
		mBlockUnorderedCacheMap.erase(it);
	}
	// If not found, do nothing. 
}

/**
 * @brief Retrieves a block from the LRU cache by its ID. If found, the block
 *        is marked as most recently used by moving it to the back of the list.
 *
 * @param blockID Vector of bytes representing the block's ID.
 * @return Shared pointer to the requested block, or nullptr if not found in cache.
 */
std::shared_ptr<CBlock> CBlockchainManager::getBlockFromUnorderedCache(const std::vector<uint8_t>& blockID)
{
	// For a read+update operation on the LRU ordering, we need exclusive access 
	// to the data structures (we modify the LRU list even on "read").
	std::unique_lock<std::shared_mutex> lock(mBlockUnorderedCacheMutex);

	auto it = mBlockUnorderedCacheMap.find(blockID);
	if (it == mBlockUnorderedCacheMap.end()) {
		// Not found in cache, return nullptr.
		return nullptr;
	}

	// Move the accessed block to the end of the list (most recently used).
	mBlockUnorderedCacheOrder.erase(it->second.second);
	mBlockUnorderedCacheOrder.push_back(blockID);
	it->second.second = std::prev(mBlockUnorderedCacheOrder.end());

	// Return the cached block.
	return it->second.first;
}

/**
 * @brief Sets the maximum number of blocks that can be stored in the cache.
 *        If the new size is smaller than the current cache size, it will
 *        evict the least recently used blocks until the size requirement
 *        is satisfied.
 *
 * @param maxSize The new maximum number of blocks allowed in the cache.
 */
void CBlockchainManager::setBlockUnorderedCacheMaxSize(size_t maxSize)
{
	std::unique_lock<std::shared_mutex> lock(mBlockUnorderedCacheMutex);
	mBlockUnorderedCacheMaxSize = maxSize;

	// Trim the cache if necessary.
	while (mBlockUnorderedCacheMap.size() > mBlockUnorderedCacheMaxSize) {
		const std::vector<uint8_t>& oldestBlockID = mBlockUnorderedCacheOrder.front();
		mBlockUnorderedCacheMap.erase(oldestBlockID);
		mBlockUnorderedCacheOrder.pop_front();
	}
}

/**
 * @brief Returns the current number of blocks in the cache.
 *
 * @return The size of the block cache.
 */
size_t CBlockchainManager::getBlockUnorderedCacheSize() const
{
	std::shared_lock<std::shared_mutex> lock(mBlockUnorderedCacheMutex);
	return mBlockUnorderedCacheMap.size();
}

// Block Unordered Cache Methods - END


void CBlockchainManager::setDoNotProcessExtrernalChainProofs(bool doNotProcessExtChainProofs)
{
	std::lock_guard<std::mutex> lock(mFieldsGuardian);
	mDoNotProcessExternalChainProofs = doNotProcessExtChainProofs;
}

bool CBlockchainManager::getDoNotProcessExtrernalChainProofs()
{
	std::lock_guard<std::mutex> lock(mFieldsGuardian);
	return mDoNotProcessExternalChainProofs;
}

bool CBlockchainManager::getIsSynchronizationPaused()
{
	std::shared_lock lock(mSharedFieldsGuardian);
	return mSynchronizationPaused;
}

void CBlockchainManager::setIsSynchronizationPaused(bool isIt)
{
	std::shared_lock lock(mSharedFieldsGuardian);
	if (mSynchronizationPaused != isIt)
	{
		mSynchronizationPaused = isIt;
		if (isIt)
		{
			mTools->logEvent("[SYNCHRONIZATION]: Synchronization is being PAUSED.",
				eLogEntryCategory::localSystem,
				100,
				eLogEntryType::warning,
				eColor::orange);
		}
		else
		{
			mTools->logEvent("[SYNCHRONIZATION]: Synchronization is RESUMED.",
				eLogEntryCategory::localSystem,
				100,
				eLogEntryType::warning,
				eColor::lightGreen);
		}
	}
}


CBlockchainManager::CBlockchainManager(eBlockchainMode::eBlockchainMode mode, std::shared_ptr<CWorkManager> workManager)
{

	setIsReady(false);
	// LOCAL VARIABLES - BEGIN

	 mRecentTotalRewardCache;
	 mRecentTotalRewardTimestamp = 0;
	 mNetworkUtilizationCache = 0.0;
	 mNetworkUtilizationTimestamp = 0;
	 mBlockSizeCache = 0;
	 mBlockSizeTimestamp = 0;
	 mAverageBlockTimeCache = 0.0;
	 mAverageKeyBlockTimeCache = 0.0;
	 mAverageBlockTimeTimestamp = 0;
	 mAverageKeyBlockTimeTimestamp = 0;

	mLastSpottedCoreVersion = CGlobalSecSettings::getVersionNumber();
	mMaxMemPoolCacheSize = 1000;
	mSynchronizationPaused = false;
	mDoNotProcessExternalChainProofs = false;
	mDoNotProcessExternalBlocks = false;
	mBlockMetaDataAvailable = false;
	mTXMetaDataAvailable = false;
	mCachedAttoPerUSD = 0;
	mDailyOpenAttoPerUSD = mCachedAttoPerUSD;
	mLastPriceCheck = std::time(0);
	mLastDailyReset = mLastPriceCheck;
	mBlockUnorderedCacheMaxSize = 3000;
	mLastTimeBlockCacheCleared = 0;
	mLastCacheCleanup = std::chrono::steady_clock::now();
	mReceiptsCacheSize = 0;
	mMaxReceiptsCacheSize = 100'000'000; // 100 MB default
	mMaxBlockchainCacheSize = 100'000'000'0; // 1GB default
	mHeaviestHeight = 0;
	mRestartNeeded = false;
	mLeadingAlternativeHistory = false;
	mLocallyMinedDataBlocks = 0;
	mLocallyMinedKeyBlocks = 0;
	mTotalLocalReward = 0;
	mTXProcessedLocally = 0;
	mOperatorLeadingAHardFork = false;
	mCachedFilledInStatusBarID = CStatusBarHub::getInstance()->getNextCustomStatusBarID(mode);
	mVerfiedChainCSSyncTimestamp = 0;
	mHeaviestChainCSSyncTimestamp = 0;
	mVerfiedSyncedWithCSAtHeight = 0;
	mLastControllerLoopRun = 0;
	mVitalsMonitorRunning = false;
	mVitalsMinitorIsToBeRunning = true;
	mSyncIsStuck = false;
	mBPM = 0;
	mAPM = 0;
	mFarAwayCPRequestedTimestamp = 0;
	mLastBPMCleaned = 0;
	mJustAppendedLeader = false;
	mLastHeaviestChainproofSync = 0;
	mProcessingLongChainProof = 0;
	mCustomStatusBarFlashedTimestamp = 0;
	mVerifiedChainProofTotalDiff = 0;
	mHeaviestChainProofTotalDiff = 0;
	mNetworkTestingMode = false;
	mSkipLocalDataAnalysis = false;
	mCachedBlockQueueLength = 0;
	mSolidStorage = nullptr;
	mLastVitalsRefresh = 0;
	uint64_t validUpUntil = 0;

	std::vector<std::uint64_t> verifiedChainProofCumulativePoWs;// to be used during cache formation (optional optimization the FLow mechanics does not really need that).
	mAllVitalsLookingGood = false;
	mRecentlyProcessedChainProofsClearedTimestamp = 0;
	mSynchronizationPercentage = 0;
	uint64_t mVerifiedChainProofTotalDiff = 0;//cached
	uint64_t mHeaviestChainProofTotalDiff = 0;//cached
	mCurrentKeyHeight = 0;
	mCurrentHeight = 0;
	mLastTimeStatsToFile = 0;
	mProcessingStatus = eBlockProcessingStatus::idle;
	mTotalPoWAvailableAtAchievableIndex = 0;
	mAchievablePerspectiveAtIndex = 0;
	mCommitedHeaviestChainProofBlocksCount = 0;
	mIssueHeaviestChainProofReset = false;
	mDefaultDerouteDelay = 1;

	mLastTimeValidBlockProcessed = 0;
	mDataBlockFormationLimit = 0;
	mKeyBlockFormationLimit = 0;//unlimited
	mHeaviestChainProofTotalDifficulty = 0;
	mVerifiedChainProofTotalDifficulty = 0;
	mMode = mode;
	eBlockInstantiationResult::eBlockInstantiationResult biResult;
	std::vector<uint8_t> leaderBlockID;
	std::shared_ptr<CBlock> block;
	bool enableDTIServer = false;
	bool enableUDTServer = false;
	std::vector<uint8_t> expectedPerspective;
	bool enableQUICServer = false;
	bool useQUICForSync = true;
	bool useUDTForSync = true;
	bool enableKademlia = false;
	bool enableWebServer = false;
	bool enableWebSocketsServer = false;
	bool enableFileServer = false;
	bool enableCORSProxy = false;
	bool isSandbox = false;


	mTools = std::make_shared<CTools>("Blockchain Manager", mode);
	mBreakpointFactory = std::make_shared<CBreakpointFactory>(mTools);
	std::shared_ptr<CTools> tools = mTools;
	std::string modeStr = mTools->blockchainmodeToString(mode);
	try {
		tools->writeLine("Lo and behold; initializing the Great GRIDNET " + modeStr + " Blockchain Manager..");
		//below we will check if initialization of a blockchain manager running in the same mode has not BEGUN yet (tighter reuirement than COMPLETED)

		bool isTestNet = false;
		switch (mode)
		{
		case eBlockchainMode::LIVE:
			//assert(!sLiveInstanceInited);
			sStaticPointersGuardian.lock();
			sLiveInstanceInited = true;
			sStaticPointersGuardian.unlock();
			modeStr = "LIVE";
			break;
		case eBlockchainMode::TestNet:
			//assert(!sTestNetInstanceInited);
			sStaticPointersGuardian.lock();
			sTestNetInstanceInited = true;
			sStaticPointersGuardian.unlock();
			modeStr = "TestNet";
			isTestNet = true;
			break;
		case eBlockchainMode::LIVESandBox:
			sStaticPointersGuardian.lock();
			//assert(!sLIVESandBoxInstanceInited);
			sLIVESandBoxInstanceInited = true;
			sStaticPointersGuardian.unlock();
			modeStr = "LIVE-SandBox";
			isSandbox = true;
			break;
		case eBlockchainMode::TestNetSandBox:
			//assert(!sTestSandBoxInstanceInited);
			sStaticPointersGuardian.lock();
			sTestSandBoxInstanceInited = true;
			sStaticPointersGuardian.unlock();
			modeStr = "TestNet-SandBox";
			isSandbox = true;
			isTestNet = true;
			break;

		case eBlockchainMode::LocalData:
			//assert(!sLocalTestsInstanceInited);
			sStaticPointersGuardian.lock();
			sLocalTestsInstanceInited = true;
			sStaticPointersGuardian.unlock();
			modeStr = "LocalData";
			isSandbox = false;
			isTestNet = false;

			break;
		default:
			break;
		}

		mBlockQueueMaxLength = 300;
		std::lock_guard<std::mutex> lock(sFactoryProductionLockGuardian);
		mIsValidPointer = true;
		mDiscardedKeyBlocksCount = 0;
		mDiscardedDataBlocksCount = 0;

		mJustSavedKeyBlocksCount = 0;
		mJustSavedDataBlocksCount = 0;
		mAssumedAsLeaderDataBlocksCount = 0;
		mAssumedAsLeaderKeyBlocksCount = 0;

		mAverageKeyBlockInteval = 0;
		mAverageDataBlockInteval = 0;
		mForksCount = 0;
		mAverageDataBlockInteval = 0;
		mAverageKeyBlockInteval = 0;
		mCryptoFactory = nullptr; mSolidStorage = nullptr;  mSettings = CSettings::getInstance(mode); mLiveStateDB
			= nullptr;  mLiveTransactionsManager = nullptr; mTests = nullptr; //mScriptEngine = nullptr;
		mWorkManager = workManager;
		mLeader = nullptr;
		mNetworkManager = nullptr;
		mVerificationFlowTransactionsManager = nullptr;
		mBlockFormationFlowManager = nullptr;
		mTerminalTransactionsManager = nullptr;

		bool preventBlockchainFormationTasks = false;
		mForksCount = 0;
		// LOCAL VARIABLES - END


		//High Priority Questions - BEGIN
		if (getMode() == eBlockchainMode::TestNet || getMode() == eBlockchainMode::LIVE)
		{
			bool leadingAFork = tools->askYesNo("Are you leading a Hard Fork?", false, "Hard Fork", true, true, false, 10, true);
			if (leadingAFork)
			{
				leadingAFork = tools->askYesNo(tools->getColoredString(u8"Intended for use only by Wizards🧙. Proceed?", eColor::lightPink), false, "Hard Fork", true, true, false, 10, true);
				if (leadingAFork) {
					leadingAFork = tools->askYesNo(tools->getColoredString(u8"Have you included a check-point in Source, already?", eColor::lightPink), false, "Hard Fork", true, true, false, 10, true);
				}
				setIsOperatorLeadingAHardFork(leadingAFork);
			}

		}
		//High Priority Questions - END
		if (mode == eBlockchainMode::LIVESandBox || mode == eBlockchainMode::TestNetSandBox)
		{
			mSkipLocalDataAnalysis = true;
			preventBlockchainFormationTasks = true;
		}

		if (mode == eBlockchainMode::LocalData)
			mSkipLocalDataAnalysis = false;


		if (getMode() == eBlockchainMode::TestNet || getMode() == eBlockchainMode::LIVE)
		{
			mNetworkTestingMode = mSettings->getEnterNetworkAnalysisMode(false);

		}

		mDoNotProcessExternalBlocks = mSettings->getGetDisableExternalBlockProcessing();
		mDoNotProcessExternalChainProofs = mSettings->getDisableExternalChainProofProcessing();
		mSettings->getRequireObligatoryCheckpoints();

		if (mNetworkTestingMode)
		{
			tools->writeLine("Note: In Network Analysis Mode, initial local data-analysis will be disabled.");
			mSettings->setLogEvents(eLogEntryCategory::network, eLogEntryType::notification, true);
			mSettings->setLogEvents(eLogEntryCategory::network, eLogEntryType::warning, true);
			mSettings->setLogEvents(eLogEntryCategory::network, eLogEntryType::failure, true);

			mSettings->getMinEventPriorityForConsole(0);
			mSkipLocalDataAnalysis = true;
		}
		else
		{
			mSettings->getMinEventPriorityForConsole(1);
		}

		if (mSkipLocalDataAnalysis)
		{
			preventBlockchainFormationTasks = true;
			tools->writeLine("Note: disabling blockchain formation as data-analysis won't be performed..");
		}


		mSyncStateMachine = mSettings->getDoStateSynchronization(true);
		previousIterationBlockchainHeight = 0;
		previousIterationHSCachelength = 0;
		mHotStorageBlockCacheSize = 0;
		mIsNumberOfStateDomainsFresh = false;
		mTestTrieAfterBlockProcessing = false;//this allows the test unit to check if it has properly retrieved the state.
		mMaxReceiptsIndexCacheSize = 10000;// memory consumption = 512* cache size
		mNrOfCryticalErrors = 0;
		mHeaviestChainProofTotalDifficulty = 0;
		mVerifiedChainProofTotalDifficulty = 0;
		mIsSynced = false;
		mMaxNrOfFullBlocksToKeepInMemory = CGlobalSecSettings::getNrOfFullBlocksInHotStorage();
		mMaxNrOfPrunedBlocksToKeepInMemory = CGlobalSecSettings::getNrOfPrunedBlocksInHotStorage();
		mMaxNrOfOverallBlocksToKeepInMemory = CGlobalSecSettings::getOverallLimitOflBlocksInHotStorage();
		mStatusChange = eManagerStatus::eManagerStatus::initial;
		mStatus = eManagerStatus::eManagerStatus::initial;
		// WARNING: the order of object initializations is important due to dependence on internal sub-objects.

		mIsTestNet = (mode == eBlockchainMode::eBlockchainMode::TestNet || mode == eBlockchainMode::eBlockchainMode::TestNetSandBox) ? true : false;
		//TODO: initialize all the components: storage, state trie db; verify available data. connect to the network and update state
		this->mCryptoFactory = CCryptoFactory::getInstance();
		//in a SandBox instance of the BlockchainManager reads will be allowed but ALL the write and Commits will be disabled.
		this->mSolidStorage = CSolidStorage::getInstance(mode);
		updateVersionToFile();
		bool formBlocks = false;  // Unified block formation control (both key and data blocks)
		bool runAsBootstrapNode = false;

		if (getMode() == eBlockchainMode::LocalData)
			tools->writeLine("Note: Networking for local sandbox is *NOT* advised, but for development and local testing.");
		bool enableNetworkingSubSystem = preventBlockchainFormationTasks ? false : mSettings->getEnableNetworkingSubSystem(getMode() == eBlockchainMode::LocalData ? false : true);

		if (mNetworkTestingMode)
		{
			enableNetworkingSubSystem = true;
		}
		if (enableNetworkingSubSystem)
		{
			runAsBootstrapNode = mSettings->getRunAsNetworkBootstrapNode();

		}

		//Networking - Part 1 - BEGIN
		if (enableNetworkingSubSystem)
		{
			if (mSettings->getFirstRun())
			{
				mSettings->setUseQUICForSync(true);
				mSettings->setUseQUICForSync(true);
			}

			enableDTIServer = mSettings->getInitializeDTIServer();
			enableQUICServer = mSettings->getInitializeQUICServer(true);
			useQUICForSync = mSettings->getUseQUICForSync(true);
			useUDTForSync = mSettings->getUseUDTForSync(false);
			enableUDTServer = mSettings->getInitializeUDTServer(CGlobalSecSettings::getEnableUDTByDefault());
			enableKademlia = mSettings->getInitializeKademliaProtocol(true);
			enableWebServer = mSettings->getInitializeWebServer();
			enableWebSocketsServer = mSettings->getInitializeWebSocketsServer();
			enableCORSProxy = mSettings->getInitializeCORSProxy();
			enableFileServer = mSettings->getInitializeFileSystemServer();

			tools->writeLine(tools->getColoredString("Storing current networking configuration..", eColor::orange));

			mSettings->setPreviousSettingsAvailable(true);

			// launch threads. IMPORTANT: This needs to happen at the end. Otherwise, we risk the thread locking one of the initialization mutexes

			mNetworkManager = std::make_shared<CNetworkManager>(std::shared_ptr<CBlockchainManager>(this), runAsBootstrapNode, enableDTIServer, enableUDTServer, enableKademlia, enableFileServer, enableWebServer, enableWebSocketsServer, enableCORSProxy, enableQUICServer, useQUICForSync, useUDTForSync);
			mNetworkManager->setIsNetworkTestMode(mNetworkTestingMode);

			if (mNetworkTestingMode)
			{
				std::string analyseIP = mSettings->getFocusOnIPv4();
				if (!analyseIP.empty())
				{
					mNetworkManager->focusOnIP(mSettings->getFocusOnIPv4());
					tools->writeLine(tools->getColoredString("Grid Analysis is focused on IP: " + analyseIP, eColor::orange));
				}

			}

			//Systems which are to be pre-initialized - BEGIN

			// Initialize WFP Firewall if kernel mode is enabled
			if (false && mNetworkManager->getIsFirewallKernelModeIntegrationEnabled()) {
				if (!mNetworkManager->initializeWFPFirewall()) {
					tools->logEvent("Warning: WFP Firewall initialization failed, continuing with basic firewall",
						"Network Manager", eLogEntryCategory::localSystem, 10, eLogEntryType::warning);
				}
			}

			if (enableWebServer)
			{
				mSolidStorage->checkUIDataAvailable();
				mNetworkManager->initWebServer();
			}
			//Systems which are to be pre-initialized - END

		}
		else
		{
			mNetworkManager = nullptr;
		}

		tools->writeLine("Note: blockchain formation for Local Sandbox is *NOT* advised except for development and testing.");
		formBlocks = preventBlockchainFormationTasks ? false : mSettings->getDoBlockFormation(getMode() != eBlockchainMode::LocalData ? true : false);

		//Suppress Block Formation - BEGIN

		if (mWorkManager->getWorkers().size() == 0)
		{
			formBlocks = false;
			tools->writeLine(tools->getColoredString("Note: suppressing block formation as no computational devices are available.", eColor::lightPink));
		}

		if (getIsOperatorLeadingAHardFork())
		{
			formBlocks = true;
		}

		if (isSandbox)
		{
			formBlocks = false;
		}

		//Suppress Block Formation - END

		CKeyChain chain(false);
		std::string logID;

		//Set-up default Event-Logging Settings - BEGIN

		//The questions would be asked only once, and stored, but for when user decides not to use the 'previous configuration' anymore.

		mSettings->getMinEventPriorityForConsole();
		bool processAllNotifications = false;
		bool processAllExceptDebugInfo = false;

		if (getMode() == eBlockchainMode::TestNet || getMode() == eBlockchainMode::LIVE)
		{

			processAllExceptDebugInfo = tools->askYesNo("Do you want to log all types of events except Debug-Info?", true);
			if (!processAllExceptDebugInfo)
			{
				processAllNotifications = tools->askYesNo("Do you want to log ALL types of events (including debug-data)? - *NOT* advised", false);//not sandbox or local-data, ask if process everything
			}
		}

		bool logIt = false;//the default policy for sandbox and local-data blockchain instance

		//beforehand we asked whether to log all types of events except Debug-Info

		bool ask = false;

		for (int cat = eLogEntryCategory::network; cat <= eLogEntryCategory::unknown; cat++)
		{

			tools->writeLine("[ Setting-up " + tools->logEntryCategoryToStr(static_cast<eLogEntryCategory::eLogEntryCategory>(cat)) + " Notifications ]");

			for (int eType = eLogEntryType::notification; eType <= eLogEntryType::unknown; eType++)
			{
				ask = false;
				logID = "Log_" + std::to_string(cat) + "_" + std::to_string(eType);
				if (isSandbox || getMode() == eBlockchainMode::LocalData)
				{
					logIt = false;//do not log ANYTHING for a sandbox
					mSettings->setLogEvents(static_cast<eLogEntryCategory::eLogEntryCategory>(eType), static_cast<eLogEntryType::eLogEntryType>(cat), logIt);
				}
				else if (processAllNotifications)
				{
					logIt = true;
				}
				else if (processAllExceptDebugInfo && cat == eLogEntryCategory::debug)
				{
					logIt = false;
				}
				else if (processAllExceptDebugInfo && cat != eLogEntryCategory::debug)
				{
					logIt = true;
				}
				else
				{//ASK.
					//the below would save as well.
					ask = true;
					mSettings->getLogEvents(static_cast<eLogEntryCategory::eLogEntryCategory>(eType), static_cast<eLogEntryType::eLogEntryType>(cat));
				}
				if (!ask)
				{
					mSettings->wasQuestionAlreadyAsked(logID, true);
					mSettings->setLogEvents(static_cast<eLogEntryCategory::eLogEntryCategory>(eType), static_cast<eLogEntryType::eLogEntryType>(cat), logIt);
				}
			}

		}
	//Set-up default Event-Logging Settings - END

		std::string chainID = mSettings->getMinersKeyChainID();

		if (chainID.empty() || !mSettings->getCurrentKeyChain(chain, false))
		{
			if (tools->askYesNo("There is no Miner's (main) key-chain generated yet. Do you wish to generate one now? (Y / N):", true))
			{
				chainID = "key0";
				Botan::secure_vector<uint8_t> privKey;
				std::vector<uint8_t> pubKey;

				mCryptoFactory->genKeyPair(privKey, pubKey);
				chain = CKeyChain(mCryptoFactory, privKey);
				chain.setID(chainID);

				assertGN(mSettings->saveKeyChain(chain.getPackedData(), chain.getID()));
				assertGN(mSettings->setMinersKeyChainID(chain.getID()));

			}
		}
		

		if (mMode == eBlockchainMode::TestNet)
		{
			tools->writeLine("Operator's Key-Chain ID: " + tools->getColoredString(chain.getID(), eColor::lightCyan));
			std::vector<uint8_t> currentPubKey = chain.getPubKey();
			std::vector<uint8_t> currentID;
			if (mCryptoFactory->genAddress(currentPubKey, currentID))
			{
				tools->writeLine("Operator's State Domain ID: " + tools->getColoredString(tools->bytesToString(currentID), eColor::lightCyan));

				tools->writeLine(tools->getColoredString("Note:", eColor::orange) + " Your current ID within the network is: " + tools->getColoredString(tools->bytesToString(currentID), eColor::lightGreen) +
					" use " + tools->getColoredString("'getNextID'", eColor::lightCyan) + " to generate and set new ID from your key-chain at any moment.");

				Sleep(4000);
			}
		}

		//Checkpoints Activation - BEGIN (Part 1)
		loadCheckpoints();
		//Checkpoints Activation - END (Part 1)
	
		// Changes in Checkpoints Detection - BEGIN
	
		//[Rationale]: it is assumed that if a new checkpoint is added, it is as a consequence of a change to interpretation of something present within the elements of 
		//the blockchain (instructions, data etc.).
		// 
		//In such a case, local node should re-validate the entire history of events, beginning from the Genesis Block.
		//We keep track of the current (as defined by the current build) number of checkpoints and the one which was present during previous run.
		// If these counts are not the same - the entire Verified Chain Proof and Verified Path data structures would be wiped away from Cold Storage.
		// 
		//[Notice]: the Heaviest Chain Proof and Heaviest Path data structures would remain intact. Same holds for data blocks and key-blocks. 
		//			Verified Chain Proof and Verified Path would thus be restored based on local data. 

		uint64_t previousCheckpointsCount = 0;
		uint64_t newCheckpointsCount = getForcedResyncSequenceNumber(mode);
		mSettings->getPreviousCheckpointsCount(previousCheckpointsCount);
		if (mode == eBlockchainMode::TestNet)
		{
			if (previousCheckpointsCount != newCheckpointsCount)
			{


				if (tools->askYesNo("New checkpoints found. About to initialize a full re-sync." + tools->getColoredString(" Do you agree?\a\a\a", eColor::orange), true, "", true, true, true, 30))
				{
					tools->writeLine(tools->getColoredString("New checkpoint present.", eColor::lightCyan) + " I will re-validate the entire history of events starting from the Genesis Block.\a\a\a");
					resync(false);
					mSettings->setCheckpointsCount(newCheckpointsCount);
					tools->writeLine(tools->getColoredString("Updated Checkpoints: ", eColor::lightCyan) + tools->getColoredString(std::to_string(newCheckpointsCount), eColor::lightGreen));
				}
				else
				{

					tools->writeLine(tools->getColoredString("Re-sync aborted. Node might not be able to synchronize properly!\a\a\a", eColor::cyborgBlood));

					if (tools->askYesNo("Force checpoints onto Cold Storage?" + tools->getColoredString(" (Wizards only)", eColor::lightPink), false, "", true, true, true, 30))
					{
						mSettings->setCheckpointsCount(newCheckpointsCount);
						tools->writeLine(tools->getColoredString("Updated Checkpoints: ", eColor::lightCyan) + tools->getColoredString(std::to_string(newCheckpointsCount), eColor::lightGreen));

					}
				}
			}
		}
		// Changes in Checkpoints Detection - END

		std::vector<uint8_t> currentPerspective;

		if (!mNetworkTestingMode)
		{
			//find the most recent block and its StateDB root
			tools->writeLine("Retrieving paths from Cold Storage..");
			getPath(eChainProof::heaviest);//it is important to this before the actual block body is retrieved since we might need to fall-back
			//to an earlier block if there was a write-error. The path will be verified later on.
			getPath(eChainProof::verified);

			if (mHeaviestPath.size() == 0 && mVerifiedPath.size() > 0)
			{
				tools->writeLine("Heaviest Path Empty.. transplanting from the Verified Path..");
				resetHeaviestChainProof();
			}

			tools->writeLine("Retrieving chain-proofs from Cold Storage..");
			getChainProof(eChainProof::heaviest);
			getChainProof(eChainProof::verified);


			// Report Chain Proof Availability - BEGIN
			if (mVerifiedChainProof.size() > 0 || mVerifiedPath.size() > 0)
			{
				std::stringstream ss;
				ss << "Verified Chain-Proof state: "
					<< tools->getColoredString("Retrieved", eColor::lightGreen)
					<< " (Chain size: " << mVerifiedChainProof.size()
					<< ", Path size: " << mVerifiedPath.size() << ")";

				if (mVerifiedChainProof.size() != mVerifiedPath.size())
				{
					ss << tools->getColoredString(" - WARNING: Size mismatch!", eColor::lightPink);
				}
				tools->writeLine(ss.str());
			}
			else
			{
				tools->writeLine(tools->getColoredString(
					"No Verified Chain-Proof available", eColor::lightPink));
			}

			if (mHeaviestChainProof.size() > 0 || mHeaviestPath.size() > 0)
			{
				std::stringstream ss;
				ss << "Heaviest Chain-Proof state: "
					<< tools->getColoredString("Retrieved", eColor::lightGreen)
					<< " (Chain size: " << mHeaviestChainProof.size()
					<< ", Path size: " << mHeaviestPath.size() << ")";

				if (mHeaviestChainProof.size() != mHeaviestPath.size())
				{
					ss << tools->getColoredString(" - WARNING: Size mismatch!", eColor::lightPink);
				}
				tools->writeLine(ss.str());
			}
			else
			{
				tools->writeLine(tools->getColoredString(
					"No Heaviest Chain-Proof available", eColor::lightPink));
			}

			// Report relative sizes if both exist
			if (mVerifiedChainProof.size() > 0 && mHeaviestChainProof.size() > 0)
			{
				std::stringstream ss;
				ss << "Chain-Proof comparison: ";
				if (mVerifiedChainProof.size() == mHeaviestChainProof.size())
				{
					ss << tools->getColoredString("Equal sizes", eColor::lightGreen);
				}
				else
				{
					std::string diff = mVerifiedChainProof.size() > mHeaviestChainProof.size() ?
						"Verified is longer by " : "Heaviest is longer by ";
					ss << tools->getColoredString(diff +
						std::to_string(std::abs(static_cast<int64_t>(mVerifiedChainProof.size()) -
							static_cast<int64_t>(mHeaviestChainProof.size()))) +
						" blocks", eColor::orange);
				}
				tools->writeLine(ss.str());
			}
			// Report Chain Proof Availability - END

			// Ensure Verified Path <-> Verified Chain Proof congruency - BEGIN
			if (mVerifiedChainProof.size() > 0 || mVerifiedPath.size() > 0)
			{
				// Check if there's a size mismatch between verified path and chain proof
				if (mVerifiedChainProof.size() != mVerifiedPath.size())
				{
					tools->logEvent(
						tools->getColoredString("The Verified Chain-Proof and Verified Path are inconsistent. Initiating Self Repair Maneuvers.", eColor::lightPink),
						eLogEntryCategory::localSystem, 10, eLogEntryType::warning);

					// Fix-Up Method 1 - BEGIN
					// This method regenerates the verified path from the verified chain proof
					// It assumes the verified chain proof is correct and the path needs to be regenerated
					tools->logEvent(
						tools->getColoredString(" - [ Emergency Method 1 ] - ", eColor::orange) +
						"Recalculating Verified Path based on Verified Chain-Proof. " +
						"Chain Proof size: " + std::to_string(mVerifiedChainProof.size()) +
						", Path size: " + std::to_string(mVerifiedPath.size()),
						eLogEntryCategory::localSystem, 10, eLogEntryType::notification);

					uint64_t oldPathSize = mVerifiedPath.size();
					getPath(eChainProof::verified, true);

					tools->logEvent(
						tools->getColoredString("Method 1 Complete: ", eColor::orange) +
						"Previous Path size: " + std::to_string(oldPathSize) +
						", Current Path size: " + std::to_string(mVerifiedPath.size()),
						eLogEntryCategory::localSystem, 10, eLogEntryType::notification);
					// Fix-Up Method 1 - END

					// Check if Fix-Up Method 1 didn't resolve the issue
					if (mVerifiedChainProof.size() != mVerifiedPath.size() && !mVerifiedPath.empty())
					{
						// Fix-Up Method 2 - BEGIN
// This method regenerates the verified chain proof from the verified path
// It assumes the path is correct and tries to reconstruct the chain proof
// by fetching blocks from storage and extracting their headers
						tools->logEvent(
							tools->getColoredString(" - [ Emergency Method 2 ] - ", eColor::orange) +
							"Recalculating Verified Chain-Proof based on Verified Path and locally available blocks. " +
							"Path size: " + std::to_string(mVerifiedPath.size()),
							eLogEntryCategory::localSystem, 10, eLogEntryType::notification);

						// Get status bar hub for progress reporting
						std::shared_ptr<CStatusBarHub> barHub = CStatusBarHub::getInstance();
						eBlockchainMode::eBlockchainMode mode = getMode();
						const uint64_t barID = 501; // Use a dedicated bar ID for self-repair operations

						// Remember the original size for reporting
						uint64_t originalChainProofSize = mVerifiedChainProof.size();

						// Clear the chain proof so we can reconstruct it from scratch
						mVerifiedChainProof.clear();

						// Track successful reconstructions for logging
						uint64_t successfulBlocks = 0;
						uint64_t pathSize = mVerifiedPath.size();

						// Initialize progress tracking
						int lastReportedProgress = -1;
						barHub->setCustomStatusBarText(mode, barID, "Self-Repair: Preparing to reconstruct chain proof...");

						// Traverse path from oldest to newest to reconstruct chain proof in correct order
				
				
						// First pass - collect all available headers
						for (uint64_t i = 0; i < pathSize; i++) {
							// Calculate and report progress
							int progress = static_cast<int>((static_cast<double>(i) / pathSize) * 100);
							if (progress != lastReportedProgress) {
								lastReportedProgress = progress;
								barHub->setCustomStatusBarText(mode, barID,
									"Self-Repair: Reconstructing chain proof... " + std::to_string(progress) + "% (" +
									std::to_string(i) + "/" + std::to_string(pathSize) + " blocks)");
							}

							eBlockInstantiationResult::eBlockInstantiationResult bir;
							std::shared_ptr<CBlock> block = mSolidStorage->getBlockByHash(mVerifiedPath[i], bir);



							if (!block) {

								// IMPORTANT: we're retrieving  blocks from the Genesis Block so we ABORT on the first missing block.
							
								// Log failure to retrieve block
								tools->logEvent(
									tools->getColoredString("[Self-Repair] ", eColor::orange) +
									"Failed to retrieve block at path index " + std::to_string(i) +
									" with ID: " + tools->base58CheckEncode(mVerifiedPath[i]),
									eLogEntryCategory::localSystem, 10, eLogEntryType::failure);

						

								break;
							}
							else if(block){
							
								// Successfully retrieved block, get its packed header data
								std::vector<uint8_t> packed;
								if (block->getHeader()->getPackedData(packed)) {
									mVerifiedChainProof.push_back(packed);
									successfulBlocks++;
								}
								else {
									// Log failure to pack header data
									tools->logEvent(
										tools->getColoredString("[Self-Repair] ", eColor::orange) +
										"Failed to pack header for block at path index " + std::to_string(i) +
										" with height " + std::to_string(block->getHeader()->getHeight()),
										eLogEntryCategory::localSystem, 10, eLogEntryType::failure);

									break;
								}
							}
							
						}


						// Log results of Fix-Up Method 2
						tools->logEvent(
							tools->getColoredString("[Self-Repair] Method 2 Complete: ", eColor::orange) +
							"Original Chain-Proof size: " + std::to_string(originalChainProofSize) +
							", New Chain-Proof size: " + std::to_string(mVerifiedChainProof.size()) +
							", Successful blocks: " + std::to_string(successfulBlocks) +
							", Continuous sequence: " + std::to_string(mVerifiedChainProof.size()) + " blocks",
							eLogEntryCategory::localSystem, 10, eLogEntryType::notification);

						// Clear the status bar after completion
						barHub->invalidateCustomStatusBar(mode, barID);
						// Fix-Up Method 2 - END

					}
					else
					{
						// Fix-Up Method 1 was successful
						tools->logEvent(
							tools->getColoredString("The Verified Chain-Proof was repaired with Emergency Method 1.", eColor::lightGreen),
							eLogEntryCategory::localSystem, 10, eLogEntryType::notification);
					}


					// Adjust Verified Path - BEGIN
					// Rationale: if we were able to recontruct at least portion of Verified Chain Proof - adjust Path accotdingly.
					if (mVerifiedChainProof.size() != mVerifiedPath.size() && !mVerifiedChainProof.empty())
					{
						size_t oldSize = mVerifiedPath.size();
						size_t newSize = mVerifiedChainProof.size();
						size_t adjustedBy = oldSize - newSize;

						mVerifiedPath.erase(
							mVerifiedPath.begin() + newSize,
							mVerifiedPath.end()
						);

						tools->logEvent(
							"Adjusted verified path height to " + std::to_string(newSize) +
							" by removing " + std::to_string(adjustedBy) + " elements. " +
							tools->getColoredString("The Verified Chain-Proof was repaired with Emergency Method 1.", eColor::lightGreen),
							eLogEntryCategory::localSystem,
							10,
							eLogEntryType::notification
						);
					}

					// Adjust Verified Path - END




					// Final verification check
					if (mVerifiedChainProof.size() != mVerifiedPath.size())
					{
						// Both repair methods failed
						tools->logEvent(
							tools->getColoredString("CRITICAL: Self-Repair Mechanisms Failed. Chain-Proof size: " +
								std::to_string(mVerifiedChainProof.size()) + ", Path size: " +
								std::to_string(mVerifiedPath.size()), eColor::cyborgBlood),
							eLogEntryCategory::localSystem, 10, eLogEntryType::failure);

						// Consider additional emergency measures
						if (!mVerifiedChainProof.empty() && !mVerifiedPath.empty())
						{
							tools->logEvent(
								tools->getColoredString("Attempting minimum viable recovery - truncating to matching sizes", eColor::orange),
								eLogEntryCategory::localSystem, 10, eLogEntryType::warning);

							// Truncate to the smaller of the two sizes as a last resort
							uint64_t minSize = min(mVerifiedChainProof.size(), mVerifiedPath.size());
							if (mVerifiedChainProof.size() > minSize)
								mVerifiedChainProof.resize(minSize);
							if (mVerifiedPath.size() > minSize)
								mVerifiedPath.resize(minSize);

							// Also truncate key heights index to match
							if (minSize > 0)
							{
								CBlockHeader::eBlockHeaderInstantiationResult instRes;
								std::string error;
								std::shared_ptr<CBlockHeader> lastHeader = CBlockHeader::instantiate(
									mVerifiedChainProof[minSize - 1], instRes, error, false, mMode);

								if (lastHeader) {
									uint64_t maxKeyHeight = lastHeader->getKeyHeight();
									truncateKeyBlockIDsFromKeyHeight(maxKeyHeight + 1, eChainProof::verified);

									tools->logEvent(
										tools->getColoredString("Minimum viable recovery complete - truncated to " +
											std::to_string(minSize) + " blocks", eColor::lightGreen),
										eLogEntryCategory::localSystem, 10, eLogEntryType::notification);
								}
							}
						}
					}
					else
					{
						// Self-repair was successful
						tools->logEvent(
							tools->getColoredString("Self-Repair Complete: Verified Chain-Proof and Path are now consistent with " +
								std::to_string(mVerifiedChainProof.size()) + " blocks.", eColor::lightGreen),
							eLogEntryCategory::localSystem, 10, eLogEntryType::notification);

						mTools->writeLine("Flushing repaired Verified Chain Proof to Cold Storage..", eColor::orange);
						//syncChainProofToColdStorage(eChainProof::verified);
					}
				}
				else
				{
					// No mismatch detected - everything is fine
					tools->logEvent(
						"Verified Chain-Proof and Path consistency check passed. Size: " +
						std::to_string(mVerifiedChainProof.size()) + " blocks.",
						eLogEntryCategory::localSystem, 2, eLogEntryType::notification);
				}
			}
			else
			{
				// Either verified path or chain proof (or both) is empty
				tools->logEvent(
					tools->getColoredString("Chain integrity check skipped - Verified Chain-Proof size: " +
						std::to_string(mVerifiedChainProof.size()) + ", Verified Path size: " +
						std::to_string(mVerifiedPath.size()), eColor::lightPink),
					eLogEntryCategory::localSystem, 5, eLogEntryType::notification);
			}


			if (mVerifiedChainProof.size() != mVerifiedPath.size())
			{
				mVerifiedChainProof.clear();
				mVerifiedPath.clear();

			}
			// Ensure Verified Path <-> Verified Chain Proof congruency - END

			// Ensure Heaviest Path <-> Heaviest Chain Proof congruency - BEGIN
			if (mHeaviestChainProof.size() > 0 || mHeaviestPath.size() > 0)
			{
				if (mHeaviestChainProof.size() != mHeaviestPath.size())
				{
					// Attempt to fix chain-proofs - BEGIN
					bool operationSucceeded = false;
				
					if (!operationSucceeded)
					{

						tools->writeLine("Attempting to restore Heaviest Path based on Heaviest Chain-Proof..");
						mHeaviestPath.clear();
						if (mHeaviestChainProof.size())
						{
							for (uint64_t c = 0; c < mHeaviestChainProof.size(); c++)
							{
								mHeaviestPath.push_back(mCryptoFactory->getSHA2_256Vec(mHeaviestChainProof[c]));
							}


							if (tools->compareByteVectors(mCryptoFactory->getSHA2_256Vec(mHeaviestChainProof[mHeaviestChainProof.size() - 1]),
								mHeaviestPath[mHeaviestPath.size() - 1]))
							{
								operationSucceeded = true;
								tools->writeLine("Operation succeed. Heaviest Chain-Proof and Path fixed.");
							}
							else
							{
								tools->writeLine("Operation failed. Heaviest Chain-Proof still inconsistent.");
							}
						}
						else
						{
							operationSucceeded = true;
							tools->writeLine("Operation succeed. Heaviest Chain-Proof and Path fixed.");
						}
					}


					if (!operationSucceeded)
					{
						// Last resort
						tools->writeLine("I'll assume 'verified' as 'heaviest'.");
						mHeaviestChainProof = mVerifiedChainProof;
						mHeaviestPath = mVerifiedPath;
						mHeaviestPathDouble = mHeaviestPath;
					}
				}
				// Attempt to fix chain-proofs - END
			}
			// Ensure Heaviest Path <-> Heaviest Chain Proof congruency - END

		}

		// Chain-Proofs' Pre-Analysis - END

		// Chain-Proofs' Analysis - BEGIN

		if (!mSkipLocalDataAnalysis && mVerifiedChainProof.size())
		{
			tools->writeLine(tools->getColoredString("Verifying the 'verified' chain-proof..", eColor::blue));

		

#if DO_MT_CHAINPROOF_VALIDATION_TESTS==1
			uint64_t mVerifiedChainProofTotalDifficultyTest = 0;
			std::vector<std::uint64_t> powsTest;
			uint64_t validUpUntilTest = 0;
			bool testVerfied = false;
			bool testSucceeded = false;
			// Test Chain Proof Verification Multi-Threaded (Part 1) - BEGIN
			// Negative (0) is POSITIVE (enum). Positive is Wrong.
			if (!verifyChainProofMT(mVerifiedChainProof, mVerifiedChainProofTotalDifficultyTest, true, true, nullptr, false, powsTest, nullptr, 0, false, true, 999, validUpUntilTest, 8))
			{
				testVerfied = true;
			}

			// Test Chain Proof Verification Multi-Threaded (Part 1)  - END
#endif

			// Verified Chain-Proof Maintenance - BEGIN

// Step 1: Structural Validation
			eChainProofValidationResult::eChainProofValidationResult result =
				verifyChainProof(
					mVerifiedChainProof,
					mVerifiedChainProofTotalDifficulty,
					true,
					true,
					nullptr,
					false,
					verifiedChainProofCumulativePoWs,
					nullptr,
					0,
					false,
					false,
					999,
					true,
					validUpUntil
				);

			// Handle structural validation results
			if (result) // Chain proof has structural issues
			{
				if (validUpUntil)
				{
					uint64_t cutPosition = validUpUntil + 1;
					if (cutPosition < mVerifiedChainProof.size())
					{
						tools->writeLine(
							tools->getColoredString(
								"The 'verified' chain-proof is only partially valid (up to block " +
								std::to_string(validUpUntil) + "). Reason: '" +
								mTools->getColoredString(
									mTools->CPValidationResultToString(result),
									eColor::lightPink
								),
								eColor::cyborgBlood
							)
						);

						mVerifiedChainProof.erase(
							mVerifiedChainProof.begin() + cutPosition,
							mVerifiedChainProof.end()
						);
						if (!mVerifiedPath.empty() && cutPosition < mVerifiedPath.size())
						{
							mVerifiedPath.erase(
								mVerifiedPath.begin() + cutPosition,
								mVerifiedPath.end()
							);
						}
					}
					else
					{
						tools->writeLine(
							tools->getColoredString(
								"Warning: Invalid cut position calculated. Clearing chain-proof entirely.",
								eColor::cyborgBlood
							)
						);
						mVerifiedChainProof.clear();
						mVerifiedPath.clear();
					}
				}
				else
				{
					tools->writeLine(
						tools->getColoredString(
							"The 'verified' chain-proof is structurally invalid. Clearing entirely.",
							eColor::cyborgBlood
						)
					);
					mVerifiedChainProof.clear();
					mVerifiedPath.clear();
				}
			}

			// Step 2: Perspective Validation (only if we have a structurally valid chain)
			if (!mVerifiedChainProof.empty())
			{
				tools->writeLine("Validating perspectives in structurally valid chain proof...");

				CTrieDB tempDB(CGlobalSecSettings::getStateDBID(), mSolidStorage);
				bool perspectiveFound = false;
				uint64_t currentIndex = mVerifiedChainProof.size() - 1;

				// Search backwards for a valid perspective
				while (currentIndex < mVerifiedChainProof.size()) // Note: Unsigned comparison
				{
					CBlockHeader::eBlockHeaderInstantiationResult ebhi;
					std::string errorInfo;
					auto bhi = CBlockHeader::instantiate(mVerifiedChainProof[currentIndex], ebhi, errorInfo);

					if (bhi)
					{
						// First check for alternative (checkpoint) perspective
						std::vector<uint8_t> effectivePerspective = getEffectivePerspective(mVerifiedPath[currentIndex]);

						if (!effectivePerspective.empty())
						{
							tools->writeLine(tools->getColoredString("Found alternative perspective at height " +
								std::to_string(currentIndex), eColor::orange));
						}
						else
						{
							// Use native perspective from block header
							effectivePerspective = bhi->getPerspective(eTrieID::state);
							tools->writeLine(tools->getColoredString("Using native perspective at height " +
								std::to_string(currentIndex), eColor::lightGreen));
						}

						if (tempDB.setPerspective(effectivePerspective))
						{
							perspectiveFound = true;

							// Cut chain to this point if it's not the tip
							if (currentIndex != mVerifiedChainProof.size() - 1)
							{
								uint64_t cutPosition = currentIndex + 1;
								tools->writeLine(tools->getColoredString(
									"Found valid perspective at height " + std::to_string(currentIndex) +
									". Cutting chain to this point.", eColor::lightPink));

								mVerifiedChainProof.erase(
									mVerifiedChainProof.begin() + cutPosition,
									mVerifiedChainProof.end()
								);
								mVerifiedPath.erase(
									mVerifiedPath.begin() + cutPosition,
									mVerifiedPath.end()
								);
							}

							setAchievablePerspectiveAtIndex(currentIndex);
							break;
						}
					}

					if (currentIndex == 0) break;
					currentIndex--;
				}

				if (!perspectiveFound)
				{
					tools->writeLine(
						tools->getColoredString(
							"No valid perspectives found in chain proof. Clearing entirely.",
							eColor::cyborgBlood
						)
					);
					mVerifiedChainProof.clear();
					mVerifiedPath.clear();
					setAchievablePerspectiveAtIndex(0);
				}
				else if (currentIndex == mVerifiedChainProof.size() - 1)
				{
					// Chain proof is fully valid with valid perspective at tip
					tools->writeLine(
						"The 'verified' chain-proof" +
						tools->getColoredString(" is VALID", eColor::lightGreen) +
						" with valid perspective. Total difficulty: " +
						std::to_string(mVerifiedChainProofTotalDifficulty)
					);
					pingChainProofCSSyncTime(eChainProof::verified);
				}
			}

			mLeader = nullptr; // Reset leader as chain proof has been modified
			// Verified Chain-Proof Maintenance - END

#if DO_MT_CHAINPROOF_VALIDATION_TESTS==1
			// Test Chain Proof Verification Multi-Threaded (Part 2) - BEGIN
			if (!(mVerifiedChainProofTotalDifficultyTest == mVerifiedChainProofTotalDifficulty
				&& validUpUntilTest == validUpUntil))
			{

				testSucceeded = false;
			}


			// Ensure PoWs and powsTest are identical before the second phase
			bool powIdentical = (pows.size() == powsTest.size());
			if (powIdentical)
			{
				for (size_t i = 0; i < pows.size(); i++)
				{
					if (pows[i] != powsTest[i])
					{
						powIdentical = false;
						break;
					}
				}
			}

			if (!powIdentical)
			{
				tools->writeLine("PoWs and powsTest are not identical.");
				testSucceeded = false;  // Early exit if they are not the same
			}
#endif
		}

		// Test Chain Proof Verification Multi-Threaded (Part 2) - END
		if (!mSkipLocalDataAnalysis && mHeaviestChainProof.size())
		{
			validUpUntil = 0;
			tools->writeLine(tools->getColoredString("Verifying the 'heaviest' chain-proof..", eColor::blue));


			eChainProofValidationResult::eChainProofValidationResult result = verifyChainProof(mHeaviestChainProof, mHeaviestChainProofTotalDifficulty, true, true, nullptr, false,
				mHeaviestChainProofCumulativePoWs, nullptr, 0, false, false, true, validUpUntil);

			// Let's refrain ourselves from employing sophisticated Heaviest Chain Proof self-repair logic.
			// Heaviest Chain Proof (in contrast with the Verified Chain Proof) can be cheaply (in both computational and data exchange terms) restored from the Network.
			
			// Negative (0) is POSITIVE (enum). Positive is Wrong.
			if (!result)// do not require checkpoints during local analysis. 
				// This comes handy in particular before Tier 0 nodes are preparing for a hard fork. 
				// These need to reprocess the enture history of events BEFORE they are ready to accept the most recen Hard Fork Block.
				// Not requiring checkpoints in Heaveist Chain Proof prevents the chain proof from being wiped out completely and allows node
				// to proceed with a local resync instead of requiring the presence of a Hard Fork leaer.
			{
				tools->writeLine("The 'heaviest' Chain-Proof" + tools->getColoredString(" is VALID", eColor::lightGreen) + " Total Difficulty:" + std::to_string(mHeaviestChainProofTotalDifficulty));
				pingChainProofCSSyncTime(eChainProof::heaviest);
			}
			else
			{

				if (mVerifiedChainProof.size())
				{
					std::stringstream ss;
					ss << mTools->getColoredString("The 'heaviest' chain-proof is invalid.", eColor::cyborgBlood) <<
						" Reason: '" + mTools->getColoredString(mTools->CPValidationResultToString(result), eColor::lightPink) << "'" <<
						mTools->getColoredString(" I'll assume the 'verified' one as 'heaviest'..", eColor::orange);

					tools->writeLine(ss.str());

					mHeaviestChainProof = mVerifiedChainProof;
					mHeaviestPath = mVerifiedPath;
					mHeaviestPathDoubleGuardian.lock();
					mHeaviestPathDouble = mHeaviestPath;
					mHeaviestPathDoubleGuardian.unlock();
					setAchievablePerspectiveAtIndex(mVerifiedChainProof.size() ? (mVerifiedChainProof.size() - 1) : 0);
					mHeaviestChainProofTotalDifficulty = mVerifiedChainProofTotalDifficulty;



					//IMPORTANT: we need to rebuild the PoW cache in any case down below! Thu a call to verifyChainProof even though was copied from verified chain-proof.
					tools->writeLine("Re-validating the restored 'heaviest' chain-proof in order to rebuild the PoW cache..");

					//NOTICE: WE DO NOT REQURE CHECKPOINTS BELOW. The below ID needed as we need the getColoredString to be calculated YET we DO NOT wipe anything it fails validation . Heaviest Chain-Proof would be restored from the network anyway.
					//	    we DO NOT do the below since the Verified Chain-Proof based on which Heviest Chain-Proof was restored MIGHT contain all the checkpoints YET.
					
					eChainProofValidationResult::eChainProofValidationResult result = verifyChainProof(mHeaviestChainProof, mHeaviestChainProofTotalDifficulty, true, true, nullptr, false, mHeaviestChainProofCumulativePoWs, nullptr, 0, false, false, true, false);
					
					// Negative (0) is POSITIVE (enum). Positive is Wrong.
				
				}
				else
				{

					std::stringstream ss;
					ss << mTools->getColoredString("The 'heaviest' chain-proof is invalid.", eColor::cyborgBlood) <<
						" Reason: '" + mTools->getColoredString(mTools->CPValidationResultToString(result), eColor::lightPink) << "'" <<
						mTools->getColoredString("The 'verified' is unavailable.. clearing state", eColor::orange);

					tools->writeLine(ss.str());
					setLeader(nullptr);
					mHeaviestChainProof.clear();
					mHeaviestPath.clear();
					mHeaviestChainProofCumulativePoWs.clear();
					setCachedHeight(0);
					setCachedHeight(0, true);
					mHeaviestPathDoubleGuardian.lock();
					mHeaviestPathDouble = mHeaviestPath;
					mHeaviestPathDoubleGuardian.unlock();
					setHeaviestChainProofLeadBlockID(std::vector<uint8_t>());
					setAchievablePerspectiveAtIndex(0);
					mHeaviestChainProofTotalDifficulty = 0;
				}
			}
		}

		// Final Verified <-> Heaviest Chain-Proofs' Cross Comparison - BEGIN

		if ((mHeaviestChainProofTotalDifficulty < mVerifiedChainProofTotalDifficulty)
			|| (((mHeaviestChainProofTotalDifficulty == mVerifiedChainProofTotalDifficulty) && mVerifiedChainProof.size() > mHeaviestChainProof.size()))
			)
		{

			tools->writeLine(tools->getColoredString("The Verified Chain Proof seems better than Heaviest, replacing..", eColor::orange));
			eChainProofValidationResult::eChainProofValidationResult cpValRes = eChainProofValidationResult::invalidGeneral;

			eChainProofUpdateResult::eChainProofUpdateResult overRes = analyzeAndUpdateChainProof(mVerifiedChainProof,cpValRes, mHeaviestChainProof, mHeaviestChainProofTotalDifficulty);


			if (overRes == eChainProofUpdateResult::updated || overRes == eChainProofUpdateResult::updatedLocalBestKnown)
			{
				tools->writeLine(tools->getColoredString("The Heaviest Chain Proof was updated based on the Verified Chain-Proof.", eColor::neonGreen));
			}
			else
			{
				tools->writeLine(tools->getColoredString("Updating Heaviest Chain Proof based on the Verified Chain-Proof failed.", eColor::lightPink));
			}
		}

		if (!(mHeaviestChainProof.size() == mHeaviestPath.size() && mHeaviestPathDouble.size() == mHeaviestPath.size()))
		{
			tools->writeLine(tools->getColoredString("I'll fix 'heaviest' path based on the 'heaviest' chain-proof..", eColor::lightPink));

			mHeaviestPathDoubleGuardian.lock();
			mHeaviestPath.clear();
			std::shared_ptr<CCryptoFactory> cf = CCryptoFactory::getInstance();

			for (uint64_t i = 0; i < mHeaviestChainProof.size(); i++)
			{
				mHeaviestPath.push_back(cf->getSHA2_256Vec(mHeaviestChainProof[i]));
			}

			mHeaviestPathDouble = mHeaviestPath;
			mHeaviestPathDoubleGuardian.unlock();

		}
		assertGN(mHeaviestChainProofCumulativePoWs.size() == mHeaviestChainProof.size() && mHeaviestChainProof.size() == mHeaviestPath.size());
		// Final Verified <-> Heaviest Chain-Proofs' Cross Comparison - END
		
		// Chain-Proofs' Analysis - END
		
		if (!mNetworkTestingMode)
		{
			// Checkpoints Activation - BEGIN ( Part 1)

			activateCheckpoints(eChainProof::heaviest);

			// Checkpoints Activation - END ( Part 1)
		}

		// Chain-Proof Cache Preparation - BEGIN

		// CRITICAL SECTION - BEGIN

		// Cache Level 1 - INIT
		mHeaviestPathGuardian.lock();
		mVerifiedPathGuardian.lock();
		mVerifiedPathDoubleGuardian.lock();
		// Cache Level 1  - INIT_END

		// Logic - BEGIN
		mVerifiedChainProofDouble = mVerifiedChainProof;
		mVerifiedPathDouble = mVerifiedPath;

		if (mHeaviestChainProof.size())
		{
			double percentage;
			if (mVerifiedChainProof.size() == mHeaviestChainProof.size()) {
				percentage = 100.0;
			}
			else {
				percentage = (100.0 * mVerifiedChainProof.size()) / mHeaviestChainProof.size();
				if (percentage > 99.99 && percentage < 100) {
					percentage = 99.99;
				}
			}

			setSyncPercentage(percentage);
		}
		mCachedLeader = mLeader;

		if (mLeader)
		{
			if (!mCachedKeyLeader)
				mCachedKeyLeader = getKeyBlockForBlock(mLeader);
		}
		// Logic - END

		// Cache Level 1  - EXIT_BEGIN
		mVerifiedPathDoubleGuardian.unlock();
		mVerifiedPathGuardian.unlock();
		mHeaviestPathGuardian.unlock();
		// Cache Level 1  - EXIT_END

		// CRITICAL SECTION - END

		mHeaviestPathGuardian.lock();
		setCachedHeaviestHeight(mHeaviestChainProof.size() ? mHeaviestChainProof.size() - 1 : 0);
		mHeaviestPathGuardian.unlock();

		// Chain-Proof Cache Preparation - END
		
		// Leader Proclemation - BEGIN

		if (!mSkipLocalDataAnalysis && !mHeaviestChainProof.empty())
		{

			if (mMode == eBlockchainMode::TestNet || mMode == eBlockchainMode::LIVE)
			{
				// Heaviest Cache Initialization ( Phase 1 ) - BEGIN
				if (!mHeaviestChainProof.empty())
				{
					std::string errorInfo;
					CBlockHeader::eBlockHeaderInstantiationResult result = CBlockHeader::eBlockHeaderInstantiationResult::failure;
					auto lastBlockIndex = mHeaviestChainProof.size() - 1;

					// Instantiate header for leader
					auto leaderHeader = CBlockHeader::instantiate(mHeaviestChainProof[lastBlockIndex], result, errorInfo);
					if (leaderHeader)
					{
						setHeaviestChainProofLeader(leaderHeader);
						setHeaviestChainProofLeadBlockID(mHeaviestPath[lastBlockIndex]);

						// Instantiate key leader header
						auto keyLeaderHeader = CBlockHeader::instantiate(mHeaviestChainProof[lastBlockIndex], result, errorInfo, false, getMode());
						if (keyLeaderHeader)
						{
							setHeaviestChainProofKeyLeader(keyLeaderHeader);
						}
						else
						{
							tools->writeLine(tools->getColoredString(
								"Failed to instantiate Heaviest Chain Key Leader header: " + errorInfo,
								eColor::cyborgBlood));
						}
					}
					else
					{
						tools->writeLine(tools->getColoredString(
							"Failed to instantiate Heaviest Chain Leader header: " + errorInfo,
							eColor::cyborgBlood));
					}

					setCachedHeaviestHeight(lastBlockIndex);
				}
				else
				{
					tools->writeLine(tools->getColoredString(
						"No Heaviest Chain Proof available for cache initialization",
						eColor::lightPink));
				}
				// Heaviest Cache Initialization ( Phase 1 ) - END
			}
		}

		if (!mVerifiedPath.empty())
		{
			std::string vpLeaderID = tools->base58CheckEncode(mVerifiedPath[mVerifiedPath.size() - 1]);
			tools->writeLine("The 'verified' chain-proof leading block:" + tools->getColoredString(vpLeaderID, eColor::blue) + ". At height: " + std::to_string(mVerifiedPath.size() - 1));
		}

		// Verified Leader Proclamation - BEGIN
		if ((mLeader == nullptr || mKeyLeader == nullptr) && !mVerifiedPath.empty()) {
			std::string errStr;
			eBlockInstantiationResult::eBlockInstantiationResult bir;

			// Sub-OPERATION: Proclaim Verified Leader - BEGIN
			if (mLeader == nullptr) {
				tools->writeLine("[LEADER PROCLAMATION]: Instantiating confirmed leader...", eColor::blue);

				// Get full block from storage using last path entry
				mLeader = mSolidStorage->getBlockByHash(mVerifiedPath.back(), bir);
				if (mLeader) {
					tools->writeLine("Leader block instantiated at height: " +
						std::to_string(mLeader->getHeader()->getHeight()));
					setCachedLeader(mLeader);
					setCachedHeight(mLeader->getHeader()->getHeight());
					setCachedHeight(mLeader->getHeader()->getKeyHeight(), true);
				}
				else {
					tools->writeLine(tools->getColoredString(
						"Failed to instantiate leader block from storage",
						eColor::cyborgBlood));
				}
			}
			// Sub-OPERATION: Proclaim Verified Leader - END

			// Sub-OPERATION: Validate and find the key leader - BEGIN
			if (mKeyLeader == nullptr) {
				// First check backwards through chain proof to find last key block location
				bool keyBlockFound = false;
				int depth = 0;
				CBlockHeader::eBlockHeaderInstantiationResult hir;
				uint64_t failure_index = 0xFFFFFFFFFFFFFFFFULL;


				// Check for empty vectors before starting the loop to avoid unsigned underflow issues
				if (mVerifiedPath.empty() || mVerifiedChainProof.empty())
				{
					tools->writeLine("[INFO]: Verification path or proof is empty. Skipping instantiation loop.", eColor::orange);
				}
				else
				{
					// Loop backwards using uint64_t. The condition `i != static_cast<uint64_t>(-1)`
					// is a safe way to check for underflow from 0.
					for (uint64_t i = mVerifiedPath.size() - 1; i != static_cast<uint64_t>(-1); --i)
					{
						// Ensure vectors are consistent (optional but good practice)
						// Use static_cast<size_t> for vector indexing if size_t differs from uint64_t
						if (static_cast<size_t>(i) >= mVerifiedChainProof.size()) {
							tools->writeLine("[ERROR]: Inconsistent vector sizes before processing index " + std::to_string(i), eColor::alertError);
							failure_index = i; // Mark this inconsistency as a failure point
							break;
						}

						try
						{
							// Declare result/error vars locally for this attempt
							CBlockHeader::eBlockHeaderInstantiationResult current_hir;
							std::string current_errStr;

							tools->writeLine("[LEADER PROCLAMATION]: Instantiating confirmed leader header at index " + std::to_string(i), eColor::blue);

							// *** Call the potentially failing function ***
							// Use static_cast<size_t>(i) if vector uses size_t for indexing
							auto h = CBlockHeader::instantiate(mVerifiedChainProof[static_cast<size_t>(i)], current_hir, current_errStr, false, mMode);

							// Check 1: Did instantiate return nullptr? (Indicates internal failure/validation error)
							if (!h)
							{
								tools->writeLine("[ERROR]: Failed to instantiate block header at index " + std::to_string(i) + ". Reason: " + current_errStr, eColor::alertError);
								failure_index = i; // Record the index of the faulty header
								break;             // Stop processing further headers
							}

							// If instantiation succeeded, proceed with logic
							tools->writeLine("[INFO]: Header at index " + std::to_string(i) + " instantiated successfully.", eColor::lightGreen);

							if (h->isKeyBlock())
							{
								tools->writeLine("[INFO]: Header at index " + std::to_string(i) + " is a Key Block header. Checking storage.", eColor::cyanOnBlack);
								// Found key block *header* in chain proof, now get actual block from storage
								// Assuming 'bir' is defined appropriately for getBlockByHash result/status
								// Use static_cast<size_t>(i) if vector uses size_t for indexing
								mKeyLeader = mSolidStorage->getBlockByHash(mVerifiedPath[static_cast<size_t>(i)], bir);
								if (mKeyLeader)
								{
									keyBlockFound = true;
									// Ensure size() doesn't return 0 before subtracting
									if (mVerifiedPath.size() > 0) {
										depth = mVerifiedPath.size() - 1 - i;
									}
									else {
										depth = 0; // Avoid underflow if somehow size is 0 here
									}
									tools->writeLine("[INFO]: Key Block FOUND in storage at depth " + std::to_string(depth) + ".", eColor::alertSuccess);
									// Successful exit from the loop, do not set failure_index
									break;
								}
								else
								{
									tools->writeLine("[WARNING]: Key Block header found at index " + std::to_string(i) + ", but block not found in solid storage.", eColor::alertWarning);
									// Decide if this is a critical failure or just a warning.
									// If critical, uncomment the next two lines:
									// failure_index = i;
									// break;
								}
							}
							// else: Header is not a key block, continue the loop to check the previous header.

						}
						// Check 2: Catch specific known exceptions from instantiate or its dependencies
						catch (const Botan::BigInt::DivideByZero& ex) // Catch the specific exception
						{
							tools->writeLine("[ERROR]: Caught Botan::BigInt::DivideByZero exception while instantiating header at index " + std::to_string(i), eColor::alertError);
							// Consider logging ex.what() if available and useful.
							failure_index = i; // Record the index of the faulty header
							break;             // Stop processing further headers
						}
						// Catch other standard exceptions
						catch (const std::exception& ex)
						{
							tools->writeLine("[ERROR]: Caught std::exception while instantiating header at index " + std::to_string(i) + ". Reason: " + ex.what(), eColor::alertError);
							failure_index = i; // Record the index of the faulty header
							break;             // Stop processing further headers
						}
						// Catch any other unknown exceptions (use cautiously)
						catch (...)
						{
							tools->writeLine("[ERROR]: Caught unknown exception while instantiating header at index " + std::to_string(i), eColor::alertError);
							failure_index = i; // Record the index of the faulty header
							break;             // Stop processing further headers
						}
					} // End of loop
				} // End of check for empty vectors


				// --- Truncation Logic ---
				// Check if the loop was broken due to a failure
				if (failure_index != 0xFFFFFFFFFFFFFFFFULL)
				{
					tools->writeLine("[INFO]: Truncating verification data due to error at original index " + std::to_string(failure_index) + ".", eColor::alertWarning);

					// We need to remove elements from index 0 up to and including failure_index.
					// Convert failure_index to size_t for vector operations if necessary.
					size_t truncation_point = static_cast<size_t>(failure_index);

					if (truncation_point < mVerifiedPath.size())
					{
						// Erase from the beginning up to the element *after* the failed one
						mVerifiedPath.erase(mVerifiedPath.begin(), mVerifiedPath.begin() + truncation_point + 1);
					}
					else {
						// This case implies failure_index might be out of sync or relates to the initial size check
						tools->writeLine("[WARNING]: Failure index seems out of bounds during truncation. Clearing mVerifiedPath.", eColor::alertWarning);
						mVerifiedPath.clear();
					}

					// Truncate the second vector consistently
					if (truncation_point < mVerifiedChainProof.size())
					{
						mVerifiedChainProof.erase(mVerifiedChainProof.begin(), mVerifiedChainProof.begin() + truncation_point + 1);
					}
					else {
						// Handle potential inconsistency if sizes differed somehow
						tools->writeLine("[WARNING]: Failure index seems out of bounds during truncation. Clearing mVerifiedChainProof.", eColor::alertWarning);
						mVerifiedChainProof.clear();
					}
					tools->writeLine("[INFO]: Verification data truncated. New size: " + std::to_string(mVerifiedPath.size()), eColor::alertWarning);
				}
				// else: Loop completed successfully or found the key block without errors before the end.

				// If no key block found/available, try latest block
				if (!keyBlockFound) {
					mKeyLeader = mSolidStorage->getBlockByHash(mVerifiedPath.back(), bir);
					if (!mKeyLeader) {
						// FAILURE ACTION: Critical log and system shutdown due to unavailable key block
						tools->logEvent("[CRITICAL]: Leading Key-Block from the Verified Path not available locally.",
							eLogEntryCategory::localSystem, 100, eLogEntryType::failure, eColor::cyborgBlood);
						CGRIDNET::getInstance()->shutdown();
						return; // TERMINATE OPERATION: Missing key block
					}
					if (!mKeyLeader->getHeader()->isKeyBlock()) {
						// WARNING ACTION: Log failure to find a key block in the verified path
						tools->writeLine("[WARNING]: No Key Block found in the verified path.", eColor::lightPink);
					}
				}
			}
			mCachedKeyLeader = mKeyLeader;
			// Sub-OPERATION: Validate and find the key leader - END

			// Sub-OPERATION: Verify Leader Alignment - BEGIN
			if (mLeader) {
				bool isAligned = true;
				std::stringstream diagnostics;
				diagnostics << "Verifying leader alignment:\n";

				// Verify leader block ID matches path
				if (mLeader->getID() != mVerifiedPath.back()) {
					isAligned = false;
					diagnostics << mTools->getColoredString(" - Leader ID mismatch with verified path\n", eColor::cyborgBlood);
				}

				// Verify leader height matches chain position
				if (mLeader->getHeader()->getHeight() != (mVerifiedChainProof.size() - 1)) {
					isAligned = false;
					diagnostics << mTools->getColoredString(" - Leader height mismatch with chain proof size\n", eColor::cyborgBlood);
				}

				// Verify leader's encoded form matches chain proof
				std::vector<uint8_t> encodedLeader;

				if (!mLeader->getHeader()->getPackedData(encodedLeader) || encodedLeader != mVerifiedChainProof.back()) {
					isAligned = false;
					diagnostics << mTools->getColoredString(" - Leader encoding mismatch with chain proof\n", eColor::cyborgBlood);
				}

				if (!isAligned) {
					tools->writeLine(diagnostics.str() + "  Status: " +
						tools->getColoredString("MISALIGNED ⚠", eColor::cyborgBlood));
					mLeader = nullptr;
					setCachedLeader(nullptr);
					tools->logEvent("Leader alignment failed - resetting leader",
						eLogEntryCategory::localSystem, 100, eLogEntryType::failure, eColor::cyborgBlood);
				}
				else {
					tools->writeLine(diagnostics.str() + "  Status: " +
						tools->getColoredString("ALIGNED ✓", eColor::lightGreen));
				}
			}
			// Sub-OPERATION: Verify Leader Alignment - END
		}
		// Verified Leader Proclamation - END


		

		leaderBlockID = getLeaderID();

		if (leaderBlockID.size() == 32)
		{
			block = mSolidStorage->getBlockByHash(leaderBlockID, biResult);

			if (block != nullptr)
			{
				tools->writeLine("Retrieved body of current Leader block: " + tools->base58CheckEncode(leaderBlockID));
	
			}
			else
			{
				//the software will check for the current leader by looking at the currently heaviest known serialized chain-proof
				//the software will keep mining on the best known block available locally if its away from the best known header by at most
				// CGlobalSecSettings::getMaxAwayMiningThreshold()

				tools->writeLine("Seems like body of the current Leader is not available locally; I'll wait for it to become available;");

			}
			tools->writeLine("Current Blockchain height: " + std::to_string(block->getHeader()->getHeight()));
		}
		else
		{
			tools->writeLine(tools->getColoredString("No current leader block available.", eColor::lightPink));
		}

	
		
		// Leader Proclemation - END


		// Check Current Perspective - BEGIN

		std::shared_ptr<CBCheckpoint> checkpoint;
		std::vector<uint8_t> effectiveLeaderPerspective;//applies only if leader is 'check-pointed'.

		if (mLeader != nullptr)
		{
			//checkpoint = getCurrentCheckpoint(mLeader->getHeader());
			// ^- the issue with the current implementation is that checkpoints are activated only based on the heaviest chain proof getCurrentCheckpoint() would reutrn null.
			effectiveLeaderPerspective = getEffectivePerspective(mLeader->getID());

			if (effectiveLeaderPerspective.empty() == false)
			{
				tools->writeLine(tools->getColoredString("[ Leading Perspective ]: ", eColor::orange) + tools->getColoredString("alternative", eColor::orange) + " - " + tools->base58CheckEncode(currentPerspective));
			}
			else
			{
				tools->writeLine(tools->getColoredString("[ Leading Perspective ]: ", eColor::orange) + tools->getColoredString("native", eColor::lightGreen) + " - " + tools->base58CheckEncode(mLeader->getHeader()->getPerspective(eTrieID::state)));
				effectiveLeaderPerspective = mLeader->getHeader()->getPerspective(eTrieID::state);
			}


			//[WARNING]: if the current leader is check-pointed, we need to use the previous Final Effective Perspective instead of the Final Expected Perspective.
			currentPerspective = effectiveLeaderPerspective;
		}

		// Check Current Perspective - END

		// Set Current Perspective - BEGIN

		this->mLiveStateDB = new CTrieDB(CGlobalSecSettings::getStateDBID(), mSolidStorage, std::vector<uint8_t>(), true, true, true);

		if (currentPerspective.empty() == false)
		{
			if (this->mLiveStateDB->setPerspective(currentPerspective) == false)
			{
				//todo: introduce autonomous fix-up by traversing leaders towards the Genesis Block
				tools->writeLine(tools->getColoredString("The main Live StateDB is corrupt. I'll now quit.", eColor::cyborgBlood));
				Sleep(2000);
				exit(true);
				return;
			}
		}

		// Set Current Perspective - END

		// Populate State Trie-DB - BEGIN
		if (!mNetworkTestingMode)
		{
			if (currentPerspective.size() > 0)
			{
				tools->writeLine(tools->getColoredString("Current Effective Perspective: ", eColor::orange) + tools->base58CheckEncode(currentPerspective));
				//tools->writeLine("Testing the Live DB");
				size_t foundDomainsCount = 0;
				if (!mNetworkTestingMode)
				{
					tools->writeLine("Testing the main StateTrie DB. This might take some time..");
					//Note: the StateDomain manager of the Live perspective will be updated below with the known domains.


#if DO_MT_TRIEDB_TESTS == 1
					uint64_t runCount = 0;
					while (true)
					{
						//std::vector<CTrieNode*> vec = mLiveStateDB->getAllSubLeafNodes(eTrieSize::mediumTrie);
						runCount++;
#endif // DO_MT_TRIEDB_TESTS

						// Main Merkle Patricia Trie Integrity Test - BEGIN
						if (!mLiveStateDB->testTrie(foundDomainsCount, true, false, true, eTrieSize::mediumTrie))
						{
							tools->writeLine("The main Live StateDB is corrupt. I'll now quit.");
							exit(true);
							return;
						}

						mLiveStateDB->recalcPerspective();
						if (!tools->compareByteVectors(currentPerspective, mLiveStateDB->getPerspective()))
						{
							CTools::writeLineS("Critical Error: The State-Database of " + modeStr + "Blockchain Manager is corrupted. Aborting..");
							exit(true);
							return;

						}
						// Main Merkle Patricia Trie Integrity Test - END
#if DO_MT_TRIEDB_TESTS == 1
						mLiveStateDB->pruneTrie();
						mLiveStateDB->recalcPerspective();
						if (!tools->compareByteVectors(currentPerspective, mLiveStateDB->getPerspective()))
						{
							CTools::writeLineS("Critical Error: The State-Database of " + modeStr + "Blockchain Manager is corrupted. Aborting..");
							exit(true);
							return;
						}
						tools->writeLine("Proceding with run #" + std::to_string(runCount));
					}
#endif // DO_MT_TRIEDB_TESTS


					//the number of Live TM's known state domains is updated further
					tools->writeLine("Finished. There are " + std::to_string(foundDomainsCount) + " State Domains in total.");
					//mLiveStateDB->pruneTrie();

					tools->writeLine(std::to_string(foundDomainsCount) + " State Domains found.");
				}
			}
			else
			{
				tools->writeLine(tools->getColoredString("No current perspective available.", eColor::lightPink));
			}
		}
		// Populate State Trie-DB - END

		if (CGRIDNET::getInstance()->getIsShuttingDown())
		{
			return;
		}
		

		CSettings::setGlobalAutoConfigStepDescription("Initializing LIVE Transaction Manager for " + getTools()->blockchainmodeToString(mMode));
		this->mLiveTransactionsManager = std::make_shared<CTransactionManager>(eTransactionsManagerMode::LIVE,
			std::shared_ptr<CBlockchainManager>(this),
			mWorkManager,
			mSettings->getMinersKeyChainID(),
			false, mode, false, false, false, nullptr, false, true);
		this->mLiveTransactionsManager->initialize();//no external Thread in use. It will auto spawn new VM.
		this->mLiveTransactionsManager->setIsReady();
		mIsNumberOfStateDomainsFresh = true;

		if (CGRIDNET::getInstance()->getIsShuttingDown())
			return;
		CSettings::setGlobalAutoConfigStepDescription("Initializing VM for Transaction Manager of " + getTools()->blockchainmodeToString(mMode));
		mLiveTransactionsManager->getScriptEngine()->setOutputView(eViewState::eViewState::eventView);
		mLiveTransactionsManager->getScriptEngine()->reset();



		//Flow (ACID) Managers - BEGIN

		//Block Validation Flow Manager - BEGIN
		this->mVerificationFlowTransactionsManager = std::make_shared<CTransactionManager>(eTransactionsManagerMode::VerificationFlow, std::shared_ptr<CBlockchainManager>(this), mWorkManager, mSettings->getMinersKeyChainID(), false, mode, false);
		this->mVerificationFlowTransactionsManager->initialize();//no external Thread in use. It will auto spawn new VM.
		std::shared_ptr<SE::CScriptEngine> se = this->mVerificationFlowTransactionsManager->getScriptEngine();
		if (!se)
		{
			tools->writeLine(tools->getColoredString("Blockchain Manager did not manage to properly initialize. ", eColor::lightPink));
			return;//that might be only due to us already shutting down
		}
		mVerificationFlowTransactionsManager->getScriptEngine()->setOutputView(eViewState::eViewState::eventView);
		CSettings::setGlobalAutoConfigStepDescription("Preparing VM for Flow Transaction Manger of " + getTools()->blockchainmodeToString(mMode));
		mVerificationFlowTransactionsManager->getScriptEngine()->reset();

		//apply default identity-swap settings 

		if (CGRIDNET::getInstance()->getIsShuttingDown())
		{
			return;
		}

		mVerificationFlowTransactionsManager->setIsReady();

		//Block Validation Flow Manager - END

		//Block Formation Flow Manager - BEGIN

		this->mBlockFormationFlowManager = std::make_shared<CTransactionManager>(eTransactionsManagerMode::FormationFlow, std::shared_ptr<CBlockchainManager>(this), mWorkManager, mSettings->getMinersKeyChainID(), false, mode, formBlocks);
		this->mBlockFormationFlowManager->initialize();//no external Thread in use. It will auto spawn new VM.
		se = this->mBlockFormationFlowManager->getScriptEngine();

		if (!se)
		{
			tools->writeLine(tools->getColoredString("Blockchain Manager did not manage to properly initialize. ", eColor::lightPink));
			return;//that might be only due to us already shutting down
		}

		mBlockFormationFlowManager->getScriptEngine()->setOutputView(eViewState::eViewState::eventView);
		CSettings::setGlobalAutoConfigStepDescription("Preparing VM for Flow Transaction Manger of " + getTools()->blockchainmodeToString(mMode));
		mBlockFormationFlowManager->getScriptEngine()->reset();

		//apply default identity-swap settings
		if (formBlocks)
		{
			if (mode == eBlockchainMode::TestNet)
			{
				if (mSettings->getEnableAutomaticIDSwitching(false))//this alone would cause a question being shown to Operator.
				{
					tools->writeLine(tools->getColoredString("Automatic Identity Switching will be active.", eColor::orange));

					//the identities will be generated from the same KeyChain
					uint64_t numberOfIdentitiesToUse = mSettings->getNumberOfMiningIdentitiesToUse();

					mBlockFormationFlowManager->setCycleBackIdentiesAfterNKeysUsed(numberOfIdentitiesToUse);//up to how many identities are to be used (1 by default only the
					//key available at 0-index)

					if (numberOfIdentitiesToUse > 1)
					{
						mBlockFormationFlowManager->setNewPubKeyEveryNKeyBlocks(mSettings->getNewIdentityEveryNumberOfKeyBlocks());
					}
				}
				else
				{
					tools->writeLine(tools->getColoredString("Automatic Identity Switching will be disabled.", eColor::orange));
					// so that these questions are NOT asked once the autonomous bootstrap sequence is finalized.
					mSettings->setNumberOfMiningIdentitiesToUse(0);
					mSettings->setNewIdentityEveryNumberOfKeyBlocks(0);
				}
			}
			//on live-net do not do identity-swapping by default

		}

		if (CGRIDNET::getInstance()->getIsShuttingDown())
		{
			return;
		}
		if (mBlockFormationFlowManager)
		{
			if (formBlocks)
			{
				mBlockFormationFlowManager->updateBlocksGeneratedWithSamePubKey();
			}
			mBlockFormationFlowManager->setIsReady();
		}
		//Block Formation Flow Manager - END

		//Flow Manager for Terminals - BEGIN
		CSettings::setGlobalAutoConfigStepDescription("Initializing  VM for Terminal of " + getTools()->blockchainmodeToString(mMode));
		this->mTerminalTransactionsManager = std::make_shared<CTransactionManager>(eTransactionsManagerMode::Terminal, std::shared_ptr<CBlockchainManager>(this), mWorkManager, mSettings->getMinersKeyChainID(), false, mode, false, true, false); // doBlockFormation=false, createDetachedDB=true, doNOTlockChainGuardian=false
		this->mTerminalTransactionsManager->initialize();//no external Thread in use. It will auto spawn new VM.
		mTerminalTransactionsManager->getScriptEngine()->reset();
		mTerminalTransactionsManager->getScriptEngine()->setAllowLocalSecData(true);
		mTerminalTransactionsManager->getScriptEngine()->setTerminalMode(true);
		mTerminalTransactionsManager->getScriptEngine()->setERGLimit(CGlobalSecSettings::getSandBoxERGLimit());
		mTerminalTransactionsManager->getScriptEngine()->setOutputView(eViewState::eViewState::GridScriptConsole);
		mTerminalTransactionsManager->getScriptEngine()->enterSandbox();
		mTerminalTransactionsManager->setIsReady();
		//Flow Manager for Terminals - END

		//Flow (ACID) Managers - END
		if (mode == eBlockchainMode::LocalData)
			this->mTests = new CTests(std::shared_ptr<CBlockchainManager>(this));
		else this->mTests = nullptr;


		if (CGRIDNET::getInstance()->getIsShuttingDown())
		{
			return;
		}

		pingChainProofCSSyncTime(eChainProof::heaviest);
		pingChainProofCSSyncTime(eChainProof::verified);

		mController = std::thread(&CBlockchainManager::mControllerThreadF, this);
		if (mMode == eBlockchainMode::TestNet)
		{
			mVitalsMonitor = std::thread(&CBlockchainManager::mVitalsMonitoringThreadF, this);
		}
		//mark the networking thread as ready, terminal etc.
		CSettings::setGlobalAutoConfigStepDescription("Initializing  Network  Manager for " + getTools()->blockchainmodeToString(mMode));

		mCompiler = std::make_shared<CGridScriptCompiler>(mTools, nullptr);

		//						 -------- MAIN CACHE --------- - BEGIN
		
		// Main Cache ( Blocks & Receipts) and Initial Difficulty Adjustment - BEGIN

		if (!mNetworkTestingMode && mMode != eBlockchainMode::LIVESandBox && mMode != eBlockchainMode::TestNetSandBox && mMode != eBlockchainMode::LocalData)
		{
			// [ IMPORTANT ]: local block availability would be also verified as part of cache preparation up to the point up to which blocks are being retrieved from Cold Storage during cache formation proces.
			//				That means either blocks or receipts cache formation as notice that both require look ups of block data from Cold Storage.
			std::shared_ptr<ThreadPool> pool = std::make_shared<ThreadPool>(mTools->getCPUCoreCount() * 2, 36, mTools->getCPUCoreCount() * 2, ThreadPriority::HIGH);
			if (!prepareCacheMT(true, verifiedChainProofCumulativePoWs, true, mTools->getCPUCoreCount() * 2, pool))// && !prepareCache(true, pows)) // single threaded as a fallback algorithm
			{
				CTools::writeLineS(tools->getColoredString("Could not prepare block-cache. Performance is to be very limited..", eColor::cyborgBlood));
				//exit(0);
			}


			// Flat Cache Integrity - BEGIN
			if (!validateFlatCache())
			{
				CTools::writeLineS(tools->getColoredString("Could not prepare flat block-cache. Performance is to be limited..", eColor::cyborgBlood));
				clearFlatCache();
			}
			// Flat Cache Integrity - END
			updateMinDifficultyCoefficients();
			updateMinERGPrice();

			mMaxRecentTransactions = CGlobalSecSettings::getMaxNrOfTransactionsInCache(); // Default value, can be changed later

		}

		// Indexes Integrity Checks - BEGIN


		// [Block ID] -> [Block Height] Index Integrity - BEGIN
		// Notice: this test may be considered as an overall index integrity validation check is it validates relationships between multiple indexex.
		if (!verifyBlockIDMapIntegrity())
		{
			CTools::writeLineS(tools->getColoredString("General index integrity checks failed. Trying to rebuild height index..", eColor::cyborgBlood));
			syncBlockIDHeightMap();
			if (!verifyBlockIDMapIntegrity())
			{
				CTools::writeLineS(tools->getColoredString("Unable to fix blockchain height index...", eColor::cyborgBlood));
			}

		}
		// [Block ID]-> [Block Height] Index Integrity - END

		// Indexes Integrity Checks - END


		// Main Cache ( Blocks & Receipts) and Initial Difficulty Adjustment - END
		
		//						 -------- MAIN CACHE --------- - END
		// Notice: this needs to happen AFTER main cache population since during the former, cumulative difficulties are all set.
		// 
		
		// Ensure Total Difficulty Alignment - BEGIN
		if (mLeader) {
			uint64_t verifiedCPCumulativePoW = verifiedChainProofCumulativePoWs.back();
			uint64_t leaderHeaderDiff = mLeader->getHeader()->getTotalDiffField();
			CBlockVerificationResult valRes;
			uint64_t leaderTotalWork = mLeader->getTotalWorkDone(valRes);

			std::stringstream ss;
			ss << "Validating total difficulty alignment for leader at height "
				<< mLeader->getHeader()->getHeight() << ":\n"
				<< "  Chain Proof PoW:  " << verifiedCPCumulativePoW << "\n"
				<< "  Leader Header:    " << leaderHeaderDiff << "\n"
				<< "  Leader Work Done: " << leaderTotalWork;

			if (verifiedCPCumulativePoW == leaderHeaderDiff && verifiedCPCumulativePoW == leaderTotalWork) {
				tools->writeLine(ss.str() + "\n  Status: " +
					tools->getColoredString(u8"ALIGNED ✓", eColor::lightGreen));
			}
			else {
				tools->writeLine(ss.str() + "\n  Status: " +
					tools->getColoredString(u8"MISALIGNED ⚠", eColor::cyborgBlood));

				tools->logEvent(
					"Critical: Total difficulty misalignment detected in leader block",
					eLogEntryCategory::localSystem,
					100,
					eLogEntryType::failure,
					eColor::cyborgBlood);

				assertGN(false, "Misaligned total difficulty."); // Maintain original assertion behavior
			}
		}
		else {
			tools->writeLine("Cannot verify total difficulty alignment - No leader available");
		}
		// Ensure Total Difficulty Alignment - END

		//Verify Local Data Availability - BEGIN
		// [ IMPORTANT ]: local data availability checks are to proceed AFTER cache preparation SINCE cache preparation mechanics now also mark block availability.

		//Note: this *IS* important. External mechanics employ isBlockAvailableLocally() for instance during incoming blocks' processing.
		//verifyLocalDataAvailability() thus not only checks data availability but it also prepares REQUIRED cache data structures.
		//[Further info]: isBlockAvailableLocally() may be set to use cache only. If cache is not available, it would fall-back to direct usage of RocksDB.
		if (!mSkipLocalDataAnalysis)
		{
			if (mSettings->getDoInitialBlockAvailabilityVerification())
			{
				if (!verifyLocalDataAvailability())
				{
					tools->logEvent("I could not verify local data availability.", eLogEntryCategory::localSystem, 100, eLogEntryType::failure, eColor::cyborgBlood);
					exit(true);
				}
			}
		}
		//Verify Local Data Availability - END


		//Only once the local mechanics are ready, commence with initialization of the networking sub-system.

		updateHeaviestPathLeaders();

		// Truncate Level 1 Block Indexes - BEGIN
		// [ Rationale ]: indexes may be out of sync after self repairs.
		if (mLeader)
		{
			assertGN(truncateKeyBlockIDsFromKeyHeight(mLeader->getHeader()->getKeyHeight() + 1, eChainProof::verified));
		}
		if (mHeaviestChainProofLeaderBlock)
		{
			assertGN(truncateKeyBlockIDsFromKeyHeight(mHeaviestChainProofLeaderBlock->getKeyHeight() + 1, eChainProof::heaviest));
		}
		// Truncate Level 1 Block Indexes - END
		
		//Networking - Part 2 - BEGIN
		if (mNetworkManager && enableNetworkingSubSystem)
		{

			mNetworkManager->initialize();
			//Networking - Part 2 - END
			mNetworkManager->setIsReady();

		}
		else
		{
			mNetworkManager = nullptr;
		}

		if (mode == eBlockchainMode::LocalData)
		{
			tools->writeLine(tools->getColoredString("GridScript console available.", eColor::lightGreen), true, false, eViewState::GridScriptConsole);
			if (mode == eBlockchainMode::LocalData)
				CTools::setTerminalReady();
			//updateStatysticsToFile();
		}
	}
	catch (std::bad_alloc ex)
	{
		CTools::writeLineS("An exception due to low memory was caught during Blockchain Manager instantiation. I'll attempt a Safe Shut-Down procedure.");
		exit(0);
	}



	mSettings->markIsPastFirstRun();



}


/// <summary>
/// Do instantiations that rely on shared_from_this()
/// </summary>
/// <returns></returns>
bool CBlockchainManager::postInstantiationPreparations()
{
	//std::shared_ptr<SE::CScriptEngine> dummy = std::make_shared<SE::CScriptEngine>(nullptr, nullptr, false);

	prepareBlockTXMetaDataCache(mTools->getCPUCoreCount() * 2);

	mSettings->setLoadPreviousConfiguration();//any consecutive queries to settings will be pre-approved.
	//the question to LoadPreviousConfiguration if forced upon at startup for each instance anyway.

	if (mMode == eBlockchainMode::TestNet || mMode == eBlockchainMode::LIVE)
	{
		if (CGlobalSecSettings::getEnableChainSecAnalysis())
		{
			if (!prepareInitialBlockchainSecurityAnalysis())
			{
				mTools->logEvent("Blockchain security analysis failed", "Security", eLogEntryCategory::localSystem, 10, eLogEntryType::failure);
			}
			else
			{
				mTools->logEvent("Blockchain security analysis succeeded", "Security", eLogEntryCategory::localSystem, 10, eLogEntryType::notification);

			}

		}
		else
		{
			mTools->logEvent("Blockchain security analysis DISABLED for this build", "Security", eLogEntryCategory::localSystem, 10, eLogEntryType::warning);

		}
	}

	
	cleanCache();// once all the multi-tier meta-data caches have been prepared we can now clean.

	setIsReady(true);

	mTools->logEvent("Invoking first blockchain cache cleanup procedure..", "Cache", eLogEntryCategory::localSystem, 10, eLogEntryType::notification);

	
	pingLastTimeBlockCacheCleaned();
	if (mMode == eBlockchainMode::TestNet)
	{
		CTools::initCMDExecutor();
		std::shared_ptr<CCMDExecutor> executor = CTools::getCommandExecutor();

		if (executor)
		{

			mTools->logEvent("All systems ready.", eLogEntryCategory::localSystem, 10, eLogEntryType::notification, eColor::neonGreen);
			executor->notifyRealmReady(mMode);
			executor->changeRealm(mMode);
		}
	}

	return true;

}

void CBlockchainManager::setTestTrieAfterEachRound(bool doIt)
{
	mTestTrieAfterBlockProcessing = doIt;
}

void CBlockchainManager::lockChainGuardian()
{
	mChainGuardian.lock();
}

void CBlockchainManager::unlockChainGuardian()
{
	mChainGuardian.unlock();
}


void CBlockchainManager::waitTillBlockProcessingDone()
{
	std::lock_guard<std::recursive_mutex> lock(mBlockProcessingGuardian);
}

bool CBlockchainManager::verifyBlockIDMapIntegrity()
{
	// Local Variables - BEGIN
	bool integrityValid = true;
	size_t mapSize, flatCacheSize;
	std::shared_ptr<CTools> tools = getTools();
	std::shared_ptr<CStatusBarHub> barHub = CStatusBarHub::getInstance();
	int progress = 0;
	size_t processedEntries = 0;
	eBlockchainMode::eBlockchainMode mode = getMode();
	// Local Variables - END

	// Operational Logic - BEGIN
	tools->writeLine("Verifying BlockID to height map integrity...");

	// Step 1: Lock all relevant structures
	sync::SynchronizedLocker locker(mBlockIDMapGuardian, mBlockCacheFlatGuardian);

	// Step 2: Get sizes
	mapSize = mBlockID_BlockHeightMap.size();
	flatCacheSize = mBlockCacheFlat.size();

	// Step 3: Check if sizes match
	if (mapSize != flatCacheSize) {
		tools->logEvent("BlockID map size (" + std::to_string(mapSize) +
			") does not match flat cache size (" + std::to_string(flatCacheSize) + ")",
			eLogEntryCategory::localSystem, 10, eLogEntryType::failure);
		integrityValid = false;
	}

	// Step 4: Verify each entry
	for (const auto& entry : mBlockID_BlockHeightMap) {
		const auto& blockID = entry.first;
		uint64_t height = entry.second;

		// Check if height is within bounds of flat cache
		if (height >= flatCacheSize) {
			tools->logEvent("BlockID map contains height (" + std::to_string(height) +
				") out of bounds of flat cache (" + std::to_string(flatCacheSize) + ")",
				eLogEntryCategory::localSystem, 10, eLogEntryType::failure);
			integrityValid = false;
			continue;
		}

		// Check if block in flat cache matches the ID in the map
		auto blockInCache = mBlockCacheFlat[height].lock();
		if (!blockInCache) {
			tools->logEvent("Block in flat cache is null for height " + std::to_string(height),
				eLogEntryCategory::localSystem, 10, eLogEntryType::failure);
			integrityValid = false;
			continue;
		}

		if (blockInCache->getID() != blockID) {
			tools->logEvent("BlockID mismatch for height " + std::to_string(height),
				eLogEntryCategory::localSystem, 10, eLogEntryType::failure);
			integrityValid = false;
		}

		// Update progress
		processedEntries++;
		progress = static_cast<int>((static_cast<double>(processedEntries) / mapSize) * 100);

		// Report progress every 5%
		if (progress % 5 == 0) {
			tools->logEvent("BlockID map integrity check progress: " + std::to_string(progress) + "%",
				eLogEntryCategory::localSystem, 1, eLogEntryType::notification);
			barHub->setCustomStatusBarText(mode, getCacheBarID(), std::to_string(progress) + "% completed..");
		}
	}

	// Final progress update
	tools->logEvent("BlockID map integrity check completed",
		eLogEntryCategory::localSystem, 1, eLogEntryType::notification);
	barHub->setCustomStatusBarText(mode, getCacheBarID(), "100% completed");

	// Report final result
	std::string resultMessage = integrityValid ?
		"BlockID map integrity check passed successfully." :
		"BlockID map integrity check failed. See logs for details.";
	tools->logEvent(resultMessage, eLogEntryCategory::localSystem,
		integrityValid ? 1 : 10,
		integrityValid ? eLogEntryType::notification : eLogEntryType::failure);

	// Operational Logic - END

	return integrityValid;
}
/// <summary>
/// Verified local data availability.
/// Note; only blocks from the mHeaviestPath might be missing.
/// Blocks from mVerifiedPath MUST BE available.
/// </summary>
/// <returns></returns>
bool CBlockchainManager::verifyLocalDataAvailability(eChainProof::eChainProof chainproof)
{
	// Local Variables - BEGIN
	std::shared_ptr<CTools> tools = getTools();
	sync::SynchronizedLocker lock(mHuntedBlocksGuardian, mHeaviestPathGuardian);
	int progress = 0;
	uint64_t availability = 0;
	uint64_t availableLocally = 0;
	eBlockchainMode::eBlockchainMode mode = getMode();
	std::vector <std::vector<uint8_t>>* targetChainProof;
	targetChainProof = (chainproof == eChainProof::verified ? &mVerifiedPath : &mHeaviestPath);
	std::shared_ptr<CStatusBarHub>  barHub = CStatusBarHub::getInstance();
	bool isBasedOnCache = false;
	// Local Variables - END

	// Operational Logic - BEGIN

	//todo (in progress): make these assumptions based on the global block cache; decoded ChainProof is redundant and wastes RAM
	tools->writeLine("Verifying local data availability..");
	tools->writeLine("Checking block availability..");


	for (int i = 0; i < targetChainProof->size(); i++)
	{
		if (isBlockAvailableLocally((*targetChainProof)[i], false, isBasedOnCache))
		{
			availableLocally++;
			if (!isBasedOnCache)// do not mark as available if current assessment already based on local cache index.
			{
				markBlockLocalAvailability((*targetChainProof)[i]);
			}
		}
		else {

			//Notice: this is taking place during commitHeaviestChainProofBlocks() with additional checks.

			//if (!addBlockToHuntedList((*targetChainProof)[i]))
			//{
				//block might be already on the list etc.
				//tools->writeLine("I could not add wanted Block to the Hunted Blocks List; aborting..");
				//return false;
			//}
		}
		progress = (int)(((double)i / (double)(targetChainProof->size())) * 100);
		barHub->setCustomStatusBarText(mode, getCacheBarID(), std::to_string(progress) + "% completed..");
		//tools->flashLine(std::to_string(progress) + "% completed..");
	}
	if (targetChainProof->size())
	{
		availability = (uint64_t)(((double)availableLocally / (double)(targetChainProof->size())) * 100);
	}

	// Operational Logic - END
	tools->writeLine(tools->getColoredString(std::string(chainproof == eChainProof::verified ? "[Verified Chain-Proof]:" : "[Heaviest Chain-Proof]:"), eColor::lightCyan) + "Local data availability is " + std::to_string(availability) + " % ");
	return true;
}


std::shared_ptr<CTransactionManager> CBlockchainManager::getLiveTransactionsManager()
{
	std::lock_guard<std::mutex> lock(mFieldsGuardian);
	return mLiveTransactionsManager;
}
std::shared_ptr<CTransactionManager> CBlockchainManager::getVerificationFlowManager()
{
	std::lock_guard<std::mutex> lock(mFieldsGuardian);
	return mVerificationFlowTransactionsManager;
}


std::shared_ptr<CTransactionManager> CBlockchainManager::getFormationFlowManager()
{
	std::lock_guard<std::mutex> lock(mFieldsGuardian);
	return mBlockFormationFlowManager;
}
std::shared_ptr<CTransactionManager> CBlockchainManager::getTerminalTransactionsManager()
{
	return mTerminalTransactionsManager;
}
std::shared_ptr<CSettings> CBlockchainManager::getSettings()
{
	return mSettings;
}

bool CBlockchainManager::getSyncMachine()
{
	std::lock_guard<std::mutex> lock(mFieldsGuardian);
	return mSyncStateMachine;
}

void CBlockchainManager::pingCustomStatusBarShown()
{
	std::lock_guard<std::mutex> lock(mFieldsGuardian);
	mCustomStatusBarFlashedTimestamp = mTools->getTime();
}



// Assuming you have a mutex named mFieldsGuardian in the CBlockchainManager class for thread safety



//Hot-Storage Block Statistics - BEGIN

/**
 * @brief Increments the count of successfully appended blocks.
 *
 * This function updates the appended block count at the current index.
 * This count represents the number of blocks that were successfully added to the chain.
 */
void CBlockchainManager::incAPM() {
	std::lock_guard<std::mutex> lock(mFieldsGuardian);
	uint64_t currentTime = std::chrono::duration_cast<std::chrono::seconds>(std::chrono::system_clock::now().time_since_epoch()).count();
	mAppendedBlockTimestamps.push_back(currentTime);
}



/**
 * @brief Computes the average number of blocks appended over the last 60 seconds.
 *
 * This function calculates the average by summing up the blocks appended over
 * the last 60 indices and divides by the interval (60 seconds).
 *
 * @return The average number of blocks appended per minute.
 */
uint64_t CBlockchainManager::getAPM() {
	std::lock_guard<std::mutex> lock(mFieldsGuardian);
	uint64_t currentTime = std::chrono::duration_cast<std::chrono::seconds>(std::chrono::system_clock::now().time_since_epoch()).count();
	mAppendedBlockTimestamps.erase(
		std::remove_if(mAppendedBlockTimestamps.begin(), mAppendedBlockTimestamps.end(), [currentTime](uint64_t timestamp) {
			return (currentTime - timestamp) > 60;
			}),
		mAppendedBlockTimestamps.end()
	);

	return mAppendedBlockTimestamps.size();
}



uint64_t CBlockchainManager::getlastBlockStatsCleaned()
{
	std::lock_guard<std::mutex> lock(mFieldsGuardian);
	return mLastBPMCleaned;
}

/**
 * @brief Computes the average number of blocks processed over the last 60 seconds.
 *
 * This function calculates the average by summing up the blocks processed over
 * the last 60 indices and divides by the interval (60 seconds).
 *
 * @return The average number of blocks processed per minute.
 */
uint64_t CBlockchainManager::getBPM() {
	std::lock_guard<std::mutex> lock(mFieldsGuardian);
	uint64_t currentTime = std::chrono::duration_cast<std::chrono::seconds>(std::chrono::system_clock::now().time_since_epoch()).count();
	mProcessedBlockTimestamps.erase(
		std::remove_if(mProcessedBlockTimestamps.begin(), mProcessedBlockTimestamps.end(), [currentTime](uint64_t timestamp) {
			return (currentTime - timestamp) > 60;
			}),
		mProcessedBlockTimestamps.end()
	);

	return mProcessedBlockTimestamps.size();
}



/**
 * @brief Advances the current index and clears statistics at that index.
 *
 * This function is called every 60 seconds. It moves to the next index or
 * wraps around if at the end. The values at the current index are then reset.
 */
void CBlockchainManager::cleanBlockStats() {
	std::lock_guard<std::mutex> lock(mFieldsGuardian);
	uint64_t currentTime = std::chrono::duration_cast<std::chrono::seconds>(std::chrono::system_clock::now().time_since_epoch()).count();

	// Remove timestamps older than 60 seconds.
	mProcessedBlockTimestamps.erase(
		std::remove_if(mProcessedBlockTimestamps.begin(), mProcessedBlockTimestamps.end(), [currentTime](uint64_t timestamp) {
			return (currentTime - timestamp) > 60;
			}),
		mProcessedBlockTimestamps.end()
	);

	mAppendedBlockTimestamps.erase(
		std::remove_if(mAppendedBlockTimestamps.begin(), mAppendedBlockTimestamps.end(), [currentTime](uint64_t timestamp) {
			return (currentTime - timestamp) > 60;
			}),
		mAppendedBlockTimestamps.end()
	);
}

//Hot-Storage Block Statistics - END

void CBlockchainManager::setDoNotProcessExtrernalBlocks(bool doNotProcessExtBlocks)
{
	std::lock_guard<std::mutex> lock(mFieldsGuardian);
	mDoNotProcessExternalBlocks = doNotProcessExtBlocks;
}

bool  CBlockchainManager::getDoNotProcessExtrernalBlocks()
{
	std::lock_guard<std::mutex> lock(mFieldsGuardian);
	return mDoNotProcessExternalBlocks;
}

CBlockchainManager::CBlockchainManager(const CBlockchainManager& sibling)
{
	mSynchronizationPaused = false;
	mDoNotProcessExternalChainProofs = sibling.mDoNotProcessExternalChainProofs;
	mDoNotProcessExternalBlocks = sibling.mDoNotProcessExternalBlocks;
	mBreakpointFactory = sibling.mBreakpointFactory;
	mBlockMetaDataAvailable = sibling.mBlockMetaDataAvailable;
	mHeaviestHeight = sibling.mHeaviestHeight;
	mTXMetaDataAvailable = sibling.mTXMetaDataAvailable;
	mLocallyMinedDataBlocks = sibling.mLocallyMinedDataBlocks;
	mLocallyMinedKeyBlocks = sibling.mLocallyMinedKeyBlocks;
	mTotalLocalReward = sibling.mTotalLocalReward;
	mTXProcessedLocally = sibling.mTXProcessedLocally;
	mOperatorLeadingAHardFork = false;
	mOperatorLeadingAHardFork = sibling.mOperatorLeadingAHardFork;
	mCachedFilledInStatusBarID = sibling.mCachedFilledInStatusBarID;
	mSyncIsStuck = sibling.mSyncIsStuck;
	mLastControllerLoopRun = sibling.mLastControllerLoopRun;
	mVitalsMonitorRunning = sibling.mVitalsMonitorRunning;
	mVitalsMinitorIsToBeRunning = sibling.mVitalsMonitorRunning;
	mFarAwayCPRequestedTimestamp = sibling.mFarAwayCPRequestedTimestamp;
	mBPM = sibling.mBPM;
	mAPM = sibling.mAPM;
	mLastBPMCleaned = sibling.mLastBPMCleaned;
	mLastHeaviestChainproofSync = sibling.mLastHeaviestChainproofSync;
	mProcessingLongChainProof = sibling.mProcessingLongChainProof;
	mCustomStatusBarText = sibling.mCustomStatusBarText;
	mCustomStatusBarFlashedTimestamp = sibling.mCustomStatusBarFlashedTimestamp;
	mNetworkTestingMode = sibling.mNetworkTestingMode;
	mSkipLocalDataAnalysis = sibling.mSkipLocalDataAnalysis;
	mNetworkTestingMode = sibling.mNetworkTestingMode;
	mSyncStateMachine = sibling.mSyncStateMachine;
	mRecentlyProcessedChainProofsClearedTimestamp = sibling.mRecentlyProcessedChainProofsClearedTimestamp;
	mSynchronizationPercentage = sibling.mSynchronizationPercentage;
	mLastTimeStatsToFile = sibling.mLastTimeStatsToFile;
	mProcessingStatus = sibling.mProcessingStatus;
	mTotalPoWAvailableAtAchievableIndex = sibling.mTotalPoWAvailableAtAchievableIndex;
	mAchievablePerspectiveAtIndex = sibling.mAchievablePerspectiveAtIndex;
	mCommitedHeaviestChainProofBlocksCount = sibling.mCommitedHeaviestChainProofBlocksCount;
	mIssueHeaviestChainProofReset = sibling.mIssueHeaviestChainProofReset;
	mDefaultDerouteDelay = sibling.mDefaultDerouteDelay;


	mDiscardedKeyBlocksCount = sibling.mDiscardedKeyBlocksCount;
	mDiscardedDataBlocksCount = sibling.mDiscardedDataBlocksCount;

	mJustSavedKeyBlocksCount = sibling.mJustSavedKeyBlocksCount;
	mJustSavedDataBlocksCount = sibling.mJustSavedDataBlocksCount;
	mAssumedAsLeaderDataBlocksCount = sibling.mAssumedAsLeaderDataBlocksCount;
	mAssumedAsLeaderKeyBlocksCount = sibling.mAssumedAsLeaderKeyBlocksCount;

	mAverageKeyBlockInteval = sibling.mAverageKeyBlockInteval;
	mAverageDataBlockInteval = sibling.mAverageDataBlockInteval;

	mDataBlockFormationLimit = sibling.mDataBlockFormationLimit;
	mKeyBlockFormationLimit = sibling.mKeyBlockFormationLimit;
	mBlockQueueMaxLength = sibling.mBlockQueueMaxLength;

	mAverageDataBlockInteval = sibling.mAverageDataBlockInteval;
	mAverageKeyBlockInteval = sibling.mAverageKeyBlockInteval;
	mIsValidPointer = sibling.mIsValidPointer;
	mMode = sibling.mMode;
	mForksCount = sibling.mForksCount;
	previousIterationBlockchainHeight = sibling.previousIterationBlockchainHeight;
	previousIterationHSCachelength = sibling.previousIterationHSCachelength;
	mHotStorageBlockCacheSize = sibling.mHotStorageBlockCacheSize;
	mHeaviestChainProofTotalDifficulty = sibling.mHeaviestChainProofTotalDifficulty;
	mVerifiedChainProofTotalDifficulty = sibling.mVerifiedChainProofTotalDifficulty;
	mIsSynced = sibling.mIsSynced;
	mIsNumberOfStateDomainsFresh = sibling.mIsNumberOfStateDomainsFresh;
	mMaxNrOfFullBlocksToKeepInMemory = sibling.mMaxNrOfFullBlocksToKeepInMemory;
	mMaxNrOfPrunedBlocksToKeepInMemory = sibling.mMaxNrOfPrunedBlocksToKeepInMemory;
	mStatus = sibling.mStatus;
	mMinDifficulty = sibling.mMinDifficulty;
	mCryptoFactory = sibling.mCryptoFactory;
	mSolidStorage = sibling.mSolidStorage;
	mLiveTransactionsManager = sibling.mLiveTransactionsManager;
	mWorkManager = sibling.mWorkManager;
	mTests = sibling.mTests;
	mSettings = sibling.mSettings;
	mVerifiedPath = sibling.mVerifiedPath;
	mLiveStateDB = sibling.mLiveStateDB;
	mIsTestNet = sibling.mIsTestNet;
	mLeader = sibling.mLeader;
	mLastTimeValidBlockProcessed = sibling.mLastTimeValidBlockProcessed;
	blocksForProcessing = sibling.blocksForProcessing;
}


std::shared_ptr<CCryptoFactory>  CBlockchainManager::getCryptoFactory()
{
	//std::lock_guard<std::recursive_mutex> lock(mGuardian);
	assertGN(mCryptoFactory != nullptr);
	return mCryptoFactory;
}




void CBlockchainManager::exit(bool waitForConfirmation)
{
	std::lock_guard<std::recursive_mutex> lock(mGuardian);
	//stop my own operations first
	try {
		missionAbort();
		stop();

		if (waitForConfirmation)
			getTools()->askYesNo("Everything shut down; I'm about to quit; say Bye:)", true);


		//if (mTools != NULL)
		//	mTools.reset();
		//delete mNetworkManager;
		//delete this;

	}
	catch (...)
	{

	}

}


void CBlockchainManager::setMaxReceiptsCacheSize(size_t size) {
	if (size == 0) {
		throw std::invalid_argument("Max cache size cannot be 0");
	}
	mMaxReceiptsCacheSize.store(size, std::memory_order_relaxed);

	// Trigger cache cleanup if necessary
	receiptsHotCacheCleanup(true);
}

size_t CBlockchainManager::getMaxReceiptsCacheSize() {

	return mMaxReceiptsCacheSize.load(std::memory_order_relaxed);
}

size_t CBlockchainManager::getMaxBlockchainCacheSize() {

	return mMaxBlockchainCacheSize.load(std::memory_order_relaxed);
}

size_t CBlockchainManager::getReceiptsCacheSize() const noexcept {
	return mReceiptsCacheSize.load(std::memory_order_relaxed);
}

std::shared_ptr<CReceipt> CBlockchainManager::getReceiptFromHotCache(const std::vector<uint8_t>& id) const {
	std::shared_lock<std::shared_mutex> lock(mReceiptsCacheMutex);
	auto it = mReceiptsCache.find(id);
	if (it != mReceiptsCache.end()) {
		it->second.lastAccessed = std::chrono::steady_clock::now();
		return it->second.receipt;
	}
	return nullptr;
}

void CBlockchainManager::addReceiptToHotCache(const std::shared_ptr<CReceipt>& receipt) {
	if (!receipt) {
		throw std::invalid_argument("Cannot add null receipt to cache");
	}

	// Pre-Flight - BEGIN

	// Sanitize Trie Node copy - BEGIN
	// Rationale: we need to make sure trie-node does not 'think' it's part of a Trie (all its internal pointers need to be clear);
	receipt->unregister(); // otherwise sanitize() would throw.
	receipt->sanitize();
	// Sanitize Trie Node copy - END

	// Pre-Flight - END

	std::unique_lock<std::shared_mutex> lock(mReceiptsCacheMutex);
	std::vector<uint8_t> id = receipt->getGUID();
	// If the receipt already exists, update it
	auto it = mReceiptsCache.find(id);
	if (it != mReceiptsCache.end()) {
		mReceiptsCacheSize.fetch_sub(it->second.size, std::memory_order_relaxed);
		it->second.receipt = receipt;
		it->second.size = estimateReceiptSize(*receipt);
		it->second.lastAccessed = std::chrono::steady_clock::now();
		mReceiptsCacheSize.fetch_add(it->second.size, std::memory_order_relaxed);
		return;
	}

	// Make room for the new receipt if necessary
	size_t newSize = estimateReceiptSize(*receipt);
	while (mReceiptsCacheSize.load(std::memory_order_relaxed) + newSize > mMaxReceiptsCacheSize.load(std::memory_order_relaxed)) {
		if (mReceiptsCache.empty()) {
			// Edge case: new receipt is larger than max cache size
			return;
		}
		removeOldestReceipt();
	}

	// Add the new receipt
	mReceiptsCache[id] = { receipt, newSize, std::chrono::steady_clock::now() };
	mReceiptsCacheOrder.push_back(id);
	mReceiptsCacheSize.fetch_add(newSize, std::memory_order_relaxed);

	// Perform cleanup if it's been a while since the last one
	if (std::chrono::steady_clock::now() - mLastCacheCleanup > std::chrono::hours(1)) {
		receiptsHotCacheCleanupK();
	}
}



void CBlockchainManager::removeOldestReceipt() {
	if (mReceiptsCacheOrder.empty()) return;

	auto oldestId = mReceiptsCacheOrder.front();
	mReceiptsCacheOrder.pop_front();
	auto it = mReceiptsCache.find(oldestId);
	if (it != mReceiptsCache.end()) {
		mReceiptsCacheSize.fetch_sub(it->second.size, std::memory_order_relaxed);
		mReceiptsCache.erase(it);
	}
}

size_t CBlockchainManager::estimateReceiptSize(const CReceipt& receipt) const noexcept {
	// Implement a more accurate size estimation if possible
	return sizeof(CReceipt);// +receipt.getSerializedSize();
}

void CBlockchainManager::forceClearReceiptsCache() noexcept {
	std::unique_lock<std::shared_mutex> lock(mReceiptsCacheMutex);

	// Clear all cache entries
	mReceiptsCache.clear();
	mReceiptsCacheOrder.clear();

	// Reset cache size
	mReceiptsCacheSize.store(0, std::memory_order_relaxed);

	// Update last cleanup time
	mLastCacheCleanup = std::chrono::steady_clock::now();
}
size_t CBlockchainManager::receiptsHotCacheCleanupK(bool force)
{
	//return 0;//todo: improve performance

	auto now = std::chrono::steady_clock::now();
	if (!force && (now - mLastCacheCleanup < std::chrono::hours(1))) {
		return 0; // Skip cleanup if it's been less than an hour since the last one
	}

	size_t removedCount = 0;
	auto it = mReceiptsCache.begin();
	while (it != mReceiptsCache.end()) {
		if (now - it->second.lastAccessed > std::chrono::hours(1)) {
			mReceiptsCacheSize.fetch_sub(it->second.size, std::memory_order_relaxed);
			auto orderIt = std::find(mReceiptsCacheOrder.begin(), mReceiptsCacheOrder.end(), it->first);
			if (orderIt != mReceiptsCacheOrder.end()) {
				mReceiptsCacheOrder.erase(orderIt);
			}
			it = mReceiptsCache.erase(it);
			++removedCount;
		}
		else {
			++it;
		}
	}

	mLastCacheCleanup = now;
	return removedCount;
}

size_t CBlockchainManager::receiptsHotCacheCleanup(bool force) {
	std::unique_lock<std::shared_mutex> lock(mReceiptsCacheMutex);
	return receiptsHotCacheCleanupK();
}

std::shared_ptr<CBreakpointFactory> CBlockchainManager::getBreakpointFactory()
{
	std::shared_lock lock(mSharedFieldsGuardian);
	return mBreakpointFactory;
}

CBlockchainManager::~CBlockchainManager()
{

	//setIsReady(false);
	try {
		receiptsHotCacheCleanup(true);
		if (mIsTestNet)
			getTools()->writeLine("Shutting down TEST-NET blockchain manager!");
		else
			getTools()->writeLine("Shutting down LIVE-NET blockchain manager!");

		if (mTerminalTransactionsManager != nullptr)
		{
			mTerminalTransactionsManager = nullptr;
		}

		if (mVerificationFlowTransactionsManager != nullptr)
		{
			mVerificationFlowTransactionsManager = nullptr;
		}
		if (mVerificationFlowTransactionsManager != nullptr)
		{
			mVerificationFlowTransactionsManager = nullptr;
		}
		if (mLiveTransactionsManager != nullptr)
		{
			mLiveTransactionsManager = nullptr;
		}

		if (mWorkManager != nullptr)
		{
			mWorkManager = nullptr;
		}
		if (mSettings != nullptr)
			mSettings = nullptr;

		if (mLiveStateDB != nullptr)
		{
			delete mLiveStateDB;
			mLiveStateDB = nullptr;
		}
		if (mLeader != nullptr)
		{
			mLeader = nullptr;
		}
		if (mNetworkManager != nullptr)
		{
			mNetworkManager = nullptr;
			mLeader = nullptr;
		}
		if (mIsTestNet && sTestNetInstance != nullptr)
		{
			sTestNetInstance = nullptr;
		}
		if (!mIsTestNet && sLiveInstance != nullptr)
			sLiveInstance = nullptr;
	}
	catch (std::bad_alloc ex)
	{
		//this is to 
	}
	//TODO clear memory stop threads
}

CSolidStorage* CBlockchainManager::getSolidStorage()
{
	std::lock_guard<std::mutex> lock(mFieldsGuardian);
	assertGN(mSolidStorage != nullptr);
	return mSolidStorage;
}

/*SE::CScriptEngine * CBlockchainManager::getScriptEngine()
{
	std::lock_guard<std::recursive_mutex> lock(mGuardian);
 assertGN(mScriptEngine != nullptr);
	return mScriptEngine;
}*/

CTrieDB* CBlockchainManager::getStateTrieP()
{
	std::lock_guard<std::recursive_mutex> lock(mLiveStateDBGuardian);
	assertGN(mLiveStateDB != nullptr);
	return mLiveStateDB;
}

CTrieDB CBlockchainManager::getStateTrie()
{
	std::lock_guard<std::recursive_mutex> lock(mLiveStateDBGuardian);
	return *mLiveStateDB;
}

/// <summary>
/// Returns the space in bytes occupied by the selected chainProof.
/// </summary>
/// <param name="whichOne"></param>
/// <returns></returns>
uint64_t CBlockchainManager::getChainProofSizeInBytes(eChainProof::eChainProof whichOne)
{
	uint64_t toRet = 0;
	if (whichOne == eChainProof::heaviest)
	{
		std::lock_guard<ExclusiveWorkerMutex> lock(mHeaviestPathGuardian);
		for (int i = 0; i < mHeaviestChainProof.size(); i++)
		{
			toRet += mHeaviestChainProof[i].size();
		}
	}
	else if (whichOne == eChainProof::verified)
	{
		std::lock_guard<ExclusiveWorkerMutex> lock(mVerifiedPathGuardian);
		for (int i = 0; i < mVerifiedChainProof.size(); i++)
		{
			toRet += mVerifiedChainProof[i].size();
		}
	}
	else
		return 0;

	return toRet;
}

uint64_t CBlockchainManager::getPathCacheSizeInBytes(eChainProof::eChainProof whichOne)
{
	uint64_t toRet = 0;
	if (whichOne == eChainProof::heaviest)
	{
		std::lock_guard<ExclusiveWorkerMutex> lock(mHeaviestPathGuardian);
		toRet = mHeaviestPath.size() * 8;

	}
	else if (whichOne == eChainProof::verified)
	{
		std::lock_guard<ExclusiveWorkerMutex> lock(mVerifiedPathGuardian);
		for (int i = 0; i < mVerifiedChainProof.size(); i++)
		{
			toRet = mVerifiedPath.size() * 8;
		}
	}
	else
		return 0;

	return toRet;

}


std::shared_ptr<CStateDomainManager> CBlockchainManager::getStateDomainManager(bool persistentSDM)
{
	//std::lock_guard<std::recursive_mutex> lock(mGuardian);
	if (mLiveTransactionsManager != nullptr)
	{
		std::shared_ptr<CStateDomainManager> sdm = persistentSDM ?
			// persistent SDM -------------v
			mLiveTransactionsManager->getPersistentStateDomainManager() :
			// otherwise the regular one --v
			mLiveTransactionsManager->getStateDomainManager();

		return sdm;
	}
	else
		return nullptr;
}


CBlockchainManager::eBlockProcessingResult CBlockchainManager::processBlock(std::vector<uint8_t> BERBlock)
{


	try {
		if (BERBlock.size() > CGlobalSecSettings::getMaxDataBlockSize())
			return CBlockchainManager::eBlockProcessingResult::error;

		eBlockInstantiationResult::eBlockInstantiationResult iResult;
		std::string errorInfo;
		std::shared_ptr<CBlock> block = CBlock::instantiateBlock(true, BERBlock, iResult, errorInfo, mMode);

		if (iResult == eBlockInstantiationResult::Failure)
		{
			getTools()->writeLine("Error instantiating Block");
			return CBlockchainManager::eBlockProcessingResult::error;
		}
		std::vector<std::string> log;
		CBlockchainManager::eBlockProcessingResult res = processBlock(block, log);

		addBlockToProcessedBlocks(block->getID());

		updateStatysticsToFile();
		if (block != nullptr && res != appended)
		{
			//incDiscardedBlocksCount();
			//remove dependancies to allow for memory to be released
			block->getHeader()->setBlock(nullptr);
		}


		return res;
	}
	catch (...)
	{
		return CBlockchainManager::eBlockProcessingResult::error;
	}

}

/// <summary>
/// Returns the number of consecutive key-blocks leader needs to wait before his / hers reward is 
/// made spendable.
/// </summary>
/// <param name="block"></param>
/// <returns></returns>
uint64_t CBlockchainManager::getMinersRewardLockPeriod(std::shared_ptr<CBlock> block)
{
	return CGlobalSecSettings::getMinersLockPeriod();//todo: make this based on governance
}

void CBlockchainManager::incBPM() {
	std::lock_guard<std::mutex> lock(mFieldsGuardian);
	uint64_t currentTime = std::chrono::duration_cast<std::chrono::seconds>(std::chrono::system_clock::now().time_since_epoch()).count();
	mProcessedBlockTimestamps.push_back(currentTime);
}


/// <summary>
/// Does block-processing. 
/// Block can either be assumed as leader, just-stored or rejected.
/// </summary>
/// <param name="block"></param>
/// <returns></returns>
CBlockchainManager::eBlockProcessingResult CBlockchainManager::processBlock(std::shared_ptr<CBlock> block, std::vector<std::string> &log)
{
#if ENABLE_FLOW_DETAILED_LOGS == 1
	// RAII Logging - BEGIN
	std::stringstream debugLog;
	// Create RAII logger. It writes out debugLog at every return (normal or early).
	CEndFlowRAII endFlowLogger(debugLog, getTools());
#endif
	// Pre-Flight - BEGIN
	std::string newLine = "\n";
	//Operational Logic - BEGIN
	std::shared_ptr <CTools> tools = getTools();
	if (block == nullptr) {
		log.push_back("ERROR: Received null block pointer");
		return error;
	}
	uint64_t currentHeight = getCachedHeight();

	uint64_t candidateHeight = block->getHeader()->getHeight();

	// ACID Block Processing Pre-Flight Checks - BEGIN
	if (currentHeight!=0 && block->getScheduledByLocalScheduler() 
		&& (candidateHeight > currentHeight && // IF block is into the future 
		candidateHeight != (currentHeight + 1)) // THEN, it needs to be a direct offspring of current leader; [ IMPORTANT ]: blocks MAY be at lower heights (forks).
		)
	{
		block->setScheduledByLocalScheduler(false);
		block->setDoTurboFlow(false);
		// all in all this should not happen
		tools->writeLine(" " + tools->getColoredString("A misplaced block for ACID processing for height "
			+ std::to_string(block->getHeader()->getHeight()), eColor::lightPink));
		return eBlockProcessingResult::error;
	}
	// ACID Block Processing Pre-Flight Checks - END
	
	// Pre-Flight - END

	// Retrieve Data - BEGIN
	if (block->getScheduledByLocalScheduler())// needed only during Flow
	{
		std::shared_ptr<CBlockHeader> header = block->getHeader();
		if (header->getPubKey().empty() && header->isKeyBlock() == false)
		{
			// Rationale: public key is not serialized as part of Data Block (storage efficiency).
			//			  We need to retrieve it based on the corresponding parental Key-Block.
			// Warning:   Presence of a public key even for data blocks is essential for proper processing.
			std::shared_ptr<CBlock> keyBlock = getKeyBlockForBlock(block);
			if (keyBlock)
			{
				header->setPubKey(keyBlock->getHeader()->getPubKey());
			}
		}

		if (header->getPubKey().empty()) {
			log.push_back("ERROR: Empty public key for non-key block after key block retrieval attempt");
			//block->setScheduledByLocalScheduler(false);
			return eBlockProcessingResult::error;
		}

		if (block->validate() == false || header->validate() == false)
		{
			//block->setScheduledByLocalScheduler(false);
			return eBlockProcessingResult::discarded;
		}
	}
	// Retrieve Data - END

	// Breakpoints' Support - BEGIN
	std::shared_ptr<CBreakpointFactory> bf = getBreakpointFactory();
	if (bf && bf->getHasBreakpoints()) {
		std::stringstream ss;
		bool breakpointHit = false;
		std::shared_ptr<CBlockHeader> header = block->getHeader();
		std::vector<std::shared_ptr<CBreakpoint>> allHitBreakpoints;

		// Check height breakpoints
		auto heightBreakpoints = bf->getBreakpointsAtHeight(header->getHeight());
		if (!heightBreakpoints.empty()) {
			breakpointHit = true;
			ss << newLine << mTools->getColoredString("[ Block Height Breakpoint Hit ]", eColor::orange) << newLine;
			ss << mTools->getColoredString("Block Height: ", eColor::lightCyan) << header->getHeight() << newLine;
			allHitBreakpoints.insert(allHitBreakpoints.end(), heightBreakpoints.begin(), heightBreakpoints.end());
		}

		// Check key height breakpoints
		auto keyHeightBreakpoints = bf->getBreakpointsAtKeyHeight(header->getKeyHeight());
		if (!keyHeightBreakpoints.empty()) {
			breakpointHit = true;
			ss << newLine << mTools->getColoredString("[ Key Block Height Breakpoint Hit ]", eColor::orange) << newLine;
			ss << mTools->getColoredString("Key Block Height: ", eColor::lightCyan) << header->getKeyHeight() << newLine;
			allHitBreakpoints.insert(allHitBreakpoints.end(), keyHeightBreakpoints.begin(), keyHeightBreakpoints.end());
		}

		// Check block ID breakpoints
		auto blockIDBreakpoints = bf->getBreakpointsForBlock(header->getHash());
		if (!blockIDBreakpoints.empty()) {
			breakpointHit = true;
			ss << newLine << mTools->getColoredString("[ Block ID Breakpoint Hit ]", eColor::orange) << newLine;
			ss << mTools->getColoredString("Block ID: ", eColor::lightCyan) << mTools->base58CheckEncode(header->getHash()) << newLine;
			allHitBreakpoints.insert(allHitBreakpoints.end(), blockIDBreakpoints.begin(), blockIDBreakpoints.end());
		}

		if (breakpointHit) {
			// Add common block information
			ss << newLine << mTools->getColoredString("[ Block Information ]", eColor::blue) << newLine;
			ss << mTools->getColoredString("Block Type: ", eColor::lightCyan)
				<< (header->isKeyBlock() ? "Key Block" : "Data Block") << newLine;
			ss << mTools->getColoredString("Miner ID: ", eColor::lightCyan)
				<< mTools->bytesToString(header->getMinersID()) << newLine;
			ss << mTools->getColoredString("Timestamp: ", eColor::lightCyan)
				<< mTools->timeToString(header->getSolvedAtTime()) << newLine;
			ss << mTools->getColoredString("Parent Block: ", eColor::lightCyan)
				<< mTools->base58CheckEncode(header->getParentID()) << newLine;
			ss << mTools->getColoredString("Transactions: ", eColor::lightCyan)
				<< header->getNrOfTransactions() << newLine;

			// Add breakpoint statistics
			ss << newLine << mTools->getColoredString("[ Breakpoint Details ]", eColor::blue) << newLine;

			// Number breakpoints for reference
			for (size_t i = 0; i < allHitBreakpoints.size(); ++i) {
				const auto& bp = allHitBreakpoints[i];
				bp->hit(); // Increment hit count for each breakpoint

				ss << mTools->getColoredString("[Breakpoint " + std::to_string(i + 1) + "]", eColor::orange) << newLine;
				ss << mTools->getColoredString("Type: ", eColor::lightCyan)
					<< (bp->getType() == eBreakpointType::block ? "Block" : "Unknown") << newLine;
				ss << mTools->getColoredString("Hit Count: ", eColor::lightCyan)
					<< bp->getHitCount() << newLine;
				ss << mTools->getColoredString("Condition: ", eColor::lightCyan);
				switch (bp->getCondition()) {
				case eBreakpointCondition::height:
					ss << "Block Height (" << bp->getValueString() << ")";
					break;
				case eBreakpointCondition::keyHeight:
					ss << "Key Block Height (" << bp->getValueString() << ")";
					break;
				case eBreakpointCondition::blockID:
					ss << "Block ID (" << bp->getValueString() << ")";
					break;
				default:
					ss << "Unknown";
				}
				ss << newLine << "---" << newLine;
			}

			// Add command help
			ss << newLine << mTools->getColoredString("Commands:", eColor::blue) << newLine;
			ss << mTools->getColoredString("continue", eColor::lightCyan) << " - Continue execution" << newLine;
			ss << mTools->getColoredString("skip N", eColor::lightCyan) << " - Disable breakpoint N (e.g., 'skip 1')" << newLine;
			ss << mTools->getColoredString("skip all", eColor::lightCyan) << " - Disable all hit breakpoints" << newLine;
			ss << "                Hit " << mTools->getColoredString("Enter", eColor::lightCyan) << " to Continue" << newLine;

			mTools->logEvent(ss.str(), "Breakpoint", eLogEntryCategory::localSystem, 5, eLogEntryType::notification);

			bool continueExecution = false;
			while (!continueExecution) {
				std::string response = mTools->askString(ss.str(), "continue", "Debugger", true, true, 0);
				response = mTools->trim(response);

				if (mTools->iequals(response, "continue")) {
					continueExecution = true;
				}
				else if (mTools->iequals(response, "skip all")) {
					for (const auto& bp : allHitBreakpoints) {
						bp->deactivate();
						mTools->logEvent("Deactivated breakpoint of type " + std::to_string(static_cast<int>(bp->getCondition())),
							"Breakpoint", eLogEntryCategory::localSystem, 5, eLogEntryType::notification);
					}
					continueExecution = true;
				}
				else if (response.substr(0, 5) == "skip ") {
					std::string numStr = response.substr(5);
					uint64_t num;
					if (mTools->stringToUint(numStr, num) && num >= 1 && num <= allHitBreakpoints.size()) {
						allHitBreakpoints[num - 1]->deactivate();
						mTools->logEvent("Deactivated breakpoint " + std::to_string(num),
							"Breakpoint", eLogEntryCategory::localSystem, 5, eLogEntryType::notification);

						ss.str(""); // Clear stringstream
						ss << mTools->getColoredString("Breakpoint " + std::to_string(num) + " disabled. Continue execution? (yes/no)",
							eColor::lightCyan) << newLine;

						if (mTools->askYesNo(ss.str(), true, "Debugger", true, true)) {
							continueExecution = true;
						}
					}
					else {
						ss.str(""); // Clear stringstream
						ss << mTools->getColoredString("Invalid breakpoint number. Use 1 to " +
							std::to_string(allHitBreakpoints.size()), eColor::lightPink) << newLine;
					}
				}
			}
		}
	}
	// Breakpoints' Support - END


	// 
	////if (block->getScheduledByLocalScheduler())
	//{

	//	removeBlockFromUnorderedCache(block->getID());
	//}
	/*std::shared_ptr<CBlock> cachedLeader = getCachedLeader();
	Note: Do not do such check since that would prevent processing of forks. Current leader might as well be at much higher height than the
	height at which we might be attempting to fork (lower height).
	if (cachedLeader && block->getHeader()->getHeight() != (cachedLeader->getHeader()->getHeight() + 1) && block->getScheduledByLocalScheduler())
	{
		tools->writeLine(tools->getColoredString("Omitting locally scheduled block since parent wasn't processed successfully..", eColor::orange));
		block->setScheduledByLocalScheduler(false);
		return CBlockchainManager::eBlockProcessingResult::discarded;
	}
	*/
	//****IMPORTANT **** block->setScheduledByLocalScheduler(false);
	//Unmark setScheduledByLocalScheduler only AFTER the block has been processed. 
	//Flow Logic relies upon this flag (optimization so that we do not need to check whether block is in the Heaviest Chain-Proof).

	incBPM();
	if (isBlacklisted(block->getID()))
	{
		return eBlockProcessingResult::discarded;
	}

	BigInt effectiveTotalReward = 0;
	BigInt effectivePaidReward = 0;
	//Local Variables - BEGIN

	uint64_t now = std::time(0);
	size_t heaviestChainProofSize = 0;
	std::lock_guard<std::recursive_mutex> locka(mBlockProcessingGuardian);
	//Local Variables - END
	std::shared_ptr<CTransactionManager> verficiationFlowManager = getVerificationFlowManager();
	//if ((now - mLastHeaviestChainproofSync) > 120)// <- WRONG. The verified path can NEVER be behind the Verified Path.
	//{
	//if (getJustAppendedLeader())
	//{
	setJustAppendedLeader(false);//so to update the heaviest path only after a block was appended to the verified chain-proof.


	heaviestChainProofSize = mHeaviestChainProof.size();


	//support  node is current leader - BEGIN
	if ((getVerifiedChainProofTotalDifficulty() > getHeaviestChainProofTotalDifficulty())// getHeaviestChainProofTotalDifficulty() //We this right here instead of after the block was added to avoid 
		//locking the mutex for overly too long. and we cannot later due to possibility of a deadlock.
		|| (mVerifiedChainProof.size() > heaviestChainProofSize))//no mutex needed?
	{
		mHeaviestPathGuardian.lock();
		mLastHeaviestChainproofSync = now;
		uint64_t winnningPoW = 0;
		eChainProofValidationResult::eChainProofValidationResult cpValRes = eChainProofValidationResult::invalidGeneral;
		eChainProofUpdateResult::eChainProofUpdateResult overRes = analyzeAndUpdateChainProof(mVerifiedChainProof,cpValRes, mHeaviestChainProof, winnningPoW, 0,
			std::vector<uint8_t>(), 999, false);// do not explicity affect cold storage here (optimization)

		switch (overRes)
		{
		case eChainProofUpdateResult::updated:
			tools->writeLine(tools->getColoredString("Updated the heaviest chain-proof based on the local verified chain-proof.", eColor::lightGreen));
			break;
		case eChainProofUpdateResult::updatedLocalBestKnown:
			tools->writeLine(tools->getColoredString("Updated the heaviest chain-proof based on the local verified chain-proof.", eColor::lightGreen));
			break;
		case eChainProofUpdateResult::totalDiffLower:
			tools->writeLine(tools->getColoredString("Local verified chain-proof won't be winning over the heaviest chain-proof.", eColor::orange));
			break;
		case eChainProofUpdateResult::noCommonPointFound:
			break;
		case eChainProofUpdateResult::invalidData:
			tools->writeLine(tools->getColoredString("Invalid data when attempting to update heaviest chain-proof based on the verified chain.", eColor::cyborgBlood));
			break;
		case eChainProofUpdateResult::Error:
			tools->writeLine(tools->getColoredString("General error when attempting to update heaviest chain-proof based on the verified chain.", eColor::cyborgBlood));
			break;
		default:
			break;
		}
		mHeaviestPathGuardian.unlock();
	}

	//}
	//}
	//support node is current leader - END


	setBlockProcessingStatus(eBlockProcessingStatus::eBlockProcessingStatus::processing);
	std::vector<uint8_t> blockID = block->getID();
	tools->writeLine("Processing block (ID: " + tools->base58CheckEncode(blockID) + " ) for height " + std::to_string(block->getHeader()->getHeight())
		+ " from: " + (block->getScheduledByLocalScheduler() ? "scheduler" : "network"));

#if ENABLE_FLOW_DETAILED_LOGS == 1

	debugLog << "Flow Results for block " << tools->base58CheckEncode(blockID) << ":" << newLine << newLine;

#endif

	//LOCAL VARIABLES - BEGIN
	CTransactionManager::eDBTransactionFlowResult  flowResult = CTransactionManager::eDBTransactionFlowResult::failure;
	assertGN(mLiveTransactionsManager != nullptr);
	std::string errorMsg;
	std::vector<CReceipt> receipts;
	size_t ERGUsed = 0;
	std::vector<uint8_t> finalPerspective;
	uint64_t blockUseRef = block.use_count();
	size_t height = 0;
	bool bAppended = false;
	bool bSaved = false;


	eBlockInstantiationResult::eBlockInstantiationResult bir;
	std::vector<uint8_t> startingPointPerspective;
	std::shared_ptr<CBlock> parent;
	CTransaction trans;
	CVerifiable ver;
	CBlockVerificationResult bvr;
	//LOCAL VARIABLES - END


	//RAM DB PRUNING - BEGIN
	mLiveStateDBGuardian.lock();// the order needs to be such in ALL cases. First lock the most general section, then the more specialized.
	mLiveStateDB->mGuardian.lock();
	mLiveStateDB->pruneTrie();
	mLiveStateDB->mGuardian.unlock();
	mLiveStateDBGuardian.unlock();
	//RAM DB PRUNING - END

	//BLOCK VALIDATION - BEGIN
	bool hardForkProcedureActive = getIsOperatorLeadingAHardFork();

	if (!(block->getIsCheckpointed() && block->getScheduledByLocalScheduler()))
	{
		if ((hardForkProcedureActive && block->getIsLeadingAHardFork()) || (!hardForkProcedureActive))
		{
			bvr = validateBlock(block);
		}
		else
		{
			bvr.setStatus(eBlockVerificationResult::notAForkLeadingBlock);
			bvr.setStore(false); // Notice: nowadays we rarely need to abort storage since the heaviest chain-proof dictates what makes its way into Cold Storage.
			//         With the current version of the protocol Heviest Chain Proof dictates what gets downloaded but local processing MIGHT reject processing.
			//		  If processing is rejected, local node would begin generating an alternative history of events - on its own.
			bvr.setAsLeader(false);
		}
	}
	else
	{
		if ((block->getScheduledByLocalScheduler() && block->getHeader()->getHeight() == getCachedHeight() + 1)
			||
			(block->isGenesis() && getCachedHeight()==0))
	
		{

			block->setDoTurboFlow(true);
			bvr.setStatus(eBlockVerificationResult::valid);
			bvr.setAsLeader(true);
		}

	}

	//BLOCK VALIDATION - END
	bool wasScheduledByLocalScheduler = block->getScheduledByLocalScheduler();
	block->setScheduledByLocalScheduler(false);

	//BLOCK IS A NEW LEADING BLOCK - BEGIN
	if (bvr.getStatus() == valid && bvr.isLeader()) {

		tools->writeLine("Block is the new Leader. " + tools->getColoredString("Commencing with Persistent Commitment.", eColor::orange));

		//Hot-Storage Stats - BEGIN
		std::shared_ptr<CTransactionManager> flowTM = getVerificationFlowManager();

		//Hot-Storage Stats - END

		//these mutexes need to be locked already;
		//there's many data set; including links etc that need to be synchronized *AT ONCE*
		parent = block->getHeader()->getParent(bir, true, true, false, shared_from_this());

		std::shared_ptr<CBCheckpoint> parentCheckpoint;
		std::shared_ptr<CBCheckpoint> checkpoint = getCurrentCheckpoint(block->getHeader());
		if (block->isGenesis() == false && parent != nullptr)
		{
			//Checkpoints and Alternative Perspectives - BEGIN
			parentCheckpoint = getCurrentCheckpoint(parent->getHeader());//check for an active checkpoint.
			std::vector<uint8_t> alternativePerspective;//this would override the Expected Perspective.

			if (parentCheckpoint)
			{
				cpFlags cf = parentCheckpoint->getFlags();
				//check for a cached Final Effective Perspective for the parent block.

				alternativePerspective = getEffectivePerspective(parent->getID());//check for a cached alternative Perspective.
				//Notice that the cached Effective Perspective would be available only for a parent block which has been already processed locally.

			}
			//Checkpoints and Alternative Perspectives - END

			//choose the Effective Initial Perspective (it must be available).

			if (alternativePerspective.size())//prefer the alternative Effective Perspective if available (only for 'check-pointed' block-segments).
			{
				tools->writeLine("Assuming an " + tools->getColoredString("alternative Initial Effective Perspective", eColor::lightPink) + " " +
					tools->getColoredString(tools->base58CheckEncode(alternativePerspective), eColor::lightCyan));

				startingPointPerspective = alternativePerspective;
			}
			else {
				startingPointPerspective = parent->getHeader()->getPerspective(eTrieID::state);

				tools->writeLine("Assuming a " + tools->getColoredString("parental Initial Effective Perspective", eColor::orange) + " " +
					tools->getColoredString(tools->base58CheckEncode(startingPointPerspective), eColor::lightCyan));
			}
		}
		else if (block->isGenesis())
		{
			startingPointPerspective = tools->getNullHash();
		}
		else {
			log.push_back("ERROR: Block is neither genesis nor has valid parent block");
			return error;
		}


		if (!verficiationFlowManager->startFlow(startingPointPerspective)) {
			log.push_back("ERROR: Failed to start verification flow with starting point perspective: " +
				tools->base58CheckEncode(startingPointPerspective));
			verficiationFlowManager->abortFlow();//assertGN(false);//this should not happen; the perspective was restored properly during block validation above
			return error;
		}

		//***IMPORTANT*** From now on - we need either to ABORT or END the flow, BEFORE the function exits.

		// Use MemoryOrdered policy to prevent deadlocks
		sync::SynchronizedLocker lock(sync::LockingPolicy::MemoryOrdered, mChainGuardian, mVerifiedPathGuardian);


		setBlockProcessingStatus(eBlockProcessingStatus::commiting);

		if (!mSolidStorage->saveBlock(block)) {
			log.push_back("ERROR: Failed to save leader block to Cold-Storage");
			verficiationFlowManager->abortFlow();
			tools->writeLine("ERROR: I was unable to save the leader block to Cold-Storage!");
			blockProcessingCleanUp(block);
			return error;
		}
		else
		{
			//addBlockToUnorderedCache(block, blockID);
		}



		//BLOCK IS TO BE PROCESSED AS THE NEW LEADER AND AFFECT COLD-STORAGE - BEGIN
		tools->writeLine(tools->getColoredString("The block was validated properly", eColor::lightGreen));

		if (bvr.isForking())
		{
			mStatisticsDataGuardian.lock();
			mForksCount++;
			mStatisticsDataGuardian.unlock();
			tools->writeLine("The block will create a Fork!");
		}
		else
			tools->writeLine("The block is just extending the current chain.");
		//the block has been validated ; and assumed to be a valid block to extend the current chain.
		//let's leave all the sandboxes do all the processing again but this time affecting the Cold Storage and Real data.

		//DATA-BLOCK SECTION - BEGIN

		if (!bvr.isKeyBlock())
		{

			for (int i = 0; i < block->getTransactionsCount(); i++)
			{
				if (block->getTransaction(block->getTransactionsIDs()[i], trans)) {
					verficiationFlowManager->addTransactionToFlow(std::make_shared<CTransaction>(trans));
				}
				else {
					log.push_back("ERROR: Failed to retrieve transaction at index " + std::to_string(i));
					verficiationFlowManager->abortFlow();
					blockProcessingCleanUp(block);
					return error;
				}
			}

		}
		for (int i = 0; i < block->getVerifiablesCount(); i++)
		{
			if (block->getVerifiable(block->getVerifiablesIDs()[i], ver)) {
				verficiationFlowManager->addVerifiableToFlow(std::make_shared<CVerifiable>(ver));
			}
			else {
				log.push_back("ERROR: Failed to retrieve verifiable at index " + std::to_string(i));
				verficiationFlowManager->abortFlow();
				blockProcessingCleanUp(block);
				return error;
			}
		}


		tools->writeLine("I'll now attempt to End The Flow");
		height = block->getHeader()->getHeight();
		
		flowResult = verficiationFlowManager->endFlow(true, true, true, errorMsg, receipts, finalPerspective, false, block,false, effectiveTotalReward, effectivePaidReward);

		if (flowResult != success) {
			log.push_back("ERROR: Flow end failed - " + errorMsg);
			tools->writeLine("The attempt to end the Flow was unsuccessful.(" + errorMsg + ")");
			blockProcessingCleanUp(block);
			return error;
		}


		///FINAL COMMIT WAS OK - BEGIN
		tools->writeLine("I'll now update the perspective of the Live Transactions Manager to " + tools->base58CheckEncode(finalPerspective));


		if (mLiveTransactionsManager == nullptr) {
			log.push_back("ERROR: Live transactions manager is null");
			blockProcessingCleanUp(block);
			return error;
		}

		mLiveStateDBGuardian.lock();
		mIsNumberOfStateDomainsFresh = false;

		//[Warning]: If, processing of a block was 'covered' by a checkpoint we make Transaction Manager use the Final Effective Perspective explicitly
		//as it MIGHT differ from the Final Expected Perspective - which is fine.

		if (!mLiveStateDB->setPerspective(checkpoint ? finalPerspective :
			block->getHeader()->getPerspective(eTrieID::state))) {
			log.push_back("ERROR: Failed to update Live Transaction Manager perspective");
			tools->writeLine("I could not update perspective of the Live Transaction Manager");
			mLiveStateDBGuardian.unlock();
			blockProcessingCleanUp(block);
			mIsNumberOfStateDomainsFresh = true;
			return error;
		}

		updateLiveTransactionManagerStatistics(bvr.isKeyBlock());

		if (mTestTrieAfterBlockProcessing)
		{
			size_t foundDomainsCount = 0;
			tools->writeLine("Debug Mode: I'm testing the main StateDB Trie; This will take some time..");
			mLiveStateDB->testTrie(foundDomainsCount, true, true, true, eTrieSize::mediumTrie);
			tools->writeLine("Debug Mode: Testing finished. Found " + std::to_string(foundDomainsCount) + " State Domains");
			mIsNumberOfStateDomainsFresh = true;
			//now check if the number of state domains reported by StateDomain Manager is the same
			//as the found number within the StateTrie.
			size_t reportedCount = mLiveTransactionsManager->getStateDomainManager()->getKnownDomainsCount();
			if (foundDomainsCount != reportedCount) {//the count of 'known' and actual state domains might differ due to a fork which caused evaporation of some of the domains
				//assert(false);
			}

		}
		mLiveStateDBGuardian.unlock();

		//DATA-BLOCK SECTION - END


		//[Warning]: If, processing of a block was 'covered' by a checkpoint we omit validation against the Final Expected Perspective.
		if (!checkpoint && !tools->compareByteVectors(mLiveStateDB->getPerspective(),
			block->getHeader()->getPerspective(eTrieID::state))) {
			log.push_back("ERROR: Final perspective validation failed - perspectives do not match");
			return CBlockchainManager::eBlockProcessingResult::error;
		}

		//Note: the initial Trie test *always* happens on the application start-up. Thus afterwards the Trie is always assumed
		//to be in the correct state after each Flow commit. The StateDomain Manager is updated with the newly created AND modified domains.
		//the domain-backlog is updated/pruned during endFlow()

		blockUseRef = block.use_count();

		mIsNumberOfStateDomainsFresh = true;

		blockUseRef = block.use_count();
		//from now on the block will be visible from the Live instance and available in P2P network
		tools->writeLine("Updating the time the last block was processed");
		pingLastTimeValidBlockProcessed();
		//mFlowTransactionsManager->getFlowDB()->pruneTrie(); do *NOT* touch the Flow-DB from outside of the Flow.

		tools->writeLine("Registering receipts within the receipt-block cache index..");

		//DATA-BLOCK SECTION - BEGIN
		//if (!bvr.isKeyBlock())
		//{

		if (!bvr.isKeyBlock())
			tools->writeLine("I'll now mark all the matching transactions in MemPool as already processed");//we might be in possession of same transactions

		mReceiptsGuardian.lock();
		for (int i = 0; i < receipts.size(); i++)
		{
			//if (receipts[i].getReceiptType() == 0)//for now register only Transaction receipts
			receipts[i].setBlockInfo(block);//to maintain block height

			registerReceiptWithinCache(receipts[i], block->getID()); // a Hot Storage Cache Receipt->Block index. Note; there's also a Cold Storage 'link' based cache. populated through calls to mSolidStorage->saveLink() after each block is processed.
			receipts[i].clearBlockInfo();// receipts serialized within blocks do not contain block height (storage efficiency through data redundancy mitigation).
			// we thus need to restore default value of block height (0) so for it not to affect Receipt hash (block heiht is a private field
			//	which is taken into account during serialization and thus hash computation).
		}



		tools->writeLine("Creating GUID-Hash and Hash-Block Links for each Receipt");//the link will allow for retrieval of each receipt by its GUID.
		//these links can be removed later on during pruning of the Cold Storage.
		for (int i = 0; i < receipts.size(); i++)
		{
			std::vector<uint8_t> hash = receipts[i].getHash();

			//Note: these receipts are VERY important. They allow clients to retrieve the results of transaction, BUT ALSO
			//they participate in more critical processes.
			//Example: The Receipt ID of a Verifiable depends on its type, but mostly 
			//it is based on a PROOF contained within it (if present).
			//For instance, in case of a a Proof-of-Fraud, the ID is based on the [BlockHeight,PubKey] tuple.
			//Then, when issuing rewards for reporting frauds, it is checked if FRAUD regarding a given key-block was not
			//reported YET. Were it not the case, we would open the doors to a 'FRAUD-report-double-spend' type of attack.

			CReceipt recD;
			assertGN(block->getHeader()->getReceipt(hash, recD), "Integrity error");

			tools->writeLine("Saving a GUID-Hash Link for Receipt: " + tools->base58CheckEncode(receipts[i].getGUID()));
			assertGN(mSolidStorage->saveLink(receipts[i].getGUID(), hash, eLinkType::eLinkType::receiptsGUIDtoReceiptsHash));
			assertGN(mSolidStorage->loadLink(receipts[i].getGUID(), hash, eLinkType::eLinkType::receiptsGUIDtoReceiptsHash));


			tools->writeLine("Saving a Hash-Block Link for Receipt: " + tools->base58CheckEncode(receipts[i].getGUID()));
			assertGN(mSolidStorage->saveLink(hash, blockID, eLinkType::eLinkType::receiptHashToBlockID));
			assertGN(mSolidStorage->loadLink(hash, blockID, eLinkType::eLinkType::receiptHashToBlockID));

			//testing - begin
			//test retrieval of receipts
			//CReceipt rec;
			//if (!block->getReceipt(hash, rec))
			//	assertGN(false);
			//testing - end

		}

		mReceiptsGuardian.unlock();
		//}
		//DATA-BLOCK SECTION - END


		if (!setLeader(block, heaviestChainProofSize)) {
			log.push_back("ERROR: Failed to set block as leader");
			blockProcessingCleanUp(block);
			return error;
		}

		// Abort PoW Computation - BEGIN
		if (bvr.isKeyBlock())
		{
			

			// abort all current OpenCL computation. New key-block was validated, we do not want to be working on stale data..
			// let us switch to mining on the latest block ASAP.
			std::shared_ptr<CWorkManager> wm = getWorkManager();

			if (wm)
			{
				uint64_t abortedCount = 0;
				std::vector<uint8_t> miningTaskID = getFormationFlowManager()->getCurrentMinigTaskID();
				if (miningTaskID.empty() == false)
				{
					wm->abortWork(miningTaskID);
					abortedCount++;
				}
				std::shared_ptr<CSettings> settings = getSettings();
	
				if (wm->getWorkers().size() > 0 && wm->getCurrentTotalMhps() > 0)
				{
					abortedCount = getWorkManager()->abortAllTasks(true);
				}
				tools->logEvent(tools->getColoredString("Aborted ", eColor::orange) + std::to_string(abortedCount) + " computational tasks.", eLogEntryCategory::localSystem, 3);

			}
		}
		// Abort PoW Computation - END
		
		//KEY-BLOCK SECTION - END

		/////FINAL COMMIT WAS OK - END


		bAppended = true;
		bSaved = true;
		//BLOCK WAS TO BE PROCESSED AT THE NEW LEADER AND AFFECT COLD-STORAGE - END

		//Checkpoints and cached perspectives - BEGIN
#if ENABLE_FLOW_DETAILED_LOGS == 1
		debugLog << "[ Effective Total Reward ]: " + tools->formatGNCValue(effectiveTotalReward) << "\n";
		debugLog << "[ Effective Paid Reward ]: " + tools->formatGNCValue(effectivePaidReward) << "\n";
#endif

		if (checkpoint)
		{
			block->getHeader()->setTotalBlockReward(effectiveTotalReward, true);
			block->getHeader()->setPaidToMiner(effectivePaidReward, true);

			setEffectivePerspective(finalPerspective, blockID);
			setTotalBlockRewardEffective(block->getHeader()->getTotalBlockReward(), blockID);
			setPaidToMinerEffective(block->getHeader()->getPaidToMiner(), blockID);
		}
		//Checkpoints and cached perspectives - END

	}//BLOCK IS NEW LEADING BLOCK - END
	else if (bvr.getStatus() == eBlockVerificationResult::notAForkLeadingBlock)
	{
		//and if set then is must have been expected.

		tools->writeLine("Block omitted:" + translateVerificationResult(bvr.getStatus()));

	}
	else if (bvr.isToBeStored())
	{//not a leader but it was decided the block is to be saved to Cold Storage.
		tools->writeLine("The block was not a Leader Reason: " + translateVerificationResult(bvr.getStatus()) + " but we're saving the Block to Cold Storage");
		//it might not be the Leader; but it was decided that we want to save the Block to cold storage.
		if (mSolidStorage->saveBlock(block))
		{
			bSaved = true;
			//addBlockToUnorderedCache(block);
		}
		else
		{
			bSaved = false;
			log.push_back("ERROR: Failed to save non-leader block to cold storage");
			tools->writeLine("There was an error saving block to cold storage!");
		}
	}
	else
	{//block discarded
		bAppended = false;
		tools->writeLine(std::string((bvr.isKeyBlock() ? "Key" : "Data")) + " block candidate for height " + std::to_string(block->getHeader()->getHeight()) + " was decided to be " + tools->getColoredString("INVALID", eColor::lightPink) + ". Reason: " + translateVerificationResult(bvr.getStatus()));
		//todo: decrease the rating of node who provided it.
	}

	//CLEAN-UP - BEGIN

	blockProcessingCleanUp(block, false);// keep tries in Hot Storage, would be managed by cache clean-up mechanics later on.



	uint64_t currentHSCacheSize = getBlockCacheLength(true); //getHotStorageCacheLength(true);
	tools->writeLine("Current Hot Storage Blockchain Cache Length: " + std::to_string(currentHSCacheSize));

	if (previousIterationHSCachelength == currentHSCacheSize && (getHeight() != previousIterationBlockchainHeight))
	{
		tools->writeLine("Note: Blockchain Hot-Storage Cache pruning was effective");
	}
	else
		tools->writeLine("Note: Blockchain  Hot-Storage Cache pruning was NOT effective");

	
	// Post-Flow Processing - BEGIN
	// [ Rationale ]:  here we apply post processing to blocks scheduled by local scheuduler (those which were supposed to participate in Flow).
	//				   In other words, here we do not apply post-processing to blocks coming in directly, out of order, directly from network.
	// [ Notice ]:     trailing invalid box are supposed to be dequeued before this code-block is reached.
	if (wasScheduledByLocalScheduler)
	{
		// Cancel Processing of pending blocks - BEGIN
		if (!((bvr.getStatus() == valid && bvr.isLeader())))
		{
			std::lock_guard<std::recursive_mutex> lock(blockQueueGuardian);
			uint64_t removedPendingBlocksCount = 0;
			if (!mBlockQueue.empty())
			{
				std::vector<uint8_t> currentBlockID = blockID;
				bool memberOfCurrentHeaviestChainProof = isBlockInChainProof(currentBlockID, eChainProof::heaviestCached);
				// block needs to be member of current heaviest chain-proof, otherwise we risk
			   // blacklsiting blocks from an alternative (proper) chain.

			   // continue cancelling processing of blocks only as long as the below holds
				while (memberOfCurrentHeaviestChainProof
					&& !mBlockQueue.empty()
					&& tools->compareByteVectors(mBlockQueue.front()->getHeader()->getParentID(), currentBlockID)
					&& mBlockQueue.front()->getScheduledByLocalScheduler() // eliminate only processing of blocks scheduled by local scheduler (do not cancel pre-processing of network blocks)
					)
				{
					currentBlockID = mBlockQueue.front()->getID();
					memberOfCurrentHeaviestChainProof = isBlockInChainProof(currentBlockID, eChainProof::heaviestCached);
					mBlockQueue.pop_front();
					removedPendingBlocksCount++;
				}
				tools->writeLine(tools->getColoredString("Canceled processing of " + std::to_string(removedPendingBlocksCount) + " offspring blocks", eColor::lightPink));
				setCachedBlockQueueLength(mBlockQueue.size());
			}

			// Immunise Node Against Block and Path - BEGIN
		
			// Notice: it is not sufficient to check for getCachedHeight() + 1 == block->getHeader()->getHeight()
			//         That is because we need to support deep forks or situatoin in which a remote block attempts to fork out few blocks deerper compared local leader.
			//if (getCachedHeight() + 1 == block->getHeader()->getHeight())// it's sufficient to perform for next leader candidate
			//{
				if (isBlockInChainProof(block->getID(), eChainProof::heaviestCached)) // block needs to be member of current heaviest chain-proof, otherwise we risk
					// blacklsiting blocks from an alternative (proper) chain.
				{
					immuniseAgainstBlock(block);
					mNetworkManager->forgetReceivedChainProofs(); // forget all received chain-proofs so that me may resume accepting alternative histories of events asap.
					clearFarAwayCPRequestedTimestamp();           // nevermind if a long chain-proof was processed recently. We want to process alternative histories asap.
				}
				// Immunise Node Against Block and Path - END
			//}
		}
		// Cancel Processing of pending blocks - END
	}
	// Post-Flow Processing - END

	//CLEAN-UP - END

	previousIterationBlockchainHeight = getHeight();
	previousIterationHSCachelength = currentHSCacheSize;

	// Post-Flight - BEGIN
	if (bAppended)
	{
		markBlockLocalAvailability(blockID, true, true);
		incAPM();
		if (!block->getHeader()->isKeyBlock())
		{
			incAssumedAsLeaderDataBlocksCount();
			updateDataBlockInterval();
		}
		else
			incAssumedAsLeaderKeyBlocksCount();
		return appended;
	}
	else if (bSaved)
	{
		markBlockLocalAvailability(blockID, true, true);
		if (block->getHeader()->isKeyBlock())
			incJustSavedKeyBlocksCount();
		else
			incJustSavedDataBlocksCount();

		return justSaved;
	}
	else {
		if (block != nullptr && block->getHeader() != nullptr)
		{
			if (block->getHeader()->isKeyBlock())
				incDiscardedKeyBlocksCount();
			else
				incDiscardedDataBlocksCount();
		}


		return discarded;
	}
	// Post-Flight - END

	//Operational Logic - END
}

void CBlockchainManager::blockProcessingCleanUp(std::shared_ptr<CBlock>& block, bool freeTries)
{
	if (freeTries)
	{
		if (!block->getHeader()->isKeyBlock())
			if (block->getHeader() != nullptr)
				block->getHeader()->freeTries();
	}
}

/// <summary>
/// Returns height of the current heaviest chain.
/// 
/// </summary>
/// <returns></returns>
uint64_t CBlockchainManager::getHeight()
{
	std::lock_guard<std::recursive_mutex> lock(mLeaderGuardian);
	if (mLeader != nullptr)
	{
		return mLeader->getHeader()->getHeight();
	}
	return 0;
}



/// <summary>
/// Returns height of the current heaviest chain.
/// 
/// </summary>
/// <returns></returns>
uint64_t CBlockchainManager::getKeyHeight()
{
	std::lock_guard<std::recursive_mutex> lock(mLeaderGuardian);
	if (mLeader != nullptr)
	{
		return mLeader->getHeader()->getKeyHeight();
	}
	return 0;
}
/// <summary>
/// Gets leader ID; either blockchain-head or there's a requirement to fetch recet KEY-BLOCK.
/// </summary>
/// <param name="keyBlockOnly"></param>
/// <returns></returns>
std::vector<uint8_t> CBlockchainManager::getLeaderID(bool keyBlockOnly)
{
	std::vector<uint8_t> leaderID;
	std::shared_ptr<CBlock> leader;

	leader = getLeader(keyBlockOnly);

	if (leader != nullptr)
	{
		leaderID = leader->getID();
	}

	return leaderID;
}


/// <summary>
/// Gets Current leader either current blockchain top; or there's a requirement to fetch the current KEY-BLOCK
/// (in which case the chain would be traversed). 
/// </summary>
/// <returns></returns>
std::shared_ptr<CBlock>CBlockchainManager::getLeader(bool keyBlockOnly)
{
	/*allow retrieval whenever desired it's up to the caller to ensure it's the good moment
	BUT.. allow setting ONLY when all the chain/chainproof mutexes are LOCKED as that would AFFECT the processes
	*/
	std::lock_guard<std::recursive_mutex> lock(mLeaderGuardian);

	//LOCAL VARIABLES - BEGIN

	//LOCAL VARIABLES - END


	/*//debug check todo: remove
	std::vector<uint8_t> leaderID;
	if((keyBlockOnly && mKeyLeader != nullptr))
		leaderID = mKeyLeader->getID();
	else if ((!keyBlockOnly && mLeader != nullptr))
	leaderID = mLeader->getID();

	if (keyBlockOnly)
	{
		if (leaderID.size() > 0)
		{
			//ensure it's within chainproof
			bool present = false;
			for (uint64_t i = mVerifiedPath.size() - 1; i >= 0; i--)
			{
				if (getTools()->compareByteVectors(mVerifiedPath[i], leaderID))
				{
					present = true;
					break;
				}
			}
		 assertGN(present);
		}
	}
	else
	{
		//ensure it's the last element
		if (mLeader != nullptr)
		 assertGN(getTools()->compareByteVectors(leaderID, mVerifiedPath[mVerifiedPath.size() - 1]));
	}
	//debug check
	*/
	if (!keyBlockOnly)
		return mLeader;
	else
		return mKeyLeader;
}

void  CBlockchainManager::setCachedLeader(std::shared_ptr<CBlock> leader)
{
	std::lock_guard<std::mutex> lock(mFieldsGuardian);
	mCachedLeader = leader;
	if (leader)
	{
		if (leader->getHeader()->isKeyBlock())
		{
			mCachedKeyLeader = leader;
		}
	}
}

std::shared_ptr<CBlock> CBlockchainManager::getCachedLeader(bool keyBlockOnly)
{
	std::lock_guard<std::mutex> lock(mFieldsGuardian);

	if (keyBlockOnly)
		return mCachedKeyLeader;
	else
		return mCachedLeader;
}

std::shared_ptr<CBlock> CBlockchainManager::getNextKeyBlockForBlock(
	std::shared_ptr<CBlock> block,
	bool omitHardForkBlocks,
	eChainProof::eChainProof chain,
	bool allowHotStorageCache)
{
	std::lock_guard<ExclusiveWorkerMutex> lock(mChainGuardian);

	// LOCAL VARIABLES - BEGIN
	eBlockInstantiationResult::eBlockInstantiationResult ir;
	std::string error;
	std::shared_ptr<CBlock> current = block;
	uint64_t currentKeyHeight = 0;
	// LOCAL VARIABLES - END

	if (block == nullptr || block->getHeader() == nullptr)
		return nullptr;

	// Determine the key height of the input block
	currentKeyHeight = block->getHeader()->getKeyHeight();

	// Hot Storage Check - BEGIN
	if (allowHotStorageCache && (chain == eChainProof::verified || chain == eChainProof::verifiedCached))
	{
		do
		{
			current = current->getNext();
			if (current != nullptr)
			{
				if (current->getHeader()->isKeyBlock() && (!(omitHardForkBlocks && current->getHeader()->getNonce() == 0)))
					return current;
			}
		} while (current != nullptr);
	}
	// Hot Storage Check - END

	// Cold Storage Access - BEGIN
	uint64_t nextKeyHeight = currentKeyHeight + 1;
	std::vector<uint8_t> nextKeyBlockID = getBlockIDAtKeyHeight(nextKeyHeight, chain);

	if (!nextKeyBlockID.empty())
	{
		current = getBlockByHash(nextKeyBlockID, ir, true);

		if (current != nullptr && current->getHeader()->isKeyBlock() &&
			(!(omitHardForkBlocks && current->getHeader()->getNonce() == 0)))
		{
			return current;
		}
	}
	// Cold Storage Access - END

	return nullptr;
}

/// <summary>
/// Retrieves a block at a specified height from the blockchain.
/// If isKeyHeight is specified, the function proceeds as if there were only key-blocks.
/// The retrieval is based on the specified chain proof type.
/// </summary>
/// <param name="height">The height of the block to retrieve (0 is the genesis block).</param>
/// <param name="isKeyHeight">If true, only consider key blocks when calculating height.</param>
/// <param name="chain">The chain to query (verified, heaviest, etc.). Defaults to verified.</param>
/// <returns>Shared pointer to the CBlock at the specified height, or nullptr if not found.</returns>
std::shared_ptr<CBlock> CBlockchainManager::getBlockAtHeight(uint64_t height, bool isKeyHeight, eChainProof::eChainProof chain)
{
	if (isKeyHeight && !(chain == eChainProof::verified || chain == eChainProof::verifiedCached))
	{
		mTools->logEvent("Target chain key-height is not supported by getBlockAtHeight() method.", eLogEntryCategory::localSystem, 10, eLogEntryType::failure);
		return nullptr;
	}

	// Extremely Fast Hot-Storage Look-up - BEGIN
	/**
	 * Fast Cache Lookup Process:
	 * 1. Utilize the flat cache (mBlockCacheFlat or mKeyBlockCacheFlat) for rapid block retrieval.
	 * 2. The flat cache provides O(1) access time, significantly faster than traversing the blockchain.
	 *
	 * Benefits:
	 * - Dramatically reduces retrieval time for recently accessed or frequently used blocks.
	 * - Efficient for both regular and key block depths across different chain types.
	 *
	 * Note: The flat cache is part of the hot storage, containing in-memory references to blocks.
	 *       It's particularly effective for recent blocks or during periods of high repeated access.
	 */
	std::shared_ptr<CBlock> fastBlock = getBlockFlatCache(height, false, isKeyHeight, chain);
	if (fastBlock)
	{
		// Block found in fast cache, return immediately
		return fastBlock;
	}
	// Extremely Fast Hot-Storage Look-up - END

	// If we reach here, the block was not found in the fast cache.
	// The method would continue with slower, traditional block retrieval methods.

	// Local Variables - BEGIN
	std::shared_ptr<CBlock> current = nullptr;
	std::shared_ptr<CBlock> genesis = nullptr;
	eBlockInstantiationResult::eBlockInstantiationResult res;
	uint64_t currentHeight = 0;
	size_t cacheSize = getMaxNrOfPrunedBlocksToKeepInMemory();
	bool currentIsKeyBlock = false;
	bool wasInitialBlockKeyBlock = false;
	bool isFirstPass = true;
	std::vector<std::vector<uint8_t>>* targetPath = nullptr;
	ExclusiveWorkerMutex* targetMutex = nullptr;
	// Local Variables - END

	// Chain Selection - BEGIN
	switch (chain)
	{
	case eChainProof::verifiedCached:
		targetPath = &mVerifiedPathDouble;
		targetMutex = &mVerifiedPathDoubleGuardian;
		break;
	case eChainProof::heaviestCached:
		targetPath = &mHeaviestPathDouble;
		targetMutex = &mHeaviestPathDoubleGuardian;
		break;
	case eChainProof::verified:
		targetPath = &mVerifiedPath;
		targetMutex = &mVerifiedPathGuardian;
		break;
	case eChainProof::heaviest:
		targetPath = &mHeaviestPath;
		targetMutex = &mHeaviestPathGuardian;
		break;
	default:
		return nullptr; // Invalid chain type
	}
	// Chain Selection - END

	// Initialization and Validation - BEGIN
	{
		if (chain == eChainProof::verified)
		{
			genesis = getBlockAtHeightSSDirect(0, chain);
		}
		else if (chain == eChainProof::verifiedCached)
		{
			genesis = getBlockAtHeightSSDirect(0, chain);
		}

		current = genesis;
		size_t chainSize = 0;
		{
			std::lock_guard<ExclusiveWorkerMutex> lock(*targetMutex);
			chainSize = targetPath->size();
		}

		if (chainSize == 0 || height >= chainSize) {
			return nullptr;
		}
	}
	// Initialization and Validation - END

	// Hot Storage Check - BEGIN
	if ((chain == eChainProof::verified || chain == eChainProof::verifiedCached) && cacheSize > 0 && height < cacheSize) {
		// Use Hot Storage
		if (current->getHeader()->isKeyBlock()) {
			wasInitialBlockKeyBlock = true;
		}

		while (current != nullptr) {
			currentIsKeyBlock = current->getHeader()->isKeyBlock();

			if (currentHeight == height) {
				if (isKeyHeight) {
					if (currentIsKeyBlock) {
						return current; // Only if the current block is a key-block at the desired height
					}
				}
				else {
					return current; // We're interested in data-blocks as well
				}
			}

			// Fetch Next Block - BEGIN
			if (!isKeyHeight) {
				current = current->getNext(); // Fetch any child block
			}
			else {
				current = getNextKeyBlockForBlock(current); // We're only interested in key-blocks
			}
			// Fetch Next Block - END

			if (!current) {
				break; // Abort if no child
			}

			if (!(isKeyHeight && isFirstPass && !wasInitialBlockKeyBlock)) {
				// We do not want to increment height if the initial block was not a key block and it's a first pass.
				currentHeight++;
			}
			isFirstPass = false;
		}

		if (currentHeight == height) {
			return current;
		}
	}
	// Hot Storage Check - END

	// Cold Storage Access - BEGIN
	std::shared_ptr<CBlock> coldStorageBlock = nullptr;
	std::vector<uint8_t> blockHash;

	// Briefly lock the mutex to copy necessary data
	{
		std::lock_guard<ExclusiveWorkerMutex> lock(*targetMutex);
		if (height < targetPath->size()) {
			blockHash = (*targetPath)[height];
		}
	}

	if (!blockHash.empty()) {
		if (!isKeyHeight) {
			// Use selected chain path to get block from Cold Storage
			coldStorageBlock = mSolidStorage->getBlockByHash(blockHash, res, true);
		}
		else {
			// Use dedicated dictionary for key height
			std::vector<uint8_t> bID = getBlockIDAtKeyHeight(height, chain);
			if (!bID.empty()) {
				coldStorageBlock = mSolidStorage->getBlockByHash(blockHash, res, true);
			}
		}
	}
	// Cold Storage Access - END

	return coldStorageBlock;
}

// Operators Security Assessment - BEGIN
void CBlockchainManager::updateSecAnalysis(const std::shared_ptr<CBlock>& block)
{
	if (!block) return;

	// Analyze the block for timestamp manipulation attacks
	analyzeBlockForTimestampManipulation(block);

	// Analyze the chain for PoW wave attacks incrementally using recent blocks
	analyzeChainForPoWWaveAttacks(block); // Analyze the last 100 key blocks
}

/**
 * @brief Analyzes a block for timestamp manipulation attempts in transactions
 *
 * Detects and categorizes timestamp violations in transactions based on severity:
 * - Minor: 3-6 hours discrepancy
 * - Major: 6-12 hours discrepancy
 * - Critical: >12 hours discrepancy
 *
 * Updates operator security info with weighted violation counts and detailed reports.
 *
 * @param block The block to analyze
 */
void CBlockchainManager::analyzeBlockForTimestampManipulation(const std::shared_ptr<CBlock>& block)
{
	// Constants - BEGIN
	static constexpr uint64_t MINOR_VIOLATION_THRESHOLD = 10800;    // 3 hours in seconds
	static constexpr uint64_t MAJOR_VIOLATION_THRESHOLD = 21600;    // 6 hours in seconds
	static constexpr uint64_t CRITICAL_VIOLATION_THRESHOLD = 43200; // 12 hours in seconds
	// Constants - END

	// Local Variables - BEGIN
	auto header = block->getHeader();
	TimestampAnalysis blockAnalysis;
	// Local Variables - END

	// Input Validation - BEGIN
	if (header->isKeyBlock()) return; // Only data blocks contain transactions
	// Input Validation - END

	// Operator ID Resolution - BEGIN
	std::vector<uint8_t> operatorIDBytes = header->getMinersID();
	if (operatorIDBytes.empty())
	{
		// Retrieve operatorID from parent key block
		std::shared_ptr<CBlock> parentKeyBlock = getKeyBlockForBlock(block, false, eChainProof::verifiedCached, true);
		if (parentKeyBlock)
		{
			operatorIDBytes = parentKeyBlock->getHeader()->getMinersID();
		}
	}
	std::string operatorID = mTools->bytesToString(operatorIDBytes);
	// Operator ID Resolution - END

	// Block Description Retrieval - BEGIN
	std::shared_ptr<CBlockDesc> blockDesc = block->getDescription();
	if (!blockDesc)
	{
		std::string errorMessage;
		blockDesc = createBlockDescription(block, true, false, errorMessage);
		if (!blockDesc) return;
	}
	// Block Description Retrieval - END

	// Transaction Analysis - BEGIN
	auto txDescs = blockDesc->getTransactions();
	for (const auto& txDesc : txDescs)
	{
		uint64_t confirmedTimestamp = txDesc->getConfirmedTimestamp();
		uint64_t unconfirmedTimestamp = txDesc->getUnconfirmedTimestamp();

		// Calculate absolute time difference safely
		uint64_t timeDiff = (confirmedTimestamp >= unconfirmedTimestamp) ?
			confirmedTimestamp - unconfirmedTimestamp :
			unconfirmedTimestamp - confirmedTimestamp;

		// Categorize violation based on severity
		if (timeDiff > CRITICAL_VIOLATION_THRESHOLD) {
			blockAnalysis.criticalViolations++;
		}
		else if (timeDiff > MAJOR_VIOLATION_THRESHOLD) {
			blockAnalysis.majorViolations++;
		}
		else if (timeDiff > MINOR_VIOLATION_THRESHOLD) {
			blockAnalysis.minorViolations++;
		}
	}
	// Transaction Analysis - END

	// Security Info Update - BEGIN
	uint32_t totalViolations = blockAnalysis.minorViolations +
		blockAnalysis.majorViolations +
		blockAnalysis.criticalViolations;

	if (totalViolations > 0)
	{
		std::unique_lock<std::shared_mutex> lock(securityMapMutex);

		// Get or create operator security info
		auto it = operatorSecurityMap.find(operatorID);
		if (it == operatorSecurityMap.end()) {
			operatorSecurityMap[operatorID] = std::make_shared<COperatorSecurityInfo>(operatorID);
			it = operatorSecurityMap.find(operatorID);
		}

		auto& securityInfo = it->second;

		// Calculate weighted violation score
		uint64_t weightedViolations =
			blockAnalysis.minorViolations +
			(blockAnalysis.majorViolations * 2) +
			(blockAnalysis.criticalViolations * 4);

		// Update security metrics
		securityInfo->incrementTimestampManipulationCount(weightedViolations);

		// Generate detailed report
		std::stringstream report;
		report << "Block at height " << header->getHeight() << " contains timestamp violations:\n"
			<< "- Minor (3-6h):    " << blockAnalysis.minorViolations << "\n"
			<< "- Major (6-12h):   " << blockAnalysis.majorViolations << "\n"
			<< "- Critical (>12h): " << blockAnalysis.criticalViolations << "\n"
			<< "Weighted score: " << weightedViolations;

		securityInfo->addDetailedReport(report.str());
	}
	// Security Info Update - END
}
/**
 * @brief Analyzes a block for Proof-of-Work (PoW) wave attacks, including detection of colluding operators exploiting difficulty adjustments.
 *
 * This method processes each key block incrementally, updating the analysis as each block is processed.
 * It maintains cumulative data structures to keep track of necessary information for analysis.
 *
 * @param block The key block to analyze.
 */

 /**
  * @brief Analyzes a block for Proof-of-Work (PoW) wave attacks, including detection of colluding operators exploiting difficulty adjustments.
  *
  * This method processes each key block incrementally, updating the analysis as each block is processed.
  * It maintains cumulative data structures to keep track of necessary information for analysis.
  *
  * @param block The key block to analyze.
  */
void CBlockchainManager::analyzeChainForPoWWaveAttacks(const std::shared_ptr<CBlock>& block)
{
	auto header = block->getHeader();

	// Only key blocks are relevant for PoW wave attacks
	if (!header->isKeyBlock()) return;
	const uint64_t MAX_SAFE_TIME = 0x7FFFFFFFFFFFFFFF;  // Max safe time value
	// Constants and Parameters
	const size_t windowSize = CGlobalSecSettings::getKeyBlockDiffWindowSize(); // 144 key blocks
	const double individualActivityThreshold = 0.5; // Threshold for individual operator activity
	const double groupActivityThreshold = 0.3; // Threshold for group activity ratio
	const double intervalAnomalyThreshold = 0.5; // Threshold to detect significant deviations in block intervals
	uint64_t targetInterval = CGlobalSecSettings::getTargetedBlockInterval(); // Expected interval between key blocks in seconds
	const uint64_t COOLDOWN_PERIOD_BLOCKS = windowSize / 6; // 24 key blocks cooldown period

	// Lock to ensure thread safety for shared data structures
	std::unique_lock<std::shared_mutex> lock(dataMutex);

	// Step 1: Update the sliding window of recent key blocks
	// We maintain a deque of recent key blocks to perform analysis over a fixed window size
	recentKeyBlocks.push_back(block);

	// Maintain the window size by removing the oldest block if necessary
	if (recentKeyBlocks.size() > windowSize) {
		recentKeyBlocks.pop_front();
	}

	// Step 2: Update operator activities
	// Extract operator ID, solved time, difficulty, and height from the block header
	std::string operatorID = mTools->bytesToString(header->getMinersID());
	uint64_t solvedAt = header->getSolvedAtTime();
	double difficulty = header->getDifficulty();
	uint64_t height = header->getHeight();

	// Get or create the operator's security info
	// We use a map to store security information for each operator
	std::shared_ptr<COperatorSecurityInfo> opInfo;
	auto it = operatorSecurityMap.find(operatorID);
	if (it != operatorSecurityMap.end()) {
		opInfo = it->second;
	}
	else {
		opInfo = std::make_shared<COperatorSecurityInfo>(operatorID);
		operatorSecurityMap[operatorID] = opInfo;
	}

	// Update operator's activity data
	opInfo->incrementBlocksMined();
	opInfo->addSolvedTime(solvedAt);

	// Update mining statistics for anomaly detection
	// This updates the EWMA and CUSUM statistics used for detecting anomalies in mining activity
	opInfo->updateMiningStatistics(height, solvedAt);

	// Step 3: Identify difficulty changes
	// Check if the difficulty has changed compared to the previous block
	bool difficultyChanged = false;
	double prevDifficulty = difficulty;
	if (recentKeyBlocks.size() >= 2) {
		auto prevBlock = recentKeyBlocks[recentKeyBlocks.size() - 2];
		prevDifficulty = prevBlock->getHeader()->getDifficulty();
		if (difficulty != prevDifficulty) {
			difficultyChanged = true;
			double difficultyChange = difficulty - prevDifficulty;
			if (difficultyChange < 0) {
				// Difficulty decreased
				opInfo->incrementBlocksMinedDuringDifficultyDecrease();
			}
			else if (difficultyChange > 0) {
				// Difficulty increased
				opInfo->incrementBlocksMinedDuringDifficultyIncrease();
			}
			// If difficulty didn't change, no action needed
		}
	}

	// Step 4: Compute global block intervals and detect anomalies
	// Analyze block intervals to detect if blocks are being mined significantly faster than expected
	if (recentKeyBlocks.size() >= 2) {
		// Collect solved times of recent key blocks
		std::vector<uint64_t> blockTimes;
		for (const auto& blk : recentKeyBlocks) {
			blockTimes.push_back(blk->getHeader()->getSolvedAtTime());
		}

		// Compute interval durations between consecutive blocks and accumulate total interval
		double totalInterval = 0;
		std::vector<uint64_t> intervalDurations;
		for (size_t i = 1; i < blockTimes.size(); ++i) {
			uint64_t interval = blockTimes[i] - blockTimes[i - 1];
			intervalDurations.push_back(interval);
			totalInterval += interval;
		}
		double meanInterval = totalInterval / intervalDurations.size();

		// Calculate standard deviation
		double stdDev = calculateStandardDeviation(intervalDurations, meanInterval);

		// Define anomaly threshold based on mean and standard deviation
		double anomalyThreshold = meanInterval - (intervalAnomalyThreshold * stdDev);

		// Identify anomalous intervals
		std::vector<size_t> anomalousIndices;
		for (size_t i = 0; i < intervalDurations.size(); ++i) {
			if (intervalDurations[i] < anomalyThreshold) {
				anomalousIndices.push_back(i);
			}
		}

		// Check if the number of anomalous intervals exceeds a dynamic threshold
		const double anomalousIntervalRatioThreshold = 0.2; // 20% of intervals
		double anomalousIntervalRatio = static_cast<double>(anomalousIndices.size()) / intervalDurations.size();

		if (anomalousIntervalRatio > anomalousIntervalRatioThreshold) {
			// Anomaly detected: blocks are being mined significantly faster than the target interval

			// Step 5: Identify operators with significant mining activity during anomalous intervals
			/*
			Objective: Counts the number of blocks mined by each operator during anomalous intervals.
			Logic: Iterates over all recent key blocks within the sliding window and increments the count for each operator.
			Scientific Soundness: Aggregating blocks mined by operators during anomalies helps identify
								those who are contributing disproportionately to the anomalous behavior.
			*/

			std::unordered_map<std::string, size_t> operatorBlocksMinedInAnomalousIntervals;
			for (const auto& idx : anomalousIndices) {
				// Consider both blocks involved in the anomalous interval
				auto blk1 = recentKeyBlocks[idx];
				auto blk2 = recentKeyBlocks[idx + 1];
				std::string opID1 = mTools->bytesToString(blk1->getHeader()->getMinersID());
				std::string opID2 = mTools->bytesToString(blk2->getHeader()->getMinersID());
				operatorBlocksMinedInAnomalousIntervals[opID1]++;
				operatorBlocksMinedInAnomalousIntervals[opID2]++;
			}

			// Update operator activities during anomalous intervals
			for (auto& [opID, blocksMined] : operatorBlocksMinedInAnomalousIntervals) {
				auto opIt = operatorSecurityMap.find(opID);
				if (opIt != operatorSecurityMap.end()) {
					opIt->second->incrementBlocksMinedDuringAnomalousIntervals(blocksMined);
				}
				else {
					// Operator not found in map, create new entry
					auto newOpInfo = std::make_shared<COperatorSecurityInfo>(opID);
					newOpInfo->incrementBlocksMinedDuringAnomalousIntervals(blocksMined);
					operatorSecurityMap[opID] = newOpInfo;
				}
			}


			// Step 6: Group operators with overlapping mining times during anomalous intervals
			/*
			Objective: Group operators who have overlapping block mining times during anomalous intervals to detect potential collusion.
			Logic:
			Union-Find Structure: Efficiently groups operators based on overlaps in their block mining times.
			Overlap Detection: Operators mining blocks within overlapThreshold (2 minutes) of each other are considered connected.
			Scientific Soundness: Detecting overlapping mining activities can indicate coordinated behavior,
								especially if multiple operators are mining blocks in close temporal proximity during anomalous periods.
			*/
			// We use a Union-Find data structure to group operators based on overlapping mining times
			// Step 6: Group operators with overlapping mining times during anomalous intervals
// Dynamically compute overlapThreshold based on recent block intervals

// Calculate dynamic overlapThreshold as a percentage of the mean interval
			const double overlapPercentage = 0.2; // 20% of the mean interval
			int64_t dynamicOverlapThreshold = static_cast<int64_t>(meanInterval * overlapPercentage);

			// Ensure dynamicOverlapThreshold is within reasonable bounds
			const int64_t MIN_OVERLAP_THRESHOLD = 120;  // 2 minutes
			const int64_t MAX_OVERLAP_THRESHOLD = targetInterval * 3; // 30 minutes
			dynamicOverlapThreshold = std::clamp(dynamicOverlapThreshold, MIN_OVERLAP_THRESHOLD, MAX_OVERLAP_THRESHOLD);

			// Data structure for Union-Find
			class UnionFind {
			public:
				void unite(const std::string& a, const std::string& b) {
					std::string rootA = find(a);
					std::string rootB = find(b);
					if (rootA != rootB) {
						parent[rootB] = rootA;
					}
				}

				std::string find(const std::string& a) {
					if (parent.find(a) == parent.end()) {
						parent[a] = a;
					}
					if (parent[a] != a) {
						parent[a] = find(parent[a]);
					}
					return parent[a];
				}

			private:
				std::unordered_map<std::string, std::string> parent;
			};

			// Prepare operator times
		// Prepare operator times - only include times during anomalous intervals
			std::vector<std::pair<std::string, std::vector<int64_t>>> operatorTimes;

			for (const auto& [opID, blocksMined] : operatorBlocksMinedInAnomalousIntervals) {
				std::vector<int64_t> times;
				times.reserve(blocksMined); // Reserve space based on blocks mined

				// Collect solved times from anomalous blocks only
				for (const auto& idx : anomalousIndices) {
					// Consider both blocks involved in the anomalous interval
					if (mTools->bytesToString(recentKeyBlocks[idx]->getHeader()->getMinersID()) == opID) {
						uint64_t t = recentKeyBlocks[idx]->getHeader()->getSolvedAtTime();
						if (t <= MAX_SAFE_TIME) {
							times.push_back(static_cast<int64_t>(t));
						}
					}
					if (mTools->bytesToString(recentKeyBlocks[idx + 1]->getHeader()->getMinersID()) == opID) {
						uint64_t t = recentKeyBlocks[idx + 1]->getHeader()->getSolvedAtTime();
						if (t <= MAX_SAFE_TIME) {
							times.push_back(static_cast<int64_t>(t));
						}
					}
				}

				std::sort(times.begin(), times.end()); // Pre-sort times for efficient comparison
				operatorTimes.emplace_back(opID, std::move(times));
			}


			// Compare operators for overlaps and unite groups
			UnionFind uf;
			for (size_t i = 0; i < operatorTimes.size(); ++i) {
				const auto& [opID1, times1] = operatorTimes[i];
				for (size_t j = i + 1; j < operatorTimes.size(); ++j) {
					const auto& [opID2, times2] = operatorTimes[j];

					// Check for overlaps between times1 and times2 using dynamicOverlapThreshold
					size_t idx1 = 0, idx2 = 0;
					bool overlapFound = false;
					while (idx1 < times1.size() && idx2 < times2.size()) {
						int64_t t1 = times1[idx1];
						int64_t t2 = times2[idx2];
						int64_t diff = t1 - t2;
						if (std::abs(diff) <= dynamicOverlapThreshold) {
							overlapFound = true;
							break;
						}
						if (t1 < t2) {
							++idx1;
						}
						else {
							++idx2;
						}
					}
					if (overlapFound) {
						uf.unite(opID1, opID2);
					}
				}
			}

			// Collect groups from Union-Find structure
			std::unordered_map<std::string, std::unordered_set<std::string>> groupMap;
			for (const auto& [opID, _] : operatorTimes) {
				std::string root = uf.find(opID);
				groupMap[root].insert(opID);
			}

			// Convert groupMap to vector of groups
			std::vector<std::unordered_set<std::string>> operatorGroups;
			for (const auto& [_, group] : groupMap) {
				operatorGroups.push_back(group);
			}

			// Step 7: Analyze each group for suspicious activity
			/*
			Objective: Determine if the collective mining activity of a group exceeds the defined threshold, indicating potential collusion.
			Logic:
			Group Activity Ratio: Calculates the proportion of blocks mined by the group during anomalous intervals relative to the total
			recent key blocks.
			Threshold Comparison: Flags groups where the activity ratio exceeds groupActivityThreshold (30%).
			Updating Operator Security Info: For each operator in a suspicious group, increments the global anomaly count, logs a detailed report,
			increments the PoW wave attack count, and updates the last reported height.
			Scientific Soundness: Aggregating mining activity across groups provides a mechanism to detect coordinated attacks that individual
			anomaly detection might miss.
			*/

			// Compute dynamic threshold based on historical data before processing groups
			// Compute dynamic threshold based on historical data before processing groups
			double HISTORICAL_GROUP_ACTIVITY_MEAN = getHistoricalGroupActivityMean();
			double HISTORICAL_GROUP_ACTIVITY_STDDEV = getHistoricalGroupActivityStdDev();
			double groupActivityMultiplier = 2.0; // Number of standard deviations above the mean
			double dynamicGroupActivityThreshold = HISTORICAL_GROUP_ACTIVITY_MEAN + (groupActivityMultiplier * HISTORICAL_GROUP_ACTIVITY_STDDEV);
			size_t totalAnomalousBlocks = anomalousIndices.size() * 2; // Each index corresponds to two blocks

			if (!totalAnomalousBlocks)
			{
				return;
			}

			// Clamp the threshold within reasonable bounds
			const double MIN_GROUP_ACTIVITY_THRESHOLD = 0.2; // 20%
			const double MAX_GROUP_ACTIVITY_THRESHOLD = 0.5; // 50%
			dynamicGroupActivityThreshold = std::clamp(dynamicGroupActivityThreshold, MIN_GROUP_ACTIVITY_THRESHOLD, MAX_GROUP_ACTIVITY_THRESHOLD);

			for (const auto& group : operatorGroups) {
				// Compute group's total blocks mined during anomalous intervals
				size_t groupBlocksMined = 0;
				std::unordered_map<std::string, size_t> operatorContribution;
				for (const auto& opID : group) {
					auto opIt = operatorSecurityMap.find(opID);
					if (opIt != operatorSecurityMap.end()) {
						opIt->second->incrementGroupParticipationCount();
						size_t blocksMined = opIt->second->getBlocksMinedDuringAnomalousIntervals();
						groupBlocksMined += blocksMined;
						operatorContribution[opID] = blocksMined;
					}
				}

				// Calculate group activity ratio relative to total anomalous blocks
				double groupActivityRatio = static_cast<double>(groupBlocksMined) / totalAnomalousBlocks;

				if (groupActivityRatio > dynamicGroupActivityThreshold) {
					// Suspicious group detected
					// Generate detailed report with operator contributions
					std::stringstream report;
					report << "Possible collusion detected among operators: ";
					for (const auto& [opID, blocksMined] : operatorContribution) {
						report << opID << " (" << blocksMined << " blocks) ";
					}
					report << "with combined activity ratio of " << (groupActivityRatio * 100)
						<< "% of anomalous blocks over the last " << totalAnomalousBlocks << " anomalous key blocks.";

					// Update security info for each operator in the group
					for (const auto& [opID, blocksMined] : operatorContribution) {
						auto opIt = operatorSecurityMap.find(opID);
						if (opIt != operatorSecurityMap.end()) {
							auto& opInfo = opIt->second;

							// Increment global anomaly count
							opInfo->incrementGlobalAnomalyCount();

							// Check if cooldown period has passed
							if (height - opInfo->getLastReportedAtHeight() >= COOLDOWN_PERIOD_BLOCKS) {
								opInfo->incrementPowWaveAttackCount();
								opInfo->addDetailedReport(report.str());
								opInfo->setLastReportedAtHeight(height);
							}
						}
					}

					// Update historical group activity after processing
					updateHistoricalGroupActivity(groupActivityRatio);
				}
			}




		}

		// Step 8: Analyze individual operator activities during difficulty decreases
		if (difficultyChanged) {
			// Calculate dynamic individualActivityThreshold based on historical data
			double HISTORICAL_INDIVIDUAL_ACTIVITY_MEAN = getHistoricalIndividualActivityMean();
			double HISTORICAL_INDIVIDUAL_ACTIVITY_STDDEV = getHistoricalIndividualActivityStdDev();
			double individualActivityMultiplier = 2.0; // Number of standard deviations above the mean
			/*
			Context:

			in dividualActivityMultiplier: Used in the computeConfidenceLevel method to set dynamic thresholds based on historical data.
			Purpose:

			Dynamic Threshold Calculation: Determines how many standard deviations above the mean are considered significant for flagging anomalies.
			Scientific Rationale:

			Statistical Significance:

			Two Standard Deviations (2σ): Commonly used in statistical analysis to capture approximately 95% of data points under a normal distribution.
			Anomaly Detection: Data points beyond 2σ from the mean are typically considered outliers or anomalies.
			Application in CUSUM and Confidence Levels:

			CUSUM Contribution: Aggregates positive and negative cumulative sums to detect shifts in mining rates.
			Confidence Threshold: Using mean + 2*stddev ensures that only significant deviations influence the confidence level, reducing the likelihood of false positives.

			Recommendation:
			Maintain the Multiplier at 2.0:
			Rationale: Aligns with standard practices in anomaly detection, ensuring that only statistically significant deviations are considered.
			Flexibility: If empirical data suggests the need for higher sensitivity, consider making this multiplier configurable.


			Optional Adjustment Based on Sensitivity Requirements:
			Increase to 3.0: For higher confidence in anomaly detection, reducing false positives.
			Decrease to 1.5: For higher sensitivity, capturing more subtle anomalies at the risk of increased false positives.

			*/
			double dynamicIndividualActivityThreshold = HISTORICAL_INDIVIDUAL_ACTIVITY_MEAN + (individualActivityMultiplier * HISTORICAL_INDIVIDUAL_ACTIVITY_STDDEV);

			// Clamp the threshold within reasonable bounds
			const double MIN_INDIVIDUAL_ACTIVITY_THRESHOLD = 0.4; // 40%
			const double MAX_INDIVIDUAL_ACTIVITY_THRESHOLD = 0.7; // 70%
			dynamicIndividualActivityThreshold = std::clamp(dynamicIndividualActivityThreshold, MIN_INDIVIDUAL_ACTIVITY_THRESHOLD, MAX_INDIVIDUAL_ACTIVITY_THRESHOLD);

			// Calculate dynamic minimum block threshold based on network conditions
			// Example: Set minimum blocks as 5% of total blocks in the window
			const double minBlockPercentage = 0.05; // 5%
			size_t dynamicMinBlocksMined = max(static_cast<size_t>(5), static_cast<size_t>(windowSize * minBlockPercentage));

			for (const auto& [opID, opInfoPtr] : operatorSecurityMap) {
				if (opInfoPtr->getBlocksMined() >= dynamicMinBlocksMined) { // Dynamic minimum block threshold
					double decreaseRatio = static_cast<double>(opInfoPtr->getBlocksMinedDuringDifficultyDecrease()) / opInfoPtr->getBlocksMined();

					// Compute dynamic threshold based on historical data
					// (Already computed before the loop)
					// double HISTORICAL_INDIVIDUAL_ACTIVITY_MEAN = getHistoricalIndividualActivityMean();
					// double HISTORICAL_INDIVIDUAL_ACTIVITY_STDDEV = getHistoricalIndividualActivityStdDev();
					// double individualActivityMultiplier = 2.0; // Number of standard deviations above the mean
					// double dynamicIndividualActivityThreshold = HISTORICAL_INDIVIDUAL_ACTIVITY_MEAN + (individualActivityMultiplier * HISTORICAL_INDIVIDUAL_ACTIVITY_STDDEV);

					// dynamicIndividualActivityThreshold is already computed before the loop

					if (decreaseRatio > dynamicIndividualActivityThreshold) {
						// Operator is suspicious of exploiting difficulty decreases
						// Generate detailed report with operator-specific contributions
						std::stringstream report;
						report << "Operator " << opID << " mined " << opInfoPtr->getBlocksMinedDuringDifficultyDecrease()
							<< " out of " << opInfoPtr->getBlocksMined() << " blocks during difficulty decreases ("
							<< (decreaseRatio * 100) << "%). Possible exploitation of difficulty adjustments.";

						// Update operator security info
						if (height - opInfoPtr->getLastReportedAtHeight() >= COOLDOWN_PERIOD_BLOCKS) {
							opInfoPtr->incrementPowWaveAttackCount();
							opInfoPtr->addDetailedReport(report.str());
							opInfoPtr->setLastReportedAtHeight(height);
						}
					}

					// Update historical individual activity after processing
					updateHistoricalIndividualActivity(decreaseRatio);
				}
			}
		}



		/* Step 9: Detect Operators Causing Difficulty Spikes and Subsequent Block Gaps
		Logic:
		Difficulty Spike Detection: Identifies a significant increase in difficulty (≥50%).
		Block Gap Detection: Identifies a substantial delay in block production (≥3× target interval).
		Operator Activity Analysis: Flags operators who were active before the gap and resumed mining after the gap,
		implying they may have ceased mining during the high-difficulty period.
		Scientific Soundness: This approach effectively targets coordinated attacks where operators manipulate
							the network difficulty to their advantage by controlling block production rates.
		*/
		// Ensure there are at least two key blocks to compare
		if (recentKeyBlocks.size() >= 2) {

			const double difficultySpikeThreshold = 1.5; // 50% increase
			const uint64_t blockGapThreshold = targetInterval * 6; // Gap exceeds 6 times the target interval

			// Only examine the gap between the last two blocks (the current and previous)
			size_t i = recentKeyBlocks.size() - 1;
			auto currentBlock = recentKeyBlocks[i];
			auto previousBlock = recentKeyBlocks[i - 1];

			double currentDifficulty = currentBlock->getHeader()->getDifficulty();
			double previousDifficulty = previousBlock->getHeader()->getDifficulty();
			uint64_t currentTime = currentBlock->getHeader()->getSolvedAtTime();
			uint64_t previousTime = previousBlock->getHeader()->getSolvedAtTime();

			// Variables to track potential manipulation
			bool difficultySpikeDetected = false;
			bool blockGapDetected = false;
			uint64_t gapStartHeight = previousBlock->getHeader()->getHeight();
			uint64_t gapEndHeight = currentBlock->getHeader()->getHeight();
			uint64_t gapStartTime = previousTime;
			uint64_t gapEndTime = currentTime;

			// Check for difficulty spike between the two blocks
			if (previousDifficulty > 0 && (currentDifficulty / previousDifficulty) >= difficultySpikeThreshold) {
				difficultySpikeDetected = true;
			}

			// Check for block gap between the two blocks
			uint64_t timeDiff = currentTime - previousTime;
			if (timeDiff >= blockGapThreshold) {
				blockGapDetected = true;
			}

			// If both a difficulty spike and block gap are detected between the previous and current block
			if (difficultySpikeDetected && blockGapDetected) {
				// Identify operators active before the gap (excluding the gap itself)
				std::unordered_map<std::string, size_t> preGapOperatorActivity;
				for (size_t j = 0; j < i; ++j) {
					auto blk = recentKeyBlocks[j];
					uint64_t blkTime = blk->getHeader()->getSolvedAtTime();
					if (blkTime <= gapStartTime) {
						std::string opID = mTools->bytesToString(blk->getHeader()->getMinersID());
						preGapOperatorActivity[opID]++;
					}
				}

				// Identify operators active after the gap (including the current block)
				std::unordered_map<std::string, size_t> postGapOperatorActivity;
				for (size_t j = i; j < recentKeyBlocks.size(); ++j) {
					auto blk = recentKeyBlocks[j];
					uint64_t blkTime = blk->getHeader()->getSolvedAtTime();
					if (blkTime >= gapEndTime) {
						std::string opID = mTools->bytesToString(blk->getHeader()->getMinersID());
						postGapOperatorActivity[opID]++;
					}
				}

				// Analyze operators who were active before the gap, not during the gap, and resumed after the gap
				for (const auto& [opID, count] : preGapOperatorActivity) {
					// Check if the operator mined during the gap
					bool minedDuringGap = false;
					// Since the gap is between previousTime and currentTime, and we only have two blocks in the gap, there are no blocks mined during the gap
					// So we can assume that operators did not mine during the gap unless we have blocks with timestamps within the gap
					// In this case, minedDuringGap remains false

					// If the operator was active before the gap and resumed after, but did not mine during the gap
					if (!minedDuringGap && postGapOperatorActivity.find(opID) != postGapOperatorActivity.end()) {
						// Operator ceased mining during the gap and resumed
						auto opIt = operatorSecurityMap.find(opID);
						if (opIt != operatorSecurityMap.end()) {
							auto& opInfoPtr = opIt->second;

							// Increment global anomaly count
							opInfoPtr->incrementGlobalAnomalyCount();

							// Generate detailed report
							std::stringstream report;
							report << "Operator " << opID << " was active before a significant block gap (height " << gapStartHeight
								<< ") during a difficulty spike, stopped mining during the gap, and resumed after difficulty decreased."
								<< " Possible manipulation of difficulty through coordinated mining and halting.";

							// Update operator security info
							uint64_t lastReportAtHeight = opInfoPtr->getLastReportedAtHeight();
							if (!lastReportAtHeight || (height - lastReportAtHeight >= COOLDOWN_PERIOD_BLOCKS)) {
								opInfoPtr->incrementPowWaveAttackCount();
								opInfoPtr->addDetailedReport(report.str());
								opInfoPtr->setLastReportedAtHeight(height);
							}
						}
					}
				}
			}
		}


		// Step 10 - compute Threat Score for Operator
		// do this only for current block creator.
		// Define a threshold for the confidence level
		const double confidenceThreshold = 0.5; // Adjust based on testing
		double confidenceLevel = opInfo->computeConfidenceLevel();
		//if (confidenceLevel >= confidenceThreshold) {
			// Operator is suspicious based on confidence level
		//	std::stringstream report;


		//} // End of analysis when at least two key blocks are present
	}
}
// Methods to update historical data using exponential decay
void CBlockchainManager::updateHistoricalGroupActivity(double groupActivityRatio) {
	std::lock_guard<std::mutex> lock(historicalDataMutex);

	// Apply decay to existing statistics
	double decayFactor = 0.99; // Example decay factor (tunable)
	groupActivityMean *= decayFactor;
	groupActivityM2 *= decayFactor;
	groupActivityWeight *= decayFactor;

	// Update with new data point
	groupActivityWeight += 1.0;
	double delta = groupActivityRatio - groupActivityMean;
	groupActivityMean += delta / groupActivityWeight;
	double delta2 = groupActivityRatio - groupActivityMean;
	groupActivityM2 += delta * delta2;
}

void CBlockchainManager::updateHistoricalIndividualActivity(double individualActivityRatio) {
	std::lock_guard<std::mutex> lock(individualHistoricalDataMutex);

	// Apply decay to existing statistics
	double decayFactor = 0.99; // Example decay factor (tunable)
	individualActivityMean *= decayFactor;
	individualActivityM2 *= decayFactor;
	individualActivityWeight *= decayFactor;

	// Update with new data point
	individualActivityWeight += 1.0;
	double delta = individualActivityRatio - individualActivityMean;
	individualActivityMean += delta / individualActivityWeight;
	double delta2 = individualActivityRatio - individualActivityMean;
	individualActivityM2 += delta * delta2;
}
double CBlockchainManager::getHistoricalIndividualActivityMean() {
	std::lock_guard<std::mutex> lock(individualHistoricalDataMutex);
	return individualActivityMean;
}

double CBlockchainManager::getHistoricalIndividualActivityStdDev() {
	std::lock_guard<std::mutex> lock(individualHistoricalDataMutex);
	if (individualActivityWeight <= 1.0) return 0.0;
	return std::sqrt(individualActivityM2 / (individualActivityWeight - 1.0));
}

double CBlockchainManager::calculateStandardDeviation(const std::vector<uint64_t>& intervals, double mean) const {
	double variance = 0.0;
	for (const auto& interval : intervals) {
		double diff = static_cast<double>(interval) - mean;
		variance += diff * diff;
	}
	variance /= intervals.size();
	return std::sqrt(variance);
}
double CBlockchainManager::getHistoricalGroupActivityMean() {
	std::lock_guard<std::mutex> lock(historicalDataMutex);
	return groupActivityMean;
}

double CBlockchainManager::getHistoricalGroupActivityStdDev() {
	std::lock_guard<std::mutex> lock(historicalDataMutex);
	if (groupActivityCount < 2) return 0.0;
	return std::sqrt(groupActivityM2 / (groupActivityWeight - 1.0));
}


/**
 * @brief Retrieves the security report with optional filtering criteria.
 *
 * This method returns a vector of shared pointers to `COperatorSecurityInfo` objects,
 * representing the security analysis results for operators. It accepts optional parameters
 * to filter the report based on the operators' activity within a specified depth (block height range)
 * and minimum offense counts.
 *
 * @param depth Optional. When greater than zero, only operators active within the last 'depth' blocks are included.
 *              Default is 0, which includes all operators.
 * @param minTotalOffenses Optional. The minimum total offenses (timestamp manipulation count + PoW wave attack count)
 *                         an operator must have to be included in the report. Default is 0.
 * @param minTimestampManipulationCount Optional. The minimum timestamp manipulation offenses an operator must have.
 *                                      Default is 0.
 * @param minPowWaveAttackCount Optional. The minimum PoW wave attack offenses an operator must have. Default is 0.
 * @return A vector of shared pointers to `COperatorSecurityInfo` objects that meet the specified criteria,
 *         sorted in descending order of total offenses.
 */
std::vector<std::shared_ptr<COperatorSecurityInfo>> CBlockchainManager::getSecurityReport(
	uint64_t depth,
	uint64_t minTotalOffenses,
	uint64_t minTimestampManipulationCount,
	uint64_t minPowWaveAttackCount)
{
	std::shared_lock<std::shared_mutex> lock(securityMapMutex);

	// Get the current block height
	uint64_t currentHeight = getCachedHeight();

	// Collect operator security info into a vector
	std::vector<std::shared_ptr<COperatorSecurityInfo>> report;
	report.reserve(operatorSecurityMap.size()); // Reserve space for efficiency

	for (const auto& [operatorID, opInfo] : operatorSecurityMap)
	{
		// Apply depth filter if depth > 0
		if (depth > 0)
		{
			uint64_t lastReportedHeight = opInfo->getLastReportedAtHeight();
			if (currentHeight >= lastReportedHeight)
			{
				uint64_t blocksSinceLastReport = currentHeight - lastReportedHeight;
				if (blocksSinceLastReport > depth)
				{
					continue; // Operator not active within the specified depth
				}
			}
			else
			{
				continue; // In case of any inconsistencies, skip this operator
			}
		}

		// Apply minimum offense counts
		int totalOffenses = opInfo->getTimestampManipulationCount() + opInfo->getPowWaveAttackCount();
		if (totalOffenses < minTotalOffenses)
		{
			continue; // Does not meet the minimum total offenses
		}

		if (opInfo->getTimestampManipulationCount() < minTimestampManipulationCount)
		{
			continue; // Does not meet the minimum timestamp manipulation offenses
		}

		if (opInfo->getPowWaveAttackCount() < minPowWaveAttackCount)
		{
			continue; // Does not meet the minimum PoW wave attack offenses
		}

		// Operator meets all criteria, add to the report
		report.push_back(opInfo);
	}

	// Sort the report with the most offending operators at the beginning
	std::sort(report.begin(), report.end(),
		[](const std::shared_ptr<COperatorSecurityInfo>& a, const std::shared_ptr<COperatorSecurityInfo>& b) {
			int aTotalOffenses = a->getTimestampManipulationCount() + a->getPowWaveAttackCount();
			int bTotalOffenses = b->getTimestampManipulationCount() + b->getPowWaveAttackCount();
			return aTotalOffenses > bTotalOffenses;
		});

	return report;
}



std::shared_ptr<COperatorSecurityInfo> CBlockchainManager::getSecurityReportForOperator(const std::string& operatorID)
{
	std::shared_lock<std::shared_mutex> lock(securityMapMutex);

	auto it = operatorSecurityMap.find(operatorID);
	if (it != operatorSecurityMap.end())
	{
		return it->second;
	}
	else
	{
		return std::make_shared<COperatorSecurityInfo>(operatorID); // Return an empty report with the operatorID
	}
}



// Operators Security Assessment - END

/// <summary>
/// Retrieves a block at a specified depth from the blockchain.
/// If isKeyDepth is specified, the function proceeds as if there were only key-blocks.
/// The retrieval is based on the specified chain proof type.
/// </summary>
/// <param name="depth">The depth of the block to retrieve.</param>
/// <param name="isKeyDepth">If true, only consider key blocks when calculating depth.</param>
/// <param name="chain">The chain to query (verified, heaviest, etc.). Defaults to verified.</param>
/// <returns>Shared pointer to the CBlock at the specified depth, or nullptr if not found.</returns>
std::shared_ptr<CBlock> CBlockchainManager::getBlockAtDepth(uint64_t depth, bool isKeyDepth, eChainProof::eChainProof chain)
{

	if (isKeyDepth && !(chain == eChainProof::verified || chain == eChainProof::verifiedCached))
	{
		mTools->logEvent("Target chain key-height/depth is not supported by getBlockAtDepth() method.", eLogEntryCategory::localSystem, 10, eLogEntryType::failure);
		// to support 
		return nullptr;
	}

	// Extremely Fast Hot-Storage Look-up - BEGIN
	/**
	 * Fast Cache Lookup Process:
	 * 1. Utilize the flat cache (mBlockCacheFlat or mKeyBlockCacheFlat) for rapid block retrieval.
	 * 2. The flat cache provides O(1) access time, significantly faster than traversing the blockchain.
	 *
	 * Benefits:
	 * - Dramatically reduces retrieval time for recently accessed or frequently used blocks.
	 * - Efficient for both regular and key block depths across different chain types.
	 *
	 * Note: The flat cache is part of the hot storage, containing in-memory references to blocks.
	 *       It's particularly effective for recent blocks or during periods of high repeated access.
	 */
	std::shared_ptr<CBlock> fastBlock = getBlockFlatCache(depth, true, isKeyDepth, chain);
	if (fastBlock)
	{
		// Block found in fast cache, return immediately
		return fastBlock;
	}
	// Extremely Fast Hot-Storage Look-up - END

	// If we reach here, the block was not found in the fast cache.
	// The method would continue with slower, traditional block retrieval methods.

	// Local Variables - BEGIN
	std::shared_ptr<CBlock> current = nullptr;
	std::shared_ptr<CBlock> leader = nullptr;
	eBlockInstantiationResult::eBlockInstantiationResult res;
	uint64_t currentDepth = 0;
	size_t currentHeight = 0;
	size_t cacheSize = getMaxNrOfPrunedBlocksToKeepInMemory();
	bool currentIsKeyBlock = false;
	bool wasInitialBlockKeyBlock = false;
	bool isFirstPass = true;
	std::vector<std::vector<uint8_t>>* targetPath = nullptr;
	ExclusiveWorkerMutex* targetMutex = nullptr;
	// Local Variables - END

	// Chain Selection - BEGIN
	switch (chain)
	{
	case eChainProof::verifiedCached:
		targetPath = &mVerifiedPathDouble;
		targetMutex = &mVerifiedPathDoubleGuardian;
		break;
	case eChainProof::heaviestCached:
		targetPath = &mHeaviestPathDouble;
		targetMutex = &mHeaviestPathDoubleGuardian;
		break;
	case eChainProof::verified:
		targetPath = &mVerifiedPath;
		targetMutex = &mVerifiedPathGuardian;
		break;
	case eChainProof::heaviest:
		targetPath = &mHeaviestPath;
		targetMutex = &mHeaviestPathGuardian;
		break;
	default:
		return nullptr; // Invalid chain type
	}
	// Chain Selection - END

	// Initialization and Validation - BEGIN
	{
		if (chain == eChainProof::verified)
		{
			leader = getLeader();
		}
		else if (chain == eChainProof::verifiedCached)
		{
			leader = getCachedLeader();
		}

		current = leader;
		if (current)
		{
			currentHeight = current->getHeader()->getHeight();
		}
	}

	if (currentHeight == 0 || depth > (currentHeight - 1)) {
		return nullptr;
	}
	// Initialization and Validation - END

	// Hot Storage Check - BEGIN
	if ((chain == eChainProof::verified || chain == eChainProof::verifiedCached) && cacheSize > 0 && depth <= cacheSize - 1) {
		// Use Hot Storage
		if (current->getHeader()->isKeyBlock()) {
			wasInitialBlockKeyBlock = true;
		}

		while (current != nullptr) {
			currentIsKeyBlock = current->getHeader()->isKeyBlock();

			if (currentDepth == depth) {
				if (isKeyDepth) {
					if (currentIsKeyBlock) {
						return current; // Only if the current block is a leader at the desired key-depth
					}
				}
				else {
					return current; // We're interested in data-blocks as well
				}
			}

			// Fetch Parent - BEGIN
			if (!isKeyDepth) {
				current = current->getParent(res, true, true, false, shared_from_this()); // Fetch any ancestor block
			}
			else {
				current = getKeyBlockForBlock(current); // We're only interested in key-blocks
			}
			// Fetch Parent - END

			if (!current) {
				break; // Abort if no parent
			}

			if (!(isKeyDepth && isFirstPass && !wasInitialBlockKeyBlock)) {
				// We do not want to increment depth if the initial block was not a key block and it's a first pass.
				// That is because a call to getKeyBlockForBlock(current) effectively just returned a key-block at key-depth equal to 0.
				currentDepth++;
			}
			isFirstPass = false;
		}

		if (currentDepth == depth) {
			return current;
		}
	}
	// Hot Storage Check - END

	// Cold Storage Access - BEGIN
	std::shared_ptr<CBlock> coldStorageBlock = nullptr;
	std::vector<uint8_t> blockHash;
	size_t pathSize = 0;

	// Briefly lock the mutex to copy necessary data
	{
		std::lock_guard<ExclusiveWorkerMutex> lock(*targetMutex);
		pathSize = targetPath->size();
		if (pathSize > depth) {
			blockHash = (*targetPath)[pathSize - 1 - depth];
		}
	}

	if (!blockHash.empty()) {
		if (!isKeyDepth) {
			// Use selected chain path to get block from Cold Storage
			coldStorageBlock = getBlockByHash(blockHash, res, true);
		}
		else {
			// Use dedicated dictionary for key depth
			std::vector<uint8_t> bID = getBlockIDAtKeyHeight(currentHeight - depth, chain);
			if (!bID.empty()) {
				coldStorageBlock = getBlockByHash(bID, res, true);
			}
		}
	}
	// Cold Storage Access - END

	return coldStorageBlock;
}

bool CBlockchainManager::syncChainProofToColdStorage(eChainProof::eChainProof which)
{

	auto flashManager = FlashingProgressManager(
		mTools,
		"Syncing chain-proofs to Cold Storage..",
		[]() { /* Optional completion callback */ }
	);

	auto progress = flashManager.createScoped(true,900);
	progress.updateText("Syncing chain-proofs to Cold Storage..");
	bool result = false;
	switch (which)
	{
	case eChainProof::verified:
		mVerifiedPathGuardian.lock();

		// Create progress manager for operation feedback

		result = setChainProof(mVerifiedChainProof, which, true);

		if (!result)
		{
			mVerifiedPathGuardian.unlock();
			return false;
		}

		result = setPath(mVerifiedPath, which, true);
		mVerifiedPathGuardian.unlock();
		break;
	case eChainProof::verifiedCached:
		break;
	case eChainProof::heaviest:

		mHeaviestPathGuardian.lock();
		result = setChainProof(mHeaviestChainProof, which, true);

		if (!result)
		{
			mHeaviestPathGuardian.unlock();
			return false;
		}

		result = setPath(mHeaviestPath, which, true);
		mHeaviestPathGuardian.unlock();
		break;
	case eChainProof::heaviestCached:
		break;
	default:
		break;
	}

	return result;

}
/// <summary>
/// Sets the current leader. Takes care of both the leader and KEY-BLOCK leader.
/// If block is a data-block, its corresponding key-block would be retrieved by traversing
/// blocks backwards starting from its parent. It is assumed all the previous block are available
/// in Cold Storage. (this should have been verified previously during block verification).
/// Thus, there's no need to call setLeader separately for key-block and data-block. On invocation is always
/// enough.
/// 
/// IF anything goes wrong, the function returns FALSE.
/// </summary>
/// <param name="block"></param>
/// <returns></returns>
bool CBlockchainManager::setLeader(std::shared_ptr<CBlock> block, size_t heaviestChainProofSize, const std::vector<std::string>& log)
{


	uint64_t coldStorageMayBeBehindCount = 30;
	if (block == nullptr || block->getHeader() == nullptr) {
		const_cast<std::vector<std::string>& >(log).push_back("ERROR: Cannot set leader - block or block header is null");
		return false;
	}


	std::shared_ptr <CTools> tools = getTools();
	sync::SynchronizedLocker lock(
		sync::LockingPolicy::SequenceOrdered,
		mChainGuardian,
		mVerifiedPathGuardian,
		mLeaderGuardian
	);
	//LOCAL VARIABLES - BEGIN
	bool parentFound = false;
	uint64_t parentFoundAtIndex = 0;
	std::vector<uint8_t> currentleaderID;
	std::shared_ptr<CBlock> current;
	std::shared_ptr<CBlock> previous;
	std::vector<uint8_t> parentID = block->getHeader()->getParentID();
	bool rebuildCache = false;
	//LOCAL VARIABLES - END

	tools->writeLine("Setting the new current Leader Block.");

	block->setMainCacheMember();

	//Note: let us preserve the content of the in-RAM cache as much as possible
	//the cache ends with the current leader

	//try to find the parent within the cache, so that we can truncate the chain (delete the (Parent+1)-Leader subchain from RAM)
	//and append the block as leader.



	if (mLeader != nullptr)
	{

		currentleaderID = mLeader->getID();
		assertGN(mVerifiedPath.size() > 0 && tools->compareByteVectors(currentleaderID, mVerifiedPath[mVerifiedPath.size() - 1]));

		if (tools->compareByteVectors(block->getID(), currentleaderID))
		{
			return true;//the block is set as leader already. (optimization)

		}
	}

	//UPDATE THE IN-HotStorage block cache - BEGIN
	if (mLeader != nullptr && !block->isGenesis())
	{
		current = mLeader;

		while (current != nullptr)
		{
			//search for parent within the HotStorage (RAM) Block Cache.
			std::vector<uint8_t> HSID = current->getHotStorageID();
			std::vector<uint8_t> ID = current->getID();
			assertGN(tools->compareByteVectors(HSID, ID));

			if (tools->compareByteVectors(current->getHotStorageID(), parentID))
			{
				parentFound = true;
				break;
			}
			current = current->getParentPtr();
			parentFoundAtIndex++;
		}

		if (!parentFound && mLeader != nullptr)
		{
			clearBlockCache();
			//mLeader->freePath(false, getTools());//parent was NOT found.- we need to free the entire cache.
			rebuildCache = true;
		}
		//AND rebuild it afterwards

		else if (parentFound)
		{
			//if index == 0 then we are trying to extend the current chain; no need to remove anything from RAM
			bool newBlockInjected = false;

			assertGN(std::memcmp(current->getHotStorageID().data(), parentID.data(), 32) == 0);//is it really the searched for parent?
			std::shared_ptr<CBlock> foundParent = current;

			//parent WAS found. free the consecutive sub-chain from RAM.

			std::shared_ptr<CBlock> next = current->getNext(); // current is the looked for parent right now
			current->setNext(nullptr);

			while (next != nullptr)
			{
				previous = next;
				previous->prepareForRemoval();
				next = next->getNext();
			}

			//inject the new block as parent's child
			foundParent->setNext(block);//<= affects the dynamic world-view only.
			//^ data in Cold Storage will be affected later on in updatePathWithLeader().
			//update cached total PoW

			//Warning- below it is important co call getTotalWorkDOne() on block not on header as the earlier is capable of 
			//recalculating total cumulative work if needed (should the total work on Leader be not set as of yet, and it should be
			//during verification of the Verified Chain Proof and generation of block cache). That is when values from the
			//verified chain proof headers' are injected into those within of the cache as it is built. We do so to eliminate
			//the need for the entire process to be taking place right below. BUT should the need arise, the invocation of
			// the below function oundParent->getTotalWorkDone() is fully capable of reconstructing the total cumulative work done
			// on the grounds of its own. Then the value attached to the newly assigned Leader is simply incremented by the amount of work
			// just performed on the very block alone. Notice that Operator may decide to skip and thus 
			// disable initial validation of the Verified Chain-Proof.


			CBlockVerificationResult bfr;

			block->getHeader()->setTotalDiffField(foundParent->getTotalWorkDone(bfr) + block->getHeader()->getDifficulty());
			std::vector<uint8_t> formerParentID = block->getHeader()->getParentID();
			block->getHeader()->setParent(foundParent);
			assertGN(std::memcmp(formerParentID.data(), block->getHeader()->getParentID().data(), 32) == 0);

		}

	}
	//UPDATE THE IN-HotStorage block cache - END



	//Now, affect the Cold Storage, effectively by altering the Verified Chain Proof and Verified Longest Paths respectively.
	//Should anything go wrong down below, the processing of this block would have no persistent effect.
	//Do notice that mLeader is set only once the below succeeds.


	//Optimization - BEGIN
	//we allow the cold-storage to be behind a certain amount of blocks as known in Hot-Storage.
	incVPInColdStorageBehindCount();
	uint64_t now = std::time(0);
	//bool updateChainProofInColdStorage = ((getVPInColdStorageBehindCount() > coldStorageMayBeBehindCount &&(
	//	(now - getChainProofCSSyncTime(eChainProof::verified)) > CGlobalSecSettings::getSyncVerifiedChainProofMaxInterval()))? true : false);
	bool updateChainProofInColdStorage = false;
	if (updateChainProofInColdStorage)
	{
		tools->writeLine("Doing a " + tools->getColoredString("Cold-Storage", eColor::lightGreen) + " Verified Path and Verified Chain-Proof update.");
		clearVPInColdStorageBehindCount();
	}
	else
	{
		tools->writeLine("Doing a " + tools->getColoredString("Hot-Storage", eColor::orange) + " Verified Path and Verified Chain-Proof update.");
	}
	//Optimization - END

	if (!updatePathWithLeader(block, eChainProof::verified, updateChainProofInColdStorage)) {
		const_cast<std::vector<std::string>&>(log).push_back("ERROR: Failed to update path with new leader block");
		return false;
	}
	else
	{
		//UPDATE SUCCEEDED - BEGIN

		// Update Heaviest Chain Proof - BEGIN
		//---------------------------------------------------
		// (A) Attempt to extend the Heaviest Chain if possible
		//---------------------------------------------------
		if (block && !block->isGenesis())
		{
			// Acquire lock to access the heaviest-path data
			std::scoped_lock<ExclusiveWorkerMutex> lock(mHeaviestPathGuardian);

			if (!mHeaviestPath.empty())
			{
				// Compare the parent of this block with the last block in the heaviest path
				// Remember that mHeaviestPath is a list/vec of block-hashes
				std::vector<uint8_t> lastOnHeaviestPath = mHeaviestPath.back();
				// The newly accepted block's parent:
				std::vector<uint8_t> parentOfNew = block->getHeader()->getParentID();

				// If the new block's parent is the last block on the heaviest path => we can extend it
				if (mTools->compareByteVectors(lastOnHeaviestPath, parentOfNew))
				{
					// We push back the newly accepted block's ID to the path
					std::vector<uint8_t> newBlockID = block->getID();
					mHeaviestPath.push_back(newBlockID);
					std::shared_ptr<CBlockHeader> newBH = block->getHeader();
					// We also push back the block-header to the chain-proof
					{
						std::scoped_lock<ExclusiveWorkerMutex> lock(mVerifiedPathGuardian);
						mHeaviestChainProof.push_back(mVerifiedChainProof.back()); // under the assumption that latest serialized just appended block header is last in mVerifiedChainProof
					}

					// Make sure we keep the cumulative PoWs in sync:
					// The new cumulative PoW = old cumulative PoW + this block's difficulty
					uint64_t newCumulativePoW = mHeaviestChainProofCumulativePoWs.back();


					newCumulativePoW += (uint64_t)newBH->getDifficulty();
					CBlockVerificationResult valRes;
					assert(newCumulativePoW == block->getTotalWorkDone(valRes)); // verify cumulative work done on this sub-chain to be coherent against what maintained in cache
					mHeaviestChainProofCumulativePoWs.push_back(newCumulativePoW);



					// As needed, call updateHeaviestPathLeaders() or relevant method 
					// to ensure your local node's "heaviest chain leader" metadata is updated
					updateHeaviestPathLeaders();

				

					// Also update the chain-proof "leading" block ID, total difficulty, etc
					setCachedHeaviestHeight(newBH->getHeight());
					setHeaviestChainProofKeyLeader(newBH);
					setHeaviestChainProofLeadBlockID(newBlockID);
					mHeaviestPathDoubleGuardian.lock();
					mHeaviestPathDouble.push_back(newBlockID);
					mHeaviestPathDoubleGuardian.unlock();
					setHeaviestChainProofTotalDifficulty(newCumulativePoW);

					// Optionally log the event
					mTools->writeLine("Extended the Heaviest Path with the newly accepted block: " +
						mTools->base58CheckEncode(newBlockID), eColor::lightGreen);
				}
				else
				{
					// If the new block's parent != last on the heaviest path, do nothing special here
					// because it might be a side chain or a "non-heaviest" chain extension
					mTools->writeLine("Block is not an immediate child of the Heaviest Path tip.",
						eColor::lightPink);
				}
			}
		}

		// Update Heaviest Chain Proof - END


		uint64_t mCD = 0;
		std::shared_ptr<CBlockHeader> ckl;
		bool cgb;
		std::vector<uint64_t> pows;

		//just go ahead and check it the resulting Verified Chain-proof looks good, going back to previous block only.
		eChainProofValidationResult::eChainProofValidationResult result = verifyChainProof(mVerifiedChainProof, mCD, true, false, ckl, cgb, pows, ckl, (block->isGenesis() ? 0 : block->getHeader()->getHeight() - 1), false, false, 100, false);
		
		
		// Negative (0) is POSITIVE (enum). Positive is Wrong.
		if (result) // do not require checkpoints to be met by the verified chain proof; 
		{

			const_cast<std::vector<std::string>&>(log).push_back("ERROR: Chain proof verification failed after leader update - result code: " + std::to_string(result));

			//that comes in handy when prepping nodes for an upcoming hard-fork.
			return false;//todo: we might want to 'revert' to the previous version of path as otherwise. the current Verified Path
			//would be out of sync with the current leader. All in all this should never happen under the assumption that updatePathWithLeader() produced correct results
			//and under same assumptions in regards to verifyChainProof(). Thus for now, we avoid mem-copying the entire path for backup.
		}
		mLeader = block;


		// Update Key_Height -> block_id index
		setBlockIDAtKeyHeight(block->getHeader()->getKeyHeight(), block->getID());
		// Truncate Level 1 Block Indexes - BEGIN
		// [ Rationale ]: indexes may be out of sync after self repairs.
		truncateKeyBlockIDsFromKeyHeight(mLeader->getHeader()->getKeyHeight() + 1, eChainProof::verified);
		//truncateKeyBlockIDsFromKeyHeight(mHeaviestHeight + 1, eChainProof::heaviest);
		// Truncate Level 1 Block Indexes - END


		//Verified Chain-Proof Cache - BEGIN

		//these caches may be used ONLY for incoming data requests. These may NOT be used during local Flow processing.
		mVerifiedPathDoubleGuardian.lock();
		mVerifiedChainProofDouble = mVerifiedChainProof;
		mVerifiedPathDouble = mVerifiedPath;
		mVerifiedPathDoubleGuardian.unlock();

		setCachedLeader(mLeader);
		//Verified Chain-Proof Cache - END

		if (block->getHeader()->isKeyBlock())
		{
			mKeyLeader = block;
			updateMinDifficultyCoefficients();
			updateMinERGPrice();
		}
		else
		{
			//the block is NOT a key-block, we need to fetch its corresponding parental key-block
			//let us check if it's available. (must be - this should have been verified ALREADY)
			mKeyLeader = getKeyBlockForBlock(block);
			mCachedKeyLeader = mKeyLeader;

			assertGN(mKeyLeader != nullptr);
		}

		assertGN(mVerifiedPath.size() > 0 && tools->compareByteVectors(block->getID(), mVerifiedPath[mVerifiedPath.size() - 1]));

		// Cache Support - BEGIN

		// Indexes Support - BEGIN

		// Flat Index Cache Support - BEGIN


		// Update Flat Cache - BEGIN
		eSetBlockCacheResult::eSetBlockCacheResult resCPR = setBlockFlatCache(block);

		if (!(eSetBlockCacheResult::Success || eSetBlockCacheResult::EmptyCacheSuccess))
		{
			std::stringstream ssCPR;
			ssCPR << "Unable to populate flat block cache at height ";
			ssCPR << std::to_string(mLeader ? mLeader->getHeader()->getHeight() : 0)
				<< " " << "Reason: " << mTools->blockCachingResultToString(resCPR);
			tools->logEvent(ssCPR.str(), "Leader Election", eLogEntryCategory::localSystem, 10, eLogEntryType::failure);
		}
		// Update Flat Cache - END

		// Flat Index Cache Support - END

		// Block-ID -> Block Height Index Support - BEGIN
		if (!addToBlockIDHeightMap(block->getID(), block->getHeader()->getHeight()))//  Flat block Index
		{
			const_cast<std::vector<std::string>&>(log).push_back("ERROR: Failed to populate [Block ID] -> [Block Height] Index at height " +
				std::to_string(mLeader ? mLeader->getHeader()->getHeight() : 0));
			tools->logEvent("Unable to populate the [Block ID] -> [Block Height] Index at height " + std::to_string(mLeader ? mLeader->getHeader()->getHeight() : 0), "Leader Election", eLogEntryCategory::localSystem, 10, eLogEntryType::failure);
			return false;
		}
		// Block-ID -> Block Height Index Support - END

		// Indexes Support - END
		truncateFlatCache(block->getHeader()->getHeight() + 1);

		if (!prepareCacheMT(false)) // we always need to ensure that block-cache is of a sufficient depth.
		{ // single threaded as a fallback algorithm
			prepareCache(false);
		}
		// Cache Support - END

		//UPDATE SUCCEEDED - END
	}

	setCachedHeight(block->getHeader()->getHeight());
	setCachedHeight(block->getHeader()->getKeyHeight(), true);
	CBlockVerificationResult res;
	setVerifiedChainProofTotalDifficulty(block->getTotalWorkDone(res));
	if (heaviestChainProofSize)
	{
		double percentage;
		if (mVerifiedChainProof.size() == mHeaviestChainProof.size()) {
			percentage = 100.0;
		}
		else {
			percentage = (100.0 * mVerifiedChainProof.size()) / mHeaviestChainProof.size();
			if (percentage > 99.99 && percentage < 100) {
				percentage = 99.99;
			}
		}

		setSyncPercentage(percentage);
	}
	setAchievablePerspectiveAtIndex(block->getHeader()->getHeight());
	setJustAppendedLeader(true);
	return true;

}


void  CBlockchainManager::setJustAppendedLeader(bool doIt)
{
	std::unique_lock lock(mSharedFieldsGuardian);
	mJustAppendedLeader = doIt;
}

bool  CBlockchainManager::getJustAppendedLeader()
{
	std::lock_guard<std::mutex> lock(mFieldsGuardian);
	return mJustAppendedLeader;
}
uint64_t CBlockchainManager::getCachedHeaviestHeight()
{
	{
		std::lock_guard hpd(mHeaviestPathDoubleGuardian);
		uint64_t length = mHeaviestPathDouble.size();

		if (length)
		{
			return length - 1;
		}
		else
		{
			return 0;
		}

	}
}
void CBlockchainManager::setCachedHeaviestHeight(uint64_t height)
{
	std::unique_lock lock(mSharedFieldsGuardian);
	mHeaviestHeight = height;
}

uint64_t CBlockchainManager::getCachedHeight(bool keyHeight)
{
	std::shared_lock lock(mSharedFieldsGuardian);
	if (keyHeight)
	{
		return mCurrentKeyHeight;
	}
	else {
		return mCurrentHeight;
	}
	return 0;
}
void CBlockchainManager::setCachedHeight(uint64_t value, bool keyHeight)
{
	std::unique_lock lock(mSharedFieldsGuardian);

	if (keyHeight)
	{
		mCurrentKeyHeight = value;
	}
	else {
		mCurrentHeight = value;
	}
}

/// <summary>
/// The function is to assess whether we have a chance of winning the proof of work race.
/// </summary>
/// <returns></returns>
bool CBlockchainManager::doIhaveAChanceOfWinning()
{
	//Local Variables - BEGIN
	uint64_t currentKeyHeight = getCachedHeight(true);
	uint64_t totalHeaviestChainProofDifficulty = getHeaviestChainProofTotalDifficulty();
	uint64_t totalVerifiedChainProofDifficulty = getVerifiedChainProofTotalDifficulty();
	uint64_t heaviestChainProofLeaderKeyHeight = 0;
	bool toRet = true;
	std::shared_ptr<CBlockHeader> heaviestChainProofLeader = getHeaviestChainProofKeyLeader();
	//Local Variables - END

	//Operational Logic - BEGIN
	if (heaviestChainProofLeader)
	{
		heaviestChainProofLeaderKeyHeight = heaviestChainProofLeader->getKeyHeight();
	}
	//if we are to alter more than 10% of the history - follow the others.
	if (totalHeaviestChainProofDifficulty)
	{
		if (heaviestChainProofLeaderKeyHeight > 10 && (((double)totalVerifiedChainProofDifficulty / (double)totalHeaviestChainProofDifficulty) * (double)100) < 90)
		{
			toRet = false;
		}

	}

	if ((heaviestChainProofLeaderKeyHeight > currentKeyHeight) && (heaviestChainProofLeaderKeyHeight - currentKeyHeight) > 4)
		toRet = false;

	if (!toRet && getIsSyncStuck())
	{
		toRet = true;
	}

	return toRet;
	//Operational Logic - END
}

uint64_t CBlockchainManager::getCachedBlockQueueLength()
{
	std::lock_guard<std::mutex> lock(mFieldsGuardian);
	return mCachedBlockQueueLength;
}

void CBlockchainManager::setCachedBlockQueueLength(uint64_t length)
{
	std::lock_guard<std::mutex> lock(mFieldsGuardian);
	mCachedBlockQueueLength = length;
}

//Block Blacklisting - BEGIN

/**
 * @brief Blacklists a given block identifier for a specific duration.
 *
 * This function adds the provided block identifier to the blacklist
 * and sets it to expire after the given duration in seconds. If the block
 * is already blacklisted, its blacklist expiration is updated to the new
 * duration. If the block isn't blacklisted, it is added with the specified
 * duration.
 *
 * @param blockIdentifier The unique identifier of the block to be blacklisted.
 * @param seconds The duration in seconds for which the block should remain blacklisted.
 * @return True if the block was added to the blacklist or its duration was updated,
 *         false if the block was already present with the same expiration time.
 */
bool CBlockchainManager::blacklistBlock(const std::vector<uint8_t>& blockIdentifier, uint64_t seconds) {
	std::shared_ptr<CTools> tools = getTools();

	if (!seconds)
	{
		seconds = CGlobalSecSettings::getDefaultBlockBlacklistTime();
	}

	tools->logEvent("Blacklisting block " + tools->base58CheckEncode(blockIdentifier) + " for " + tools->secondsToFormattedString(seconds), eLogEntryCategory::VM, 100,
		eLogEntryType::warning, eColor::lightPink);

	std::lock_guard<std::mutex> lock(mBlacklistedBlocksGuardian);
	auto expirationTime = std::chrono::system_clock::now() + std::chrono::seconds(seconds);
	auto result = mBlacklistedBlocks.emplace(blockIdentifier, expirationTime);
	return result.second;
}


// Query a block identifier from the black list
bool CBlockchainManager::isBlacklisted(const std::vector<uint8_t>& blockIdentifier) {
	std::lock_guard<std::mutex> lock(mBlacklistedBlocksGuardian);
	auto it = mBlacklistedBlocks.find(blockIdentifier);

	if (it == mBlacklistedBlocks.end()) {
		return false;  // block is not blacklisted
	}

	// Check if the block's blacklist period has expired
	if (it->second <= std::chrono::system_clock::now()) {
		mBlacklistedBlocks.erase(it);  // Remove the expired entry
		return false;
	}

	return true;
}

// Removal of a block identifier from the black list
void CBlockchainManager::unblacklistBlock(const std::vector<uint8_t>& blockIdentifier) {
	std::lock_guard<std::mutex> lock(mBlacklistedBlocksGuardian);
	mBlacklistedBlocks.erase(blockIdentifier);
}

//Block Blacklisting - END

uint64_t CBlockchainManager::getDepth()
{
	return getHeight();
}

/// <summary>
/// Validates an incoming block.
/// Answers: Given the same set of transactions, verifiables and parent block as input, 
/// would be come up with the same State Trie?
/// </summary>
/// <param name="block"></param>
/// <returns></returns>

std::shared_ptr<CGridScriptCompiler> CBlockchainManager::getCompiler()
{
	return mCompiler;
}

eBlockchainMode::eBlockchainMode CBlockchainManager::getMode()
{
	std::lock_guard<std::mutex> lock1(mModeGuardian);
	return mMode;
}


uint64_t CBlockchainManager::getKnownStateDomainsCount()
{
	return mLiveTransactionsManager->getStateDomainManager()->getKnownDomainsCount();
}

uint64_t CBlockchainManager::getForksCount()
{
	std::lock_guard<std::mutex> lock(mStatisticsDataGuardian);

	return mForksCount;
}

std::string CBlockchainManager::translateVerificationResult(eBlockVerificationResult::eBlockVerificationResult res)
{
	switch (res)
	{
	case eBlockVerificationResult::prevalidationOnly:
		return "This was a Pre-Validaiton";
	case eBlockVerificationResult::invalidSecurityExecutionContext:
		return "Invalid Security Execution Context";
		break;
	case eBlockVerificationResult::notAForkLeadingBlock:
		return "not the anticipated Hard Fork Leading Block";
		break;
	case  eBlockVerificationResult::eBlockVerificationResult::heightNotToBeConsidered:
		return "at height which cannot be considered as Leader (as of now)";
		break;
	case  eBlockVerificationResult::eBlockVerificationResult::unableToStartFlow:
		return "Unable to start the Flow";
		break;
	case  eBlockVerificationResult::eBlockVerificationResult::timeDiffExceeded:
		return "The time-difference between the block proposal and its parent is too high!";
		break;
	case  eBlockVerificationResult::eBlockVerificationResult::unknownBlockOnPath:
		return "unknown block on  the verification path";
		break;
	case eBlockVerificationResult::eBlockVerificationResult::insufficientPoW:
		return "Insufficient PoW";
		break;
	case eBlockVerificationResult::eBlockVerificationResult::excessivePoW:
		return "Excessive PoW";
		break;
	case eBlockVerificationResult::eBlockVerificationResult::insufficientTotalPoW:
		return "Insufficient Total PoW";
		break;
	case eBlockVerificationResult::eBlockVerificationResult::invalid:
		return "invalid";
		break;
	case eBlockVerificationResult::eBlockVerificationResult::parentPerspectiveUnavailavble:
		return "Parent Perspective Unavailable";
		break;
	case eBlockVerificationResult::eBlockVerificationResult::unknownParent:
		return "unknown Parent";
		break;
	case eBlockVerificationResult::eBlockVerificationResult::valid:
		return "valid";
		break;
	case eBlockVerificationResult::eBlockVerificationResult::inconsistentFinalPerspective:
		return "Inconsistent Final Perspective";
		break;

	case eBlockVerificationResult::eBlockVerificationResult::keyParentUnknown:
		return "Parent KEY-BLOCK is Unknown";
		break;
	case eBlockVerificationResult::eBlockVerificationResult::sigMissing:
		return "Signature is missing";
		break;
	case eBlockVerificationResult::eBlockVerificationResult::pubKeyMissing:
		return "PubKey missing";
		break;
	case eBlockVerificationResult::eBlockVerificationResult::invalidSignature:
		return "Invalid Signature";
		break;

	case eBlockVerificationResult::eBlockVerificationResult::headerMissing:
		return "Header Missing";
		break;
	case eBlockVerificationResult::eBlockVerificationResult::criticalFailure:
		return "Critical Failure";
		break;
	case eBlockVerificationResult::eBlockVerificationResult::verifiableMissing:
		return "Verifiable Missing";
		break;
	case eBlockVerificationResult::eBlockVerificationResult::transactionMissing:
		return "Transaction Missing";
		break;
	case eBlockVerificationResult::eBlockVerificationResult::receiptMissing:
		return "Receipt Missing";
		break;
	case eBlockVerificationResult::eBlockVerificationResult::flowInvalid:
		return "Invalid Flow";
		break;

	case  eBlockVerificationResult::eBlockVerificationResult::noCorrespondingKeyBlock:
		return "No Key-block for data-block";
		break;

	case  eBlockVerificationResult::eBlockVerificationResult::invalidBlockHeight:
		return "The reported block height was INVALID";
		break;
	case  eBlockVerificationResult::eBlockVerificationResult::rewardVerifiableMissing:
		return "One of the reward-verifiables was MISSING";
		break;
	case  eBlockVerificationResult::eBlockVerificationResult::invalidKeyHeight:
		return "invalid reported key-height for this data-block";
		break;
	case  eBlockVerificationResult::eBlockVerificationResult::leaderAttemptedADoubleSpendAttack:
		return "Leader attempted to perform a double-spend attack (!). This will be reported to other nodes..";
		break;
	case  eBlockVerificationResult::eBlockVerificationResult::parentNotALeaderInVerifiedChainProof:
		return "block is not a direct offspring of a leader in the Verified Chain-Proof.";
		break;


	default:
		return "unknown";
	}
	return std::string();
}

std::shared_ptr<CTools> CBlockchainManager::getTools()
{
	std::lock_guard<std::mutex> lock(mToolsGuardian);
	return mTools;
}

bool CBlockchainManager::getIsValidPointer()
{
	std::lock_guard<std::mutex> lock(mIsValidPointerGuardian);
	return mIsValidPointer;
}

void CBlockchainManager::invalidatePointer()
{
	std::lock_guard<std::mutex> lock(mIsValidPointerGuardian);
	mIsValidPointer = false;
}

bool CBlockchainManager::isBlockInProcessingQeueue(std::vector<uint8_t>& blockID)
{
	if (blockID.size() != 32)
		return false;

	std::lock_guard<std::recursive_mutex> lock(blockQueueGuardian);
	std::shared_ptr<CBlockHeader> header;
	std::shared_ptr<CTools> tools = getTools();

	for (auto it = mBlockQueue.cbegin(); it != mBlockQueue.cend(); ++it)
	{
		header = (*it)->getHeader();

		if (header)
		{
			if (tools->compareByteVectors(header->getHash(true), blockID))
			{
				return true;
			}
		}
	}
	return false;

}
// Block Queue Management Methods - BEGIN

/// <summary>
/// Performs verification and addition of a block to the processing queue.
/// The block is first cached and then, if conditions are met, added to the processing queue.
/// </summary>
/// <param name="block">Shared pointer to the block to be processed.</param>
/// <param name="byLocalScheduler">Flag indicating if block was scheduled by local node.</param>
/// <returns>Returns true if block was successfully queued, false otherwise.</returns>
bool CBlockchainManager::pushBlock(std::shared_ptr<CBlock> block, bool byLocalScheduler)
{
	// Pre-Flight - BEGIN
	if (!block)
	{
		return false;
	}

	// Turbo Sync Functionality - BEGIN
	// Notice: as part of Turbo Sync - also as part of Turbo Sync pre-validation is disabled for checkpointed blocks.
	addBlockToUnorderedCache(block);
	// Turbo Sync Functionality - END

	std::shared_ptr<CTools> tools = getTools();

	// External Block Processing Checks - BEGIN
	if (!byLocalScheduler && getDoNotProcessExtrernalBlocks())
	{
		tools->logEvent("Block won't be unqueued. Processing of exxternal blocks disabled.",
			eLogEntryCategory::localSystem, 3, eLogEntryType::warning, eColor::lightPink);
		return false;
	}
	// External Block Processing Checks - END

	// Hard Fork Checks - BEGIN
	if (getIsOperatorLeadingAHardFork() && !byLocalScheduler)
	{
		tools->logEvent("Block won't be unqueued. Awaiting a Hard Fork Block only.",
			eLogEntryCategory::localSystem, 1);
		return false;
	}
	// Hard Fork Checks - END
	// Pre-Flight - END

	// Operational Logic - BEGIN
	std::lock_guard<std::recursive_mutex> lock(blockQueueGuardian);
	if (block == nullptr || block->getHeader() == nullptr)
		return false;

	// Duplicate Check - BEGIN
	bool alreadyThere = false;
	for (uint64_t i = 0; i < mBlockQueue.size(); i++)
	{
		if (tools->compareByteVectors(mBlockQueue[i]->getID(), block->getID()))
		{
			tools->logEvent("Won't be adding block for processing, it's already enqueued.",
				eLogEntryCategory::network, 0);
			return false;
		}
	}
	// Duplicate Check - END

	// Queue Management - BEGIN
	if (mBlockQueue.size() < mBlockQueueMaxLength)
	{
		if (byLocalScheduler)
		{
			block->setScheduledByLocalScheduler(true);
		}
		tools->writeLine("Adding block " + tools->base58CheckEncode(block->getID()) +
			" to processing queue. Position:" + std::to_string(mBlockQueue.size()));
		mBlockQueue.push_back(block);
		std::sort(mBlockQueue.begin(), mBlockQueue.end(),
			[](const std::shared_ptr<CBlock>  a, const std::shared_ptr<CBlock>  b) {
				return a->getHeader()->getHeight() < b->getHeader()->getHeight();
			});
		setCachedBlockQueueLength(mBlockQueue.size());
		updateStatysticsToFile();
		return true;
	}
	else
	{
		tools->writeLine("Block was NOT added for processing. Queue length exceeded. (max: " +
			std::to_string(mBlockQueueMaxLength) + ")");
	}
	// Queue Management - END

	return true;
	// Operational Logic - END
}

// Block Queue Management Methods - END

/// <summary>
/// Adds a BER serialized block to a processing Queue.
/// The block is unpacked on sight. Returns False if not successfull.
/// </summary>
/// <param name="BERBlock"></param>
/// <returns>Returns true on success.</returns>
bool CBlockchainManager::pushBlock(std::vector<uint8_t> BERBlock, bool byLocalScheduler)
{
	if (BERBlock.size() > CGlobalSecSettings::getMaxDataBlockSize())
		return false;

	eBlockInstantiationResult::eBlockInstantiationResult iResult;
	std::string errorInfo;
	std::shared_ptr<CBlock> block = CBlock::instantiateBlock(true, BERBlock, iResult, errorInfo, mMode);

	if (iResult == eBlockInstantiationResult::Failure)
	{
		getTools()->writeLine(getTools()->getColoredString("[Error]: unable to instantiate the received block.", eColor::cyborgBlood));
		return false;
	}


	if (block != nullptr)
	{
		return pushBlock(block, byLocalScheduler);

	}
	else
		return false;
}

bool CBlockchainManager::getBlockQueueLength(uint64_t& length, bool waitForData)
{
	bool queueLocked = blockQueueGuardian.try_lock();

	if (queueLocked == false && waitForData == false)
	{
		length = getCachedBlockQueueLength();
		return false;
	}
	//std::lock_guard<std::recursive_mutex> lock(blockQueueGuardian);
	length = mBlockQueue.size();
	if (queueLocked)
	{
		blockQueueGuardian.unlock();
	}
	return true;
}

uint64_t CBlockchainManager::getBlockQueueMaxLength()
{
	std::lock_guard<std::recursive_mutex> lock(blockQueueGuardian);
	return mBlockQueueMaxLength;
}

void CBlockchainManager::setBlockQueueMaxLength(uint64_t size)
{
	std::lock_guard<std::recursive_mutex> lock(blockQueueGuardian);
	mBlockQueueMaxLength = size;
}

bool CBlockchainManager::wasBlockProcessed(std::vector<uint8_t> blockID)
{
	std::lock_guard<std::mutex> lock(processedBlockIDsQueueGuardian);

	if (mProcessedBlockIDsQueue.size() > 0)
	{
		for (uint64_t i = mProcessedBlockIDsQueue.size() - 1; i >= 0; i--)//from the end for performance; 
		{
			if (getTools()->compareByteVectors(mProcessedBlockIDsQueue[i], blockID))
				return true;
			if (i == 0)
				break;
		}
	}
	return false;
}

std::vector<CVerifiable> CBlockchainManager::getProofsOfFraufForLeader(std::vector<uint8_t> pubKey)
{
	return std::vector<CVerifiable>();
}

/// <summary>
/// Traverses the current VERIFIED history of events in search of the latest block produced by a given leader
/// represented by its PubKey.
/// If instructed not to use Cold-Storage, only  HotStorage cache will be used.
/// </summary>
/// <param name="pubKey"></param>
/// <returns></returns>
std::shared_ptr<CBlock> CBlockchainManager::getLatestDataBlockForKeyLeader(std::vector<uint8_t> pubKey, uint64_t maxSearch, bool useColdStorage)
{
	std::lock_guard<ExclusiveWorkerMutex> lock1(mChainGuardian);
	if (pubKey.size() != 32)
		return nullptr;

	//LOCAL VARIABLES - BEGIN
	std::shared_ptr<CBlock> current = getLeader();
	std::shared_ptr<CBlock> firstDataBlock = nullptr;
	uint64_t traversed = 0;
	uint64_t previousKeyBlockHeight = 0;
	eBlockInstantiationResult::eBlockInstantiationResult bir;
	bool keyBlockFound = false;
	//LOCAL VARIABLES - END
	//first we need to find the key-block with the pubKey..traversing backword


	while (current != nullptr && traversed < maxSearch)
	{
		if (current->getHeader()->isKeyBlock())
		{
			if (getTools()->compareByteVectors(pubKey, current->getHeader()->getPubKey()))
			{
				keyBlockFound = true;
				break; //we made it that's the leader we were looking for;
				//data-blocks
			}

		}
		else
		{
			if (current->getHeader()->getKeyHeight() != previousKeyBlockHeight)
			{
				previousKeyBlockHeight = current->getHeader()->getKeyHeight();
				firstDataBlock = current;
			}
		}

		current = current->getParent(bir, true, useColdStorage, true, shared_from_this());
		traversed++;

	}

	if (!keyBlockFound)
		return nullptr;//key-block was not found
	else
	{
		if (firstDataBlock != nullptr && !mCryptoFactory->verifyBlockSignature(firstDataBlock->getHeader(), current->getHeader()->getPubKey()))
			return nullptr;//this might happen when LOOKED_FOR_KEY_BLOCK....OTHER_KEY_BLOCK...DATA_BLOCK (i.e. our one had no data-block offsprings)
		else
			return firstDataBlock;
	}

}

/// <summary>
/// Proof-of-Fraud related mechanics.
/// The purpose is to log headers of offpsring data-blocks for a given key-block.
/// Note: The keyBlockID of the coresponding Key-block NEEDS to be provided IF the blocks is NOT a key-block.
/// Note: One needs to check for fraud BEFORE calling this function.
/// IF there's already an entry for Hash([blockHeight, keyBlockID]), the function would return FALSE (storage NOT affected).
/// The function is executed for each encounterd  data-block.
/// For more: check documentation within checkForFraud()
/// The function creates a log entry within a Cold-Storage hash-table.
/// The entry contains a Key: Hash([blockHeight, keyBlockID]) Value: blockHeader tupple.
/// 
/// Leader is allowed to create only one block at a given blockchain height.
/// Broadcasting more than one block signed using same privateKey at the same blockchain height is considered a FRAUD.
/// 
/// </summary>
/// <param name="block"></param>
/// <returns></returns>
bool CBlockchainManager::logBlock(std::shared_ptr<CBlock> block, std::vector<uint8_t> keyBlockID)
{
	//initial validation - BEGIN
	if (block == nullptr || block->getHeader() == nullptr)
		return false;

	if (block->getHeader()->isKeyBlock())
		keyBlockID = block->getID();

	//initial validation - END

	//local variables - BEGIN
	CDataConcatenator concat;
	std::vector<uint8_t> headerBody;
	std::vector<uint8_t> key;
	//local variables - END

	concat.add(keyBlockID);
	concat.add(block->getHeader()->getHeight());

	key = mCryptoFactory->getSHA2_256Vec(concat.getData());

	if (mSolidStorage->loadLink(key, headerBody, eLinkType::BHeightPKtoBlockHeader))
		return false;//there must be already aware of a block generated by the same leader for the same bc-height

	if (!block->getHeader()->getPackedData(headerBody))
		return false;

	return mSolidStorage->saveLink(key, headerBody, eLinkType::BHeightPKtoBlockHeader);
}


/// <summary>
/// The function takes a blockProposal and checks within the Cold-Storage hash-table for a block
/// generated by the same Leader, at the same blockchain height.
/// WARNING: the entire path from Key-Block to block needs to be available in ColdStorage in case of Data-Blocks.
/// 
/// The look-up is made using Hash([blockHeight, keyBlockID]), where pubKey is Leader's pub key.
/// Both values are retrieved from blockProposal.
/// 
/// IF, the function retrieves a previous block-header which DOES NOT match the header of blockProposal,
/// THEN blockProposal is considered as fraudulant and a Proof-Of-Fraud is generated and returned.
/// 
/// The REWARD for spotting the FRAUD will be  set within the proofOfFraud to the current miner's Address.
/// i.e. the function would fetch the current Key-Chain and also sign the Verifiable.
/// The default rewardee can be overriden by setting the 'rewardeesPrivKey' parameter (reardeed private key).
/// The coresponding address will be generated automatically.
/// 
/// The Proof-of-Fraud verifiable contains two headers signed for the same height AND the coresponding key-block header.
/// The key-block-header is needed as data-blocks DO NOT come with publicKeys (storage efficiency).
/// This also constitutes a SPAM-protection as verifiable PoW needs to be provided (key-block-header).
/// 
/// The Proof-of-Fraud Verifiable processing engine will check if fraud for a given epoch(Leader->data blocks) was already reported and cashed out.
/// If it was, NO REWARD would be issued.
/// 
/// The function returns TRUE if FRAUD was detected and FALSE, otherwise.
/// </summary>
/// <param name="blockProposal"></param>
/// <param name="proofOfFraud"></param>
/// <returns></returns>
eFraudCheckResult::eFraudCheckResult CBlockchainManager::checkForFraud(std::shared_ptr<CBlock> block, CVerifiable& proofOfFraud, Botan::secure_vector<uint8_t> rewardeesPrivKey)
{
	//initial validation - BEGIN
	if (block == nullptr || block->getHeader() == nullptr)
		return eFraudCheckResult::error;

	if (block->getHeader()->isKeyBlock())
	{
		return eFraudCheckResult::error;//frauds can be reported only for Data-Blocks
		//Rationalization: Key-Blocks are secured by Proof-of-Work, thus it is assumed to be infeasible for a malicious leader
		//to broacast diffent key-blocks to different parts of the network for the same key-block height.
		//Still, data-blocks DO NOT come with such a protection mechanism.
		//We need to be able to detect accurances of data-blocks issued for the same block-height by the same leader.
	}
	//initial validation - END

	getTools()->writeLine("Checking block " + getTools()->base58CheckEncode(block->getID()) + " for a possible fraud.. ");
	//local variables - BEGIN
	CDataConcatenator concat;
	std::vector<uint8_t> previousHeaderBody;
	std::vector<uint8_t> key;
	eFraudCheckResult::eFraudCheckResult toRet;
	std::shared_ptr<CBlock> keyBlock;
	std::vector<uint8_t> currentBlocksID;
	std::vector<uint8_t> currentBlockHeaderBody;
	std::vector<uint8_t> previousBlocksID;
	std::vector<uint8_t> keyBlockID;
	CKeyChain chain(false);
	bool cashedOutAlready = false;
	//local variables - END

	mSettings->getCurrentKeyChain(chain, false, false);

	keyBlock = getKeyBlockForBlock(block);

	if (keyBlock == nullptr)
		return eFraudCheckResult::keyBlockUnavailable;//can't acquire pubKey
	//NOTE: Thus, we are UNABLE to detect fraud, if we haven't seen and saved the corresponding key-block yet.

	keyBlockID = keyBlock->getID();

	if (keyBlockID.size() != 32)
		return eFraudCheckResult::error;

	//check for present Hash([blockHeight, keyBlockID]) Link in Cold Storage - PREPARATION
	//Note: between forks it might happen that a leader generated a block for the same height 
	//and this would be perfectly valid. HOWEVER, it is impossible for a leader to generate two data-block offspring
	//of the same Key-Block with a good intention!
	concat.add(keyBlockID);
	concat.add(block->getHeader()->getHeight());
	key = mCryptoFactory->getSHA2_256Vec(concat.getData());

	//The above key = Hash([blockHeight, keyBlockID]) is used to detect broadcasts of blocks intended
	//for the same block-height generated by the same Leader.
	//We create [Hash([blockHeight, pubKey]),BlockHeaderBody] key-value pairs with logBlock()
	//when encountering new Blocks. The log-entry is created independently from a Block-processing result.

	//Was the Hash([blockHeight, keyBlockID]) pair already logged? IF so, is the corresponding BlockHeaderBodythe the same
	//as the current block's? IF NOT => we've detected a FRAUD.

	if (mSolidStorage->loadLink(key, previousHeaderBody, eLinkType::BHeightPKtoBlockHeader))
	{
		block->getHeader()->getPackedData(currentBlockHeaderBody);
		currentBlocksID = mCryptoFactory->getSHA2_256Vec(currentBlockHeaderBody);
		previousBlocksID = mCryptoFactory->getSHA2_256Vec(previousHeaderBody);

		if (!getTools()->compareByteVectors(currentBlocksID, previousBlocksID))

		{
			//AT this point we already DO KNOW that there was a Block for the same height
			//generated by the same leader and that it was DIFFERENT than the currently seen.

			//NOW, we need to check if the fact was already cashed-out be someone else(another on-spotter).
			getTools()->writeLine("*WARNING*: FRAUD detected! (processing..)");

			//Generate the Proof-Of-Fraud - BEGIN
			CVerifiable PoFVer = CVerifiable(eVerifiableType::proofOfFraud);

			//prepare a Poof-of-Fraud  - [PreviousHeaderBODY,CurrentHeaderBODY]


			std::vector<uint8_t> packedKeyBlockHeader;
			if (!keyBlock->getHeader()->getPackedData(packedKeyBlockHeader))
				return eFraudCheckResult::error;

			if (!PoFVer.setPoFProof(packedKeyBlockHeader, previousHeaderBody, currentBlockHeaderBody))
				return eFraudCheckResult::error;

			//WRONG:generate Receipt-ID based on the key-block generated by the malicious leader.
			//we can NOT do the above, since multiple users might report the same fraud.
			//the receipt should allow to get the result of his/hers particular report.

			//we do want *ONLY ONE* report per a malicious key-block
			//We need a new Link: FraudID=>receiptsGUID
			//We might have created a link FraudID=>BlockID in which the freaud was processed, but that would have created 
			//the same storage overhead and processing overhead would be bigger(to traverse all the verifiables in a block
			//might be a lot of them in search of a Verifiable with a specific proof-of-fraud. 
			//This way instead, we have only a 3 additional look-ups: FraudID=>receiptsGUID=>receiptHash=>blockID=>Receipt=>verifiableBasedOnIDFromReceipt

			std::vector<uint8_t> fraudID = getTools()->getProofOfFraudID(keyBlock->getHeader()->getHash());

			//Instead of creating new fraudProcessingID =>blockID Links we reuse Receipts.
			//WRONG: we make the Receipt's ID be based on the keyBlockID/fraudProcessingID.
			//By retrieving the Block in which the Receipt is stored, we take use of the assumption
			//that the Verifiable based on which it was generated is in the same  block.
			//We retrieve the Verifiable's HASH from the retrieved receipt.
			//we use the hash to retrieve the Verifiable from the corresponding Merkle-Patricia-Trie from within the Block.

			//Now we do check if a FRAUD was not detected/reported already (and cashed out) by someone else.
			//Note 1: Only ONE report per a given key-block can be REWARDED.
			//i.e. IF leader generated multiple fraudulant data-blocks, he will be punished only once and only one reporter received reward.
			//Resaon: we CANNOT generate money out of thin air, first rewardee got everything there was to get.
			//In case the FRAUD for any data-block is found to be already reported NO REWARD would be given and the report would 
			//be neglected.
			//Note 2: The Proof-of-Frad Verifiable's ID is based on the PoF within.
			//Note 3: The Receipt's ID for a Proof-of-Frad Verifiable is based on the keyBlockID/fraudProcessingID
			//thus, to check for a previous Fraud report for a given Key-Block, it suffices to query for a Receipt.

			//CHECK IF FRAUD REPORT ALREADY PROCESSED - BEGIN

			std::vector<uint8_t> receiptGUID;
			std::vector<uint8_t> receiptsHash;//could be used to retieve the Receipt's HASH based on its GUID

			if (mSolidStorage->loadLink(fraudID, receiptGUID, eLinkType::PoFIDtoReceiptID))
			{
				if (mSolidStorage->loadLink(receiptGUID, receiptsHash, eLinkType::receiptsGUIDtoReceiptsHash))
				{
					std::vector<uint8_t> blockID;
					//the hash can be used to retrieve the ID of a Block in which the Verifiable AND its coresponding Receipt were processed/stored.
					if (mSolidStorage->loadLink(receiptsHash, blockID, eLinkType::receiptHashToBlockID))
					{
						eBlockInstantiationResult::eBlockInstantiationResult bir;
						std::shared_ptr<CBlock> block = mSolidStorage->getBlockByHash(blockID, bir, true);
						//now we can retrieve the block in which the former Proof-of-Fraud was placed

						if (block != nullptr)
						{
							//retrieve the verifiable AND receipt
							CReceipt retrievedRecept;
							if (!block->getReceipt(receiptsHash, retrievedRecept))
								return eFraudCheckResult::error;
							CVerifiable retrievedVerifiable;
							if (!block->getVerifiable(retrievedRecept.getVerifiableID(), retrievedVerifiable))
								return eFraudCheckResult::error;

							cashedOutAlready = true;
						}
					}
					else
						return eFraudCheckResult::error;

				}
				else
					return eFraudCheckResult::error;//this should not happen, the receipt should be a available locally.
			}
			else
			{
				cashedOutAlready = false;
			}

			//CHECK IF FRAUD REPORT ALREADY PROCESSED - END

			if (!cashedOutAlready)
			{
				//we are the first to report the fraud
				//sign the Proof-of-Fraud Verifiable

				//note: we do not explicitly add change-balance entries to verifiable these will be calculated implicitly.

				//sign the verifiable
				//the reward will be issued to an address generated based on the corresponding priv/pub key-pair (storage optimization)
				if (!PoFVer.sign(chain.getPrivKey()))
					return eFraudCheckResult::error;
				proofOfFraud = PoFVer;
				return  eFraudCheckResult::newFraud;
			}
			else
				return eFraudCheckResult::alreadyReported;
		}
		else
		{
			//these were different blocks. It's OK.
		}
	}

	//initial validation - END
	return  eFraudCheckResult::OK;
}


void CBlockchainManager::addBlockToProcessedBlocks(std::vector<uint8_t> blockID)
{
	std::lock_guard<std::mutex> lock(processedBlockIDsQueueGuardian);
	if (mProcessedBlockIDsQueue.size() > 100)
	{
		mProcessedBlockIDsQueue.erase(mProcessedBlockIDsQueue.begin());
	}
	mProcessedBlockIDsQueue.push_back(blockID);

}


std::shared_ptr<CBlock> CBlockchainManager::popBlock()
{
	std::lock_guard<std::recursive_mutex> lock(blockQueueGuardian);
	std::shared_ptr<CBlock> b;
	if (!mBlockQueue.empty())
	{
		b = mBlockQueue.front();
		mBlockQueue.pop_front();
		setCachedBlockQueueLength(mBlockQueue.size());
	}
	return b;
}

/// <summary>
/// Does the verification of block parts common for key- and data- blocks.
/// </summary>
/// <param name="block"></param>
/// <returns></returns>
CBlockVerificationResult CBlockchainManager::doCommonVerification(std::shared_ptr<CBlock> block)
{
	//LOCAL Variables - START
	int64_t timeDiff = 0;
	std::vector<uint8_t> blockID;
	blockID = block->getID();
	std::shared_ptr<CTools> tools = getTools();
	CBlockVerificationResult result(eBlockVerificationResult::eBlockVerificationResult::invalid, blockID);
	try {
		// Pre-Flight - BEGIN
		result.setStore(true);
		result.setAsLeader(true);
		eBlockInstantiationResult::eBlockInstantiationResult ir;
		std::shared_ptr<CBlock> parent;
		std::shared_ptr<CBlock> parentKeyBlock;
		std::vector<uint8_t> currentLeaderID;
		std::vector<uint8_t> currentKeyLeaderID;
		std::vector<uint8_t> pubKey;
		bool doingFlowProcessing = block->getScheduledByLocalScheduler();
		std::vector<uint8_t> signature;
		std::vector<uint8_t> parentID;
		bool analyzeAsLeaderCandidate = block->getScheduledByLocalScheduler();//otherwise there is no point to lock Verified-Path 
		//related mutexes (which *NEEDS* improvements anyway, the order of muetx locks!).
		if (!analyzeAsLeaderCandidate)
		{
			// [Rationale]: if block was not scheduled for processing by local block scheduler then we must NOT consider it as a leader candidate.
			//			    the above assumption is also used for processing optimization purposes.
			result.setAsLeader(false);
		}

		// Local Variables (order IMPORTANT) - BEGIN
		std::shared_ptr<CBlock> keyLeader = getLeader(true);
		std::shared_ptr<CBlock> leader = getLeader(false);
		if (leader != nullptr)
			currentLeaderID = leader->getID();
		if (keyLeader != nullptr)
			currentKeyLeaderID = keyLeader->getID();
		// Local Variables (order IMPORTANT) - END


		// Forks - BEGIN
		if (analyzeAsLeaderCandidate)
		{
			if (!tools->compareByteVectors(block->getHeader()->getParentID(), currentLeaderID))
			{
				uint64_t leaderHeight = 0;
				uint64_t blockHeight = block->getHeader()->getHeight();

				if (leader && leader->getHeader())
				{
					leaderHeight = leader->getHeader()->getHeight();
				}
				else
				{
					tools->writeLine("Warning: No valid leader block found.");
				}

				// Only blocks scheduled by the local scheduler are to be processed in-order.
				if (doingFlowProcessing)
				{
					// If the block height is unexpectedly bigger than (leaderHeight + 1), handle it
					if (blockHeight > (leaderHeight + 1))
					{
						tools->writeLine("Error: Block height is greater than leader height, "
							"unexpected state (for a block scheduled through local scheduler).");
						result.setForking(false); // Ensures consistency in this error scenario.
					}
					else
					{
						// Clamp the difference to avoid overflow if blockHeight > leaderHeight
						const uint64_t forkingOutCount =
							(blockHeight < leaderHeight) ? (leaderHeight - blockHeight) : 0;

						if (forkingOutCount > 0)
						{
							tools->writeLine("The block aims to " +
								tools->getColoredString(
									"fork out " + std::to_string(forkingOutCount),
									eColor::orange
								) +
								" block(s) in the current chain."
							);
							result.setForking(true);
						}
						else
						{
							tools->writeLine("The block does not fork out any blocks in the current chain.");
							result.setForking(false);
						}
					}
				}
			}
			else
			{
				tools->writeLine("The block is aligned with the current leader; no forking.");
				result.setForking(false);
			}
		}
		// Forks - END




		// Forks - END

		//locking mVerifiedPath is NOT enough.

	
		CVerifiable PoFVer;

		if (analyzeAsLeaderCandidate)
		{
			// Leader Overrides - BEGIN
		//when forking we need to override current leader with the one which used to be current during blocks' creation.

			if (result.isForking())
			{
				tools->writeLine("Block is forking thus assuming prior key-leader.");

				keyLeader = getKeyBlockForBlock(block);

				if (!keyLeader)
				{
					tools->writeLine("Key leader for a forking block is unknown..");
					result.setStatus(eBlockVerificationResult::eBlockVerificationResult::noCorrespondingKeyBlock);
					result.setAsLeader(false);//we might need it later on so do not disable storage
					return result;
				}

				tools->writeLine("Block is forking thus assuming prior leader.");

				eBlockInstantiationResult::eBlockInstantiationResult eir;
				leader = block->getParent(eir, true, false, false, shared_from_this());

				if (!leader)
				{
					tools->writeLine("Leader for a forking block is unknown..");
					result.setStatus(eBlockVerificationResult::eBlockVerificationResult::unknownParent);
					result.setAsLeader(false);//we might need it later on so do not disable storage
					return result;
				}

			}
			// Leader Overrides - END
			else
			{
				keyLeader = getLeader(true);
				leader = getLeader(false);
			}

		}
		else
		{
			result.setAsLeader(false);
		}

		std::shared_ptr<CTransactionManager> verficationFlowManager = getVerificationFlowManager();


		if (analyzeAsLeaderCandidate && !result.isForking()) // do not validate against current leader if forking.
		{
			if (leader != nullptr)
			{
				mVerifiedPathGuardian.lock();

				if (!tools->compareByteVectors(mVerifiedPath[mVerifiedPath.size() - 1], currentLeaderID))
				{
					tools->writeLine(tools->getColoredString("Fatal data integrity error (Leader not proclaimed by Verfied Chain).", eColor::cyborgBlood));
					assertGN(false);
				}

				if (mVerifiedPath.size() > 0)
					currentLeaderID = mVerifiedPath[mVerifiedPath.size() - 1];

				mVerifiedPathGuardian.unlock();
			}
		}
		// LOCAL Variables - END


		// Pre-Flight - END

		// Operational Logic - BEGIN

		if (block == nullptr)
		{
			result.setStore(false); // Notice: nowadays we rarely need to abort storage since the heaviest chain-proof dictates what makes its way into Cold Storage.
			//         With the current version of the protocol Heviest Chain Proof dictates what gets downloaded but local processing MIGHT reject processing.
			//		  If processing is rejected, local node would begin generating an alternative history of events - on its own.
			result.setAsLeader(false);
			return result;
		}

		

		if (block->getHeader() == nullptr)
		{
			result.setStatus(eBlockVerificationResult::eBlockVerificationResult::headerMissing);
			result.setStore(false); // Notice: nowadays we rarely need to abort storage since the heaviest chain-proof dictates what makes its way into Cold Storage.
			//         With the current version of the protocol Heviest Chain Proof dictates what gets downloaded but local processing MIGHT reject processing.
			//		  If processing is rejected, local node would begin generating an alternative history of events - on its own.
			result.setAsLeader(false);
			return result;
		}

		// Core Version Check - BEGIN
		if (block->getHeader()->getCoreVersion() < CGlobalSecSettings::getRequiredVersionNumber(block->getHeader()->getHeight()))
		{
			result.setStore(false); // Notice: rejecting blocks with insufficient Core version similarly to how we handle other validation failures
			result.setAsLeader(false);
			return result;
		}
		// Core Version Check - END

		parentID = block->getHeader()->getParentID();

		if (isBlockAvailableLocally(block->getHeader()->getHash()))
		{
			result.setStore(false); // Notice: nowadays we rarely need to abort storage since the heaviest chain-proof dictates what makes its way into Cold Storage.
			//         With the current version of the protocol Heviest Chain Proof dictates what gets downloaded but local processing MIGHT reject processing.
			//		  If processing is rejected, local node would begin generating an alternative history of events - on its own.
		}

		if (analyzeAsLeaderCandidate && !block->getHeader()->isKeyBlock() && keyLeader == nullptr)
		{
			result.setAsLeader(false);
		}

		result.setIsKeyBlock(block->getHeader()->isKeyBlock());

		parentKeyBlock = getKeyBlockForBlock(block); // notice that key-block might need to be retrieved from Cold Storage. Common Verification takes place also during out-of-order block processing.

		if (!parentKeyBlock && !block->isGenesis())
		{// Rationale: parental key-block is always needed for key-block height verififation (both for data and key-blocks down below).
		 // this also helps valdiate caching mechanics.

			result.setStatus(eBlockVerificationResult::eBlockVerificationResult::noCorrespondingKeyBlock);
			result.setAsLeader(false);
			// Update: as of now we schedule downloads only for already verified chain-proofs we thus MAY store the block.
			// notice that the parent MAY NOT be downloeaded YET.
		}

		if (!block->getHeader()->isKeyBlock())
		{
			if (parentKeyBlock == nullptr)
			{
				result.setStatus(eBlockVerificationResult::eBlockVerificationResult::noCorrespondingKeyBlock);
				result.setAsLeader(false);
				// Update: as of now we schedule downloads only for already verified chain-proofs we thus MAY store the block.
				// notice that the parent MAY NOT be downloeaded YET.

				//return result;// there's no key-block for that data-block.
				//In such a case we DO NOT even want to store it locally. (SPAM protection)
				//we download blocks only if we were able to verify the KeyChain in which the data-block was present.
				//and each key-chain REQUIRES at least one key-block.
			}
			else
			{
				logBlock(block, parentKeyBlock->getID());
			}
		}
		else
		{
			logBlock(block);
		}

		blockID = block->getID();
		result.setBlockID(blockID);
		tools->writeLine("Validating an incoming " + std::string(result.isKeyBlock() ? "Key" : "Regular") + " Block. ID: " + tools->base58CheckEncode(blockID));

		block->getHeader()->getPubSig(signature, pubKey);

		eFraudCheckResult::eFraudCheckResult fraudCheckResult = checkForFraud(block, PoFVer);
		std::vector<uint8_t> receiptID;
		switch (fraudCheckResult)
		{
		case eFraudCheckResult::keyBlockUnavailable:
			break;
		case eFraudCheckResult::newFraud:
			tools->writeLine("Happy Day! FRAUD detected. Block DISCARDED. Dispatching Proof-of-Fraud, awaiting reward.. ");
			verficationFlowManager->incNewFraudsDetected();
			if (!verficationFlowManager->registerVerifiable(PoFVer, receiptID))
			{
				tools->writeLine("I was unable to add the Proof-of-Fraud to local mem-pool. Might be a duplicate.");
			}
			else
			{
				tools->writeLine("Proof-of-Fraud registered at the local mem-pool.");
			}
			tools->writeLine("Dispatching the Proof-of-Fraud to Network Manager..");
			mNetworkManager->publishVerifiable(PoFVer);

			break;
		case eFraudCheckResult::OK:
			tools->writeLine("We've got nothing against the block. Proceeding further..");
			break;
		case eFraudCheckResult::error:
			tools->writeLine("I was unable to verify FRAUD at this stage. Assuming the block is OK.");
			break;
		case eFraudCheckResult::alreadyReported:
			verficationFlowManager->incFraudsDetectedButAlreadyRewarded();
			tools->writeLine("FRAUD spotted, still, someone was faster...");
			break;
		default:
			break;
		}

		if (!block->isGenesis())
		{
			if (block->getHeader()->getParentID().size() != 32)
			{
				result.setStatus(eBlockVerificationResult::eBlockVerificationResult::unknownParent);
				result.setStore(false); // Notice: nowadays we rarely need to abort storage since the heaviest chain-proof dictates what makes its way into Cold Storage.
				//         With the current version of the protocol Heviest Chain Proof dictates what gets downloaded but local processing MIGHT reject processing.
				//		  If processing is rejected, local node would begin generating an alternative history of events - on its own.
				result.setAsLeader(false);
				return result;
			}
		}

		if (block->getHeader()->isKeyBlock() && pubKey.size() != 32)//pub-key required *ONLY* for KEY-BLOCKs
		{
			result.setStatus(eBlockVerificationResult::eBlockVerificationResult::pubKeyMissing);
			result.setStore(false); // Notice: nowadays we rarely need to abort storage since the heaviest chain-proof dictates what makes its way into Cold Storage.
			//         With the current version of the protocol Heviest Chain Proof dictates what gets downloaded but local processing MIGHT reject processing.
			//		  If processing is rejected, local node would begin generating an alternative history of events - on its own.
			result.setAsLeader(false);
			return result;
		}

		if (signature.size() == 0)
		{
			result.setStatus(eBlockVerificationResult::eBlockVerificationResult::sigMissing);
			result.setStore(false); // Notice: nowadays we rarely need to abort storage since the heaviest chain-proof dictates what makes its way into Cold Storage.
			//         With the current version of the protocol Heviest Chain Proof dictates what gets downloaded but local processing MIGHT reject processing.
			//		  If processing is rejected, local node would begin generating an alternative history of events - on its own.
			result.setAsLeader(false);
			return result;
		}

		//Let us see if the block aims to extend the current best known chain
		//IF it does; THEN we DO NOT need to verify the entire chain-path
		//to see if the result would be a suitable Leader or not.
		//for other valid blocks we will verify the entire chain-path to see if
		//the resulting path turns out to contain the highest cumulated PoW.

			//- the decision whether to assume the block as leader will be made based on the total cumulated PoW not on whether the block extends the current leader
			//below we just check if the block wants to create a fork



		//  ******  DATA-INTEGRITY VALIDATION ****** //


		parent = block->getHeader()->getParent(ir, true, false, false, shared_from_this());
		if (parent == nullptr && !block->isGenesis())
		{
			result.setStatus(eBlockVerificationResult::eBlockVerificationResult::unknownParent);
			result.setStore(true);//store the block anyway. it will get pruned if not part of the main chain after certain time.
			//the parent might become known later on
			result.setAsLeader(false);
		}

		//validate time-span and block height
		if (parent != nullptr)
		{


			timeDiff = block->getHeader()->getSolvedAtTime() - parent->getHeader()->getSolvedAtTime();
			if (timeDiff < 0)
			{
				assertGN(true);
				//block from the past
			}

			//todo:uncomment this once in production!
			/*if (abs(timeDiff) > CGlobalSecSettings::getMaxTimeIntBetweenBlocks())
			{
				//that  break-point gets hit if the time-diff exceeded.
				//note: we get hit by this breakpoint pretty often when debugging and the database-is stale
				//on a given server, thus
				//todo: reconsider automatic hacky-time adjustment or just automated ignore of this condition
				//note: the seconds would render the global sequence of blocks INVALID when verified (as timestamps would be incorect)
				result.setStatus(eBlockVerificationResult::eBlockVerificationResult::timeDiffExceeded);
				result.setAsLeader(false);
				result.setStore(false);
				return result;

			}*/

			//BLOCK-HEGIHT VALIDATIONS - BEGIN

			if (analyzeAsLeaderCandidate && !leader && block->getHeader()->getHeight() != 0)
			{
				result.setStatus(eBlockVerificationResult::eBlockVerificationResult::unknownParent);
				result.setAsLeader(false);
				result.setStore(false); // Notice: nowadays we rarely need to abort storage since the heaviest chain-proof dictates what makes its way into Cold Storage.
				//         With the current version of the protocol Heviest Chain Proof dictates what gets downloaded but local processing MIGHT reject processing.
				//		  If processing is rejected, local node would begin generating an alternative history of events - on its own.
				return result;
			}

			//verify whether height is +1 against parent
			if (block->getHeader()->getHeight() != (parent->getHeader()->getHeight() + 1))
			{//this is true for any block. Its height needs to be greater by one than its parent
				result.setStatus(eBlockVerificationResult::eBlockVerificationResult::invalidBlockHeight);
				result.setAsLeader(false);
				result.setStore(false); // Notice: nowadays we rarely need to abort storage since the heaviest chain-proof dictates what makes its way into Cold Storage.
				//         With the current version of the protocol Heviest Chain Proof dictates what gets downloaded but local processing MIGHT reject processing.
				//		  If processing is rejected, local node would begin generating an alternative history of events - on its own.
				return result;
			}

			//we ALSO need to check whether the  block is a direct offspring of the last block within the Verified Chain Proof.
			//that is because a parent MIGHT be already available within a COLD storage, BUT it is not a direct descendant
			//of the current leader. 
			//Were it not for this verification, we would be attempting to append blocks, creating empty gaps. i.e. block N+3 
			//could be appended right after block N+1.

			//We COULD rely on recursion within a Flow, refatching all the earlier blocks and executing processBlock right over here
			//but as time approaches infinity that would be creating more overhead than relying on the current ITERATIVE approach within the
			//block processing loop (iterating over members of the Heaviest Chain-Proof and attempting to commit each block one by one from the last point whose
			//verification/processing succeeded).

			//IMPORTANT: it is being checked by the end of this function.


			if (analyzeAsLeaderCandidate && leader && block->getHeader()->getHeight())
			{

				if (!block->getHeader()->isKeyBlock())
				{
					if (block->getHeader()->getKeyHeight() != ((leader->getHeader()->getKeyHeight())))
					{

						// if we are forking we should have assumed leader as not the current lead but
						// the load which had been valid during block's creation.
						if (block->getHeader()->getKeyHeight() < (leader->getHeader()->getKeyHeight()))
							tools->writeLine("The blocks seems to be targeting one of the previous key-block leaders..");
						result.setStatus(eBlockVerificationResult::eBlockVerificationResult::invalidBlockHeight);
						result.setAsLeader(false);//we might need it later on so do not disable storage
					}
				}

				// *----WRONG - BEGIN
				/*
				*  Bottom Line:: any kind of a block can for out every other as long as it's contained within of the Heaviest Chain Proof.
				* Rationale: we need to support a situation in which a local leader produces multiple data blocks for same height 'by mistake'.
				*			 Notie that the network protects itslef against such situations through the concept of Proof-of-Fraud.
				*/
				//if (!block->getHeader()->isKeyBlock())
					//DATA BLOCK LEADER consideration ONLY - the block would be saved anyway if valid
				//{	//key-block can fork-out a data-block produced a by previous leader if cummulative PoW is greater than current chain
					//that is NOT true for data-blocks, for these the height index needs to be *equal* to previousHeight+1.


					/*
					* [Definitions]
					* Criteria 1: block->getHeader()->getHeight() == ((leader->getHeader()->getHeight() + 1)
					* Criteria 2: block is member of the Heaviest Path.
					* [Notice]:  Heaviest Path is guaranteed to have a valid sequence of blocks (in terms numerical order).
					*/
					//[Important Update]: the block does *NOT* need to be a descendant of the current Leader.
					//Such a condition would prevent certain types of forks from being processed properly.
					// Tha main line of thinking is - we NEED to be able to fork-out the current Leader.

					/*
						While during normal operation for any data block we do require that Criteria 1 is met.
						and a data block CANNOT fork-out a key-block, it MIGHT happen (be it a premeditated attack or not
						(extremely unlikely).

						Key Point: we must thus rely on:
						1) the Heaviest Chain-Proof. Notice: if the block was scheduled for processing by the local scheduler,
						then the block MUST BE within of the Heaviest Chain-Proof (optimization).
						2) IF, the block does not meet the Criteria 1 and if Criteria 2 not met as well, the block CANNOT
						be assumed as a Leader.
						3) if analyzeAsLeaderCandidate is NOT set then it means the block was not scheduled by local scheduler and thus no need to consider
							it as a Leader to begin with.
					*/

					/*
					* [Sample Scenario]:
					*  [Block 27545] - Block A [Status]: Leader
					*
					*  Now arrives [Block 27546] (Block X) which references ANOTHER [Block 27545] (Block B) than the current Leader (Block A).
					*  The Heaviest Chain-Proof has Block B at position 27545. Block B was scheduled for processing by the local scheduler.
					*
					* Had we kept such a condition such as the one below, it would prevent Block B from being proclaimed as the current Leader.
					*
					* ---- WRONG - BEGIN
					* if (block->getHeader()->getHeight() != ((leader->getHeader()->getHeight() + 1)))
					{
						result.setStatus(eBlockVerificationResult::eBlockVerificationResult::invalidBlockHeight);
						result.setAsLeader(false);//we might need it later on so do not disable storage
					}
					   ---- WRONG - END
					*
					*
					*/

					/*
					if (leader && analyzeAsLeaderCandidate && // Criteria 2. If block is in Heaviest Path (analyzeAsLeaderCandidate set), then it's fine. But we need to keep the Forking Flag
						//   which is set elsewhere. By the Forking Flag we know that cache needs to be wiped clean.
						(block->getHeader()->getHeight() != ((leader->getHeader()->getHeight() + 1))))// Criteria 1
					{
						result.setStatus(eBlockVerificationResult::eBlockVerificationResult::invalidBlockHeight);
						result.setAsLeader(false);//we might need it later on so do not disable storage
					}
					*/
					//}
					// *----WRONG - END
			}


			if (!block->getHeader()->isKeyBlock())
			{


				if (parentKeyBlock && parentKeyBlock->getHeader()->getKeyHeight() != block->getHeader()->getKeyHeight())
				{//the  height for data-block needs to be equal to its parental key-block
					result.setStatus(eBlockVerificationResult::eBlockVerificationResult::invalidKeyHeight);
					result.setAsLeader(false);
					result.setStore(false);
					return result;
				}
			}

			if (!block->isGenesis() && block->getHeader()->isKeyBlock())
			{
				if (parentKeyBlock && parentKeyBlock->getHeader()->getKeyHeight() != (block->getHeader()->getKeyHeight() - 1))
				{//the key height of a key-block needs to be equal to parentalKeyBlock_keyHeight+1
					result.setStatus(eBlockVerificationResult::eBlockVerificationResult::invalidKeyHeight);
					result.setAsLeader(false);
					result.setStore(false); // Notice: nowadays we rarely need to abort storage since the heaviest chain-proof dictates what makes its way into Cold Storage.
					//         With the current version of the protocol Heviest Chain Proof dictates what gets downloaded but local processing MIGHT reject processing.
					//		  If processing is rejected, local node would begin generating an alternative history of events - on its own.
					return result;
				}
			}
			//BLOCK-HEGIHT VALIDATIONS - END


			//check if we do already know a data-block at higher height? if so it means leader attempted to do a double spend
			//IMPORTANT: issue a penalty transaction, notify the network
			//Note we need to ensure it was signed by the same leader first!
			/*if (leader != nullptr)
			{
				if (!block->getHeader()->isKeyBlock() && !leader->getHeader()->isKeyBlock() &&
					leader->getHeader()->getHeight() >= block->getHeader()->getHeight())
				{
					result.setStatus(eBlockVerificationResult::eBlockVerificationResult::leaderAttemptedADoubleSpendAttack);
					return result;
				}
			}*/
			//TODO: check if a block signed by same leader for the same height is known
		}

		//DATA-BLOCK BEGIN
		if (!block->getHeader()->isKeyBlock())
		{
			//Note: PubKey is NOT present within a header of a DATA-BLOCK.
			//Thus, we need to fetch it from a parent KEY-BLOCK first.

			/*
			1) Note: parent-KEY-BLOCK-id is within a KEY-BLOCK only. Thus we need to traverse the chain in search of it (when looking at DATA-BLOCK)
			2) Need to make sure both keyHeight and height are verified in block header.
			3) Need to make sure parent-KEY-BLOCK (specified in a KEY-BLOCK ONLY, - needed for PoW verification) is always presnet and valid.
			AND that it's the first key- block after std::shared_ptr<CBlock> keyParent =findBlockInCache(block->getHeader()->getParentKeyBlockID());
			4) Verification of DATA-BLOCK should take a pub-key as argument.

			Solutions:
			+ cache the current KEY-BLOCK info - it wil be used when block extends the current leader - DONE
			+ look-up from chain by traversing on demand - it will be used when block extends another arbitrary block - DONE
			+ look-up from chain proof by traversing on demand - it will be used during chain-proof validation - DONE
			+ keep data in each block - that would be just too easy to implement and too storage-expensive - TOO LAME
			*/
			if (result.isForking())
			{


				if (parentKeyBlock == nullptr)
				{
					result.setStatus(eBlockVerificationResult::eBlockVerificationResult::keyParentUnknown);
					result.setAsLeader(false);
					result.setStore(true);//store the block anyway. it will get pruned if not part of the main chain after certain time.
					//the parent might become known later on
				}
				pubKey = parentKeyBlock->getHeader()->getPubKey();
			}
			else
			{

				if (parentKeyBlock == nullptr)
				{
					result.setStatus(eBlockVerificationResult::eBlockVerificationResult::keyParentUnknown);
					result.setStore(true);
					result.setAsLeader(false);
					return result;
				}


				//the block extends the current chain so we can re-use pub-key from the current
				//KEY-BLOCK leader.
				pubKey = parentKeyBlock->getHeader()->getPubKey();

			}


		}
	

		//The following will verify the block's signature.
		//If a signature is invalid for a data-block this will prove that either
		//+wrong parent was assumed OR
		//+ there was an invalid signature presented
		if (!mCryptoFactory->verifyBlockSignature(block, pubKey))
		{
			result.setStatus(eBlockVerificationResult::eBlockVerificationResult::invalidSignature);
			result.setAsLeader(false);
			result.setStore(false); // Notice: nowadays we rarely need to abort storage since the heaviest chain-proof dictates what makes its way into Cold Storage.
			//         With the current version of the protocol Heviest Chain Proof dictates what gets downloaded but local processing MIGHT reject processing.
			//		  If processing is rejected, local node would begin generating an alternative history of events - on its own.
			return result;
		}

		if (block->isGenesis())
			result.setAsLeader();
		else
		{
			// [ Important ]: it MUST be allowed to accept data blocks for key blcosk which are not current leaedrs IF the parent key  block is a amember of the currently verified chain-proof.

			if (analyzeAsLeaderCandidate && !block->getHeader()->isKeyBlock() && keyLeader != nullptr && parentKeyBlock != nullptr)
			{
				//parentKeyBlock - detected leader (by traversing through parent blocks in Cold Storate) for the to-be-verified block 
				std::vector<uint8_t> parentkeyBlockID = parentKeyBlock->getID();
				bool parentKeyBlockMemberOfVerifiedChain = false;
				// Check if parent key block member of the Verified Chain-Proof -  BEGIN
				// Rationale: if parental key-leader is part of the Verified Chain Proof block candidate MAY fork out anything EVEN if block candidate is a data block
				parentKeyBlockMemberOfVerifiedChain = isBlockInChainProof(parentKeyBlock->getID(), parentKeyBlock->getHeader()->getHeight(), eChainProof::verified);
				// Optimizaton: we COULD rely on the very fact that if block candidate was scheduled for processing by local scheduler then there must be a common
				//				point betwen local Heaviest Chain Proof and local Verified Chain proof which implies a common already verified parent.
			    //				But to maintain proper security compartmentation seperate logic to ensure parent key block is member of verified chain proof is employed.
				//				The performance impact is expected to be negligible since this only happens during forks.
				
				// Check if parent key block member of the Verified Chain-Proof -  BEGIN
				if (!parentKeyBlockMemberOfVerifiedChain)
				{
					//if parent leading block is not part of currently verified chain-proof we cannot proclai as leader
					result.setAsLeader(false);
					result.setStatus(eBlockVerificationResult::eBlockVerificationResult::noCorrespondingKeyBlock);
					if (keyLeader != nullptr && tools->compareByteVectors(keyLeader->getHeader()->getParentKeyBlockID(), parentkeyBlockID))
						tools->writeLine("The data-block seems to be targeting previous key-block leader. (forked already, sorry..)");

					return result;
				}
				
			}


			//we need NOT need to explicitly verify if we've got all the blocks leading to the parental-key-block
			//relying on verification of the flow is SUFFICIENT. we trust the miner

				//DATA-BLOCK END
		}

		result.setStatus(eBlockVerificationResult::eBlockVerificationResult::valid);//the above succeeded ,we already might know
		//whether the block is NOT to be assumed as leader or whether we might not want to store it at all..
		//further tests will commence; we need to verify the PoW if it's a key block, verify the transactions, verfiables etc.

		/*The parent of the current block does not need to be the the last block in the Verified Chain-Proof.
		[Reason]: we need to account for the possibility of forks,- in which, the parent of the current block is 'forked out'.
		The parent needs to exist, the current block needs to contribute to the 'heaviest and longesr' history of events, but otherwise
		we do not care whether the block is an imminent offspring of the current verified history of events.
		Example: Block B2 forks out all the blocks [2,12] from the current verified history of events (due to a better cumulative PoW, than the cumulative PoW
		within blocks [2,12] - which are currently within the Verified Chain-Proof). We need to allow for such events.
		Under the hood updatePathWithLeader() would always take care of updating the Verified Chain-Proof, even in such a case.

		if (!tools->compareByteVectors(parentID, lastBlockFromVerifiedChainProofID))
		{
			result.setStatus(eBlockVerificationResult::parentNotALeaderInVerifiedChainProof);
			result.setAsLeader(false);//proceeed with all the othe processin but do NOT process contents as of now.
		}*/

		return result;
	}
	catch (...)
	{
		result.setAsLeader(false);
		result.setStore(false);
		result.setStatus(eBlockVerificationResult::criticalFailure);

	}
	return result;

	//Operational Logic - END
}

/// <summary>
/// Does verification mainly of the block-parts related to key-blocks.
/// </summary>
/// <param name="block"></param>
/// <param name="result"></param>
/// <returns></returns>
CBlockVerificationResult CBlockchainManager::doKeyPartVerification(std::shared_ptr<CBlock> block, CBlockVerificationResult result)
{
	try {
		//LOCAL Variables - START
		std::vector<uint8_t> blockID;
		blockID = block->getID();
		double reqDiff = 1;
		bool parentIsHardForkBlock = false;
		bool memberOfHeaviestPath = false;
		double blockDiff = 0;
		std::shared_ptr<CTools> tools = getTools();
		bool wasPoWValid = false;
		size_t nonce = 0;
		std::shared_ptr<CBlock> parent;
		std::vector<uint8_t> currentLeaderID;
		eBlockInstantiationResult::eBlockInstantiationResult ir;
		bool blockMemberOfHeaviestPath = false;
		uint64_t nowProposal = block->getHeader()->getSolvedAtTime();
		//LOCAL Variables - END



		blockDiff = block->getHeader()->getDifficulty();
		nonce = block->getHeader()->getNonce();

		uint64_t nowNative = std::time(0);
		uint64_t nowChain = nowNative;

		// ****** Verify The Proof-of-Work ****** //
		//if the PoW is found to be invalid; the processing will stop right here.

		if (mCryptoFactory->verifyNonce(*block->getHeader()))
			wasPoWValid = true;//it means ONLY that the miner really did the claimed amount of work.


		if (!wasPoWValid && !block->getIsCheckpointed())
		{
			result.setAsLeader(false);
			result.setStore(false); // Notice: nowadays we rarely need to abort storage since the heaviest chain-proof dictates what makes its way into Cold Storage.
			//         With the current version of the protocol Heviest Chain Proof dictates what gets downloaded but local processing MIGHT reject processing.
			//		  If processing is rejected, local node would begin generating an alternative history of events - on its own.
			result.setStatus(eBlockVerificationResult::eBlockVerificationResult::insufficientPoW);
			return result; // the miner is trying to cheat; he/she did not perform the required amount of work
		}

		//NOTE: The following is sort-of redundant
		//additional data integrity verification (including verification of Trie-roots was performed during the block instantiation process).
		parent = block->getHeader()->getParent(ir, true, false, false, shared_from_this());
		if (parent)
		{
			nowChain = parent->getHeader()->getSolvedAtTime();

			if (parent->getHeader()->isKeyBlock() && parent->getHeader()->getNonce() == 0)
			{
				parentIsHardForkBlock = true;
			}

		}
		if (parent)
		{
			//Time-stamp Verification - BEGIN
			// 
			// 
			//[IMPORTANT:] the very same verification happens during chain-proof's validation.
			// 	As a general rule, consecutive blocks are expected to be in the future BUT not too far away to thwart excessive time-stamp manipulation attacks.
			//  Also, new blocks may seem to be slightly in the past yet again - due to the aforementioned time-skew.
			//  A limited amount of time-skew is always deemed to be legitimate (both into the future and into the past).
			//  Into-the-future time-skew allowed is much bigger than into-the-past time-skew.
			// 
			// [DOCS] - BEGIN

			/*
			* [RATIONALE] - BEGIN
			* ### Documentation: Block Timestamp Verification

			In the blockchain verification process, accurate timestamping of
			blocks is crucial. Timestamps serve several purposes, such as
			determining block sequence, ensuring data integrity, and preventing
			manipulation of mechanisms dependent on time, like difficulty
			adjustments. The provided code outlines checks for both the native
			operating system's timestamp and the parent block's timestamp.
			Here's a detailed rationale for these checks:

			#### 1. Native Operating System Timestamp Checks:

			- **Purpose**: This check ensures that a new block's timestamp isn't
			  deviating significantly from the current time as per the node's
			  operating system.

			- **Use Cases**:
			  - **Into-the-past Time-skew Check**: If the current block's
				timestamp appears to be in the past relative to the OS time, it
				might be due to acceptable time skews across distributed nodes.
				However, any excessive skew is flagged. This ensures blocks are
				sequenced correctly and prevents nodes from backdating blocks
				for malicious reasons.
			  - **Into-the-future Time-skew Check**: Blocks shouldn't have a
				timestamp far into the future compared to the OS time. This
				prevents forward-dating attacks, where a miner could try to
				manipulate block timestamps for gain.

			- **Special Conditions**:
			  - **Checkpoints**: If a block is checkpointed, the aforementioned
				timestamp rules can be overridden. Checkpoints are trusted
				states in the blockchain, providing reference points that are
				accepted by the network.
			  - **Hard Forks**: If an operator is leading a hard fork, the
				stringent requirements on the timestamp can be relaxed for the
				immediate block following the checkpointed block signaling the
				hard fork.

			#### 2. Parent Block Timestamp Checks:

			- **Purpose**: This ensures the chronological integrity of the
			  blockchain. Each new block should have a timestamp that is equal
			  to or greater than its parent block.

			- **Use Cases**:
			  - **Into-the-future Parent Time-skew Check**: A block's timestamp
				shouldn't be excessively further into the future compared to its
				parent block's timestamp. This prevents rapid forward jumps in
				block timestamps, which could be used to game systems like
				difficulty adjustments.

			- **Special Conditions**:
			  - **Checkpoints and Hard Forks**: Just as with the OS timestamp
				checks, checkpoints and impending hard forks can override these
				rules.

			#### Overall:
			The combination of these checks ensures the integrity and
						reliability of block timestamps in the blockchain. While
						there are mechanisms to allow for slight deviations in
						time (due to network lags, minor clock skews, etc.), any
						significant deviation that could be a sign of malicious
						activity is flagged and the block is rejected. However,
						in certain scenarios, like trusted checkpoints and hard
						forks, these rules can be relaxed, since there's a
						higher level of trust or a significant protocol change
						occurring. * [RATIONALE] - END
			## Timestamp Verification Documentation

			The timestamp verification process ensures the integrity of block
			timestamps within our blockchain system. It upholds the principle
			that block timestamps should be reasonably close to real-world time
			and in a chronological order, with certain allowances for time drift
			and specific overrides for checkpoints and hard forks. Here's an
			in-depth look:

			### 1. **Parent Check**:

			Before the timestamp verification can commence, it checks for the
			existence of a `parent` block, implying that the block being
			verified is not the genesis block (which won't have any preceding
			block).

			### 2. **Basic Time Proposal Check**:

			- **Condition**: If there's no `currentTimeProposal` (timestamp of
			  the block being verified).
			- **Outcome**: If the block isn't checkpointed, the block is
			  rejected based on the time difference.

			### 3. **Genesis Block Handling**:

			- **Condition**: If the system does not have a sense of current
			  on-chain time (`now` is undefined) and the block being verified
			  isn't the genesis block.
			- **Outcome**: If no checkpoint exists for the block, it is
			  rejected. However, if there's a checkpoint, an override message is
			  displayed, and the block is accepted.

			### 4. **Timestamp Skew Checks**:

			Timestamp skews refer to the time difference between the
			`currentTimeProposal` (block's timestamp) and `now` (the timestamp
			reported by the native OS).

			#### a. **Into-The-Past Skew**:

			- **Condition**: If the proposed block's timestamp is in the past
			  relative to the current on-chain time and the time skew exceeds
			  the limit set by `getMaxIntoThePastBlockTimeSkewSec()`.
			- **Outcome**: The block is generally rejected. Exceptions include:
			  - If the block has a checkpoint.
			  - If there's an operator leading a hard fork, and the block is
				integral to that hard fork.

			#### b. **Into-The-Future Skew**:

			- **Condition**: If the proposed block's timestamp is in the future
			  relative to the current on-chain time and the time skew exceeds
			  the limit set by `getMaxIntoTheFutureBlockTimeSkewSec()`.
			- **Outcome**: The block is generally rejected. Exceptions include:
			  - If the block has a checkpoint.
			  - If there's an operator leading a hard fork, and the block is
				integral to that hard fork.

			### 5. **Checkpoint and Hard Fork Overrides**:

			- **Checkpoint Override**: If a block is "checkpointed", it is
			  presumed to be valid even if it fails the timestamp checks.
			  Checkpoints serve as pre-validated points in the blockchain that
			  can override certain timestamp verifications.

			- **Hard Fork Override**: During planned hard forks, certain
			  timestamp verification rules can be overridden. This provides
			  flexibility to the system during significant updates or chain
			  splits. If an operator is leading a hard fork, and the block in
			  question is part of that fork, specific timestamp rules may not
			  apply.

			### Important Notes:

			- The `currentTimeProposal` is the timestamp of the block being
			  verified.
			- The `now` refers to the timestamp as reported by the native
			  operating system.
			- Proper management of checkpoint and hard fork overrides is
			  critical to the security and integrity of the blockchain. Improper
			  use or mismanagement can introduce vulnerabilities.
			- The defined limits for time skews
			  (`getMaxIntoThePastBlockTimeSkewSec()` and
			  `getMaxIntoTheFutureBlockTimeSkewSec()`) should be set considering
			  the network's requirements, expected latencies, and potential
			  clock drifts. Adjustments should be made after careful
			  consideration to maintain the balance between security and
			  flexibility.


						*/
						// [DOCS] - END
						//
						//1) [General Rule]: current block must be in the future we need to
						//   accept a certain amount of time-drift though

						//time needs to be transition to be begin with

			if (!nowProposal)
			{
				if (!block->getIsCheckpointed())
				{
					result.setAsLeader(false);
					result.setStore(false);
					result.setStatus(eBlockVerificationResult::eBlockVerificationResult::timeDiffExceeded);
					return result;
				}
			}

			//0A) [Sub-Condition] the current on-chain-time must be known (if not dealing with the Genesis Block) - BEGIN
			if (!nowChain && block->getHeader()->getHeight() != 0)//it's Genesis Block - the concept of time does not exist (yet).
			{
				if (!block->getIsCheckpointed() && !(parent && parent->getIsCheckpointed()))
				{//no checkpoint to override this
					result.setAsLeader(false);
					result.setStore(false); // Notice: nowadays we rarely need to abort storage since the heaviest chain-proof dictates what makes its way into Cold Storage.
					//         With the current version of the protocol Heviest Chain Proof dictates what gets downloaded but local processing MIGHT reject processing.
					//		  If processing is rejected, local node would begin generating an alternative history of events - on its own.
					result.setStatus(eBlockVerificationResult::eBlockVerificationResult::timeDiffExceeded);
					return result;
				}
				else
				{
					tools->writeLine("Overriding the on-chain-time-known requirement, due to a Checkpoint being present.");
				}

			}
			//0A) [Sub-Condition] - END


			//1A) [Sub-Condition]: into-the-past time-skew check - BEGIN
			//IMPORTANT: when modifying, - update checks during chain-proof verification as well.
			// In regards to into-the-past fluctuations we do not need to compare against native OS time, we just make sure that the current block is newer than its parent.
			if (nowChain && (nowProposal < nowChain) && (nowChain - nowProposal) > CGlobalSecSettings::getMaxIntoThePastBlockTimeSkewSec())//ZERO Tolerance
			{//[Rationalization]: key-block proposal must be in the future
				//Still, we must accept for a certain time-skew. The block might seem to be in the past though
				//due to a time skew. If threshold exceeded, we reject.
				//[Notice]: if (currentTimeProposal < now) - the blocks seems to be in the past (relatively to the prior block).

				if (!block->getIsCheckpointed())
				{//no checkpoint to override this

					if (getIsOperatorLeadingAHardFork() == false || !block->getIsLeadingAHardFork())
					{
						result.setAsLeader(false);
						result.setStore(false); // Notice: nowadays we rarely need to abort storage since the heaviest chain-proof dictates what makes its way into Cold Storage.
						//         With the current version of the protocol Heviest Chain Proof dictates what gets downloaded but local processing MIGHT reject processing.
						//		  If processing is rejected, local node would begin generating an alternative history of events - on its own.
						result.setStatus(eBlockVerificationResult::eBlockVerificationResult::timeDiffExceeded);
						return result;
					}
					else if (block->getIsLeadingAHardFork())//the parental block needs to be check-pointed in source-code first.
					{
						//Operator Leading a Hard-Fork - BEGIN

						//Notice: this mechanism is valid only at the boundary  of 'check-pointed' and new blocks.
								  // In other words, this mechanism is valid only for the immediate block following the block at which a Hard Fork is to occur.
						tools->writeLine(tools->getColoredString("Overriding the into-the-past maximum time-skew requirement. Operator is leading a hard-fork.", eColor::lightPink));

						//Operator Leading a Hard-Fork - END
					}
				}
				else
				{
					tools->writeLine("Overriding the into-the-past maximum time-skew requirement, due to a Checkpoint being present.");
				}
			}
			//1A) [Sub-Condition] - END

			//1B) [Sub-Condition]: into-the-future time-skew check - BEGIN
			//IMPORTANT: when modifying,- update checks during chain-proof verification as well.
			if (
				// Part A: Parent timestamp check
				(parent &&
					!parentIsHardForkBlock &&
					nowProposal > parent->getHeader()->getSolvedAtTime() &&
					(nowProposal - parent->getHeader()->getSolvedAtTime()) > CGlobalSecSettings::getMaxIntoTheFutureBlockParentTimeSkewSec()
					)
				||
				// Part B: Native time check
				(nowNative &&
					nowProposal > nowNative &&
					(nowProposal - nowNative) > CGlobalSecSettings::getMaxIntoTheFutureBlockNativeTimeSkewSec()
					)
				)	//[Notice]: if (currentTimeProposal > now) - it implies the current proposal is in the future.
				//it MUST NOT be excessively far away into the future to prevent time-stamp manipulation and thus difficulty manipulation
				//attacks.
			{
				if (!block->getIsCheckpointed())
				{//no checkpoint to override this
					if (getIsOperatorLeadingAHardFork() == false || !block->getIsLeadingAHardFork())
					{
						result.setAsLeader(false);
						result.setStore(false);
						result.setStatus(eBlockVerificationResult::eBlockVerificationResult::timeDiffExceeded);
						
						return result;
					}
					else if (block->getIsLeadingAHardFork())//the parental block needs to be check-pointed in source-code first.
					{
						//Operator Leading a Hard-Fork - BEGIN
						//Notice: this mechanism is valid only at the boundary of 'check-pointed' and new blocks.
								  // In other words, this mechanism is valid only for the immediate block following the block at which a Hard Fork is to occur.
						tools->writeLine(tools->getColoredString("Overriding the into-the-past maximum time-skew requirement. Operator is leading a hard-fork.", eColor::lightPink));
						//Operator Leading a Hard-Fork - END
					}
				}
				else
				{
					tools->writeLine("Overriding the into-the-future maximum time-skew requirement, due to a Checkpoint being present.");
				}

			}
			//1B) [Sub-Condition] - END
		}
		//Time-stamp Verification - END

		//Support of Non-Forks - BEGIN
		if (!result.isForking())
		{
			//The proposed block aims to extend the current best known chain, thus we can compare
			//its difficulty against the immediate required one
			bool diffFound = false;
			//WARNING: optimization is being used below since we are EXTENDING the current chain.

			//*****
			//IMPORTANT: note existence of similar logic in  [Non-Forks] and [Forks] related blocks.
			//*****

			//in theory we could use optimization down below (non-fork) but we DON'T (just to stay on safe side until fully validated).
			reqDiff = getMinDIfficultyForBlock(parent, nowProposal, false, false, diffFound); //mSettings->getMinDiff(now);
			//check if the block meets the current momentary difficulty criterion
			if (!block->getIsCheckpointed())
			{
				if ((blockDiff < (reqDiff - 0.01f)))
				{
					if (!block->getIsCheckpointed())
					{
						result.setAsLeader(false);
						result.setStore(false); // Notice: nowadays we rarely need to abort storage since the heaviest chain-proof dictates what makes its way into Cold Storage.
						//         With the current version of the protocol Heviest Chain Proof dictates what gets downloaded but local processing MIGHT reject processing.
						//		  If processing is rejected, local node would begin generating an alternative history of events - on its own.
						result.setStatus(eBlockVerificationResult::eBlockVerificationResult::insufficientPoW);
					}
					else
					{
						tools->writeLine("Overriding Proof-of-Work requirement due to a Checkpoint being present.");
						/*
						* Notice: When it comes to 'chain-proofs' it suffices for a chain-proof to be heaviest
						* when exchanged and verified. We do not need to verify individual PoW entries when processing these.
						* When it comes to thee - it's the cumulative Proof-of-Work which matters.
						*/
						result.setAsLeader();
					}
				}
				else if (blockDiff > (1.3 * reqDiff))
				{
					// we need to prevent powerful attacakers from being able to affect processing of blocks by riding difficulty higher
					// than required by the Protocol.
					result.setAsLeader(false);
					result.setStore(false);
					result.setStatus(eBlockVerificationResult::eBlockVerificationResult::excessivePoW);

				}
			}
			//else if(resultresult.setAsLeader();//we've got a new potential Leader indeed. NOTICE: NO NEED TO SET THAT. Assumed as leader by default if not disabled in prior processing.
		}//Support of Non-Forks - END

		//Support of Forks - BEGIN
		else
		{//the block does NOT aim to extend the current chain.
			//diff. computations needs to be performed explicitly and ad-hoc

			//The block does NOT aim to extend the current best known chain.
			//thus wee need to check if its PoW was good enough at the time of its creation
			// AND THEN we need to check the total cumulative PoW on that very path since 
			//it might turn out that the resulting path turns out to be the current Leader.
			//for all this  we need to know all the successive blocks (or at least the entire chainProof)
			//if we do not know an intermediate block; we will store it anyway => the PoW is valid.
			//it might come into use later on.
			bool diffFound = false;
			if (parent == nullptr && !block->isGenesis())
			{
				result.setAsLeader(false);
				result.setStatus(eBlockVerificationResult::eBlockVerificationResult::unknownBlockOnPath);
				return result;//an unknown block on path
			}
			else if (block->isGenesis())
			{
				//result.setAsLeader(); //we've got a new potential Leader indeed. NOTICE: NO NEED TO SET THAT. Assumed as leader by default if not disabled in prior processing.
			}
			else
			{
				//Notice: the PoW algorithm needs not only to account for what's in the past but to account
				// for the current timestamp (extrinsic to what's already present in the history of events) as well.
				// The current timestamp is thus present within the block which is being verified, here - the 'block'.

				/* In order to protect against difficulty manipulation, the timestamp present within the block
				* being verified needs to be within of an acceptable time-skew (relative to the previous block).
				*/

				//WARNING: optimization disabled since the block is forking current chain.

				//*****
				//IMPORTANT: note existence of similar logic in  [Non-Forks] and [Forks] related blocks.
				//*****
				reqDiff = getMinDIfficultyForBlock(parent, nowProposal, false, false, diffFound);

				if (!diffFound)
				{
					result.setAsLeader(false);
					result.setStatus(eBlockVerificationResult::eBlockVerificationResult::unknownBlockOnPath);
					//An unknown block is on the path thus I won't be able to verify the perspective/transactions etc.
					//I'll store the block; it might come into use once the Network Manager downloads the missing parts.
					return result;
				}
			}

			if (block->getHeader()->getDifficulty() < reqDiff)
			{//the PoW *WAS NOT* valid at the time the block was created;
				if (!block->getIsCheckpointed())
				{
					result.setAsLeader(false);
					result.setStore(false); // Notice: nowadays we rarely need to abort storage since the heaviest chain-proof dictates what makes its way into Cold Storage.
					//         With the current version of the protocol Heviest Chain Proof dictates what gets downloaded but local processing MIGHT reject processing.
					//		  If processing is rejected, local node would begin generating an alternative history of events - on its own.
					result.setStatus(eBlockVerificationResult::eBlockVerificationResult::insufficientPoW);
				}
				else
				{
					tools->writeLine("Overriding Proof-of-Work requirement due to a Checkpoint being present.");
					/*
					* Notice: When it comes to 'chain-proofs' it suffices for a chain-proof to be heaviest
					* when exchanged and verified. We do not need to verify individual PoW entries when processing these.
					* When it comes to thee - it's the cumulative Proof-of-Work which matters.
					*/
					//result.setAsLeader(); //we've got a new potential Leader indeed. NOTICE: NO NEED TO SET THAT. Assumed as leader by default if not disabled in prior processing.
				}
			}
			else if (block->getHeader()->getDifficulty() / reqDiff > 1.3)
			{
				tools->writeLine("The block has " + std::to_string(block->getHeader()->getDifficulty() / reqDiff) + " times higher difficulty than the one expected.");

				// we need to prevent powerful attacakers from being able to affect processing of blocks by riding difficulty higher
				// than required by the Protocol.
				result.setAsLeader(false);
				result.setStore(false);
				result.setStatus(eBlockVerificationResult::eBlockVerificationResult::excessivePoW);
			}
			// ******* CUMULATIVE CHAIN-WORK COMPARISON - START ********* ///

			std::string error;
			CBlockVerificationResult ver;
			//Compare total difficulty of the proposed path with the one already present
			//The following is checked during chainProof download
			unsigned long long proposedChainWork = block->getTotalWorkDone(ver);
			//block->freePath(true);//lets just prune the temporary view
			if (ver.getStatus() != eBlockVerificationResult::valid)
			{
				result.setAsLeader(false);
				//I could NOT compute the total cumulative chain-work for this block
				result.setStatus(eBlockVerificationResult::eBlockVerificationResult::unknownBlockOnPath);
				return result;
			}

			/*
			IMPORTANT update: it might happen so, especially during bigger forks, or when syncing with the network after a long period of time
			ex. due to a down-time that the analyzed block does NOT produce the highest cumulative path BUT all in all we NEED to fork the current local path
			as it LEADS to the best known cumulative path. THUS we use reliance on its membership within the heaviest sub-chain as the ultimate source of knowledge.
			*/
			mHeaviestPathGuardian.lock();
			if (mHeaviestPath.size())
			{
				for (uint64_t i = mHeaviestPath.size() - 1; i > 0; i--)
				{
					if (tools->compareByteVectors(mHeaviestPath[i], blockID))
					{
						blockMemberOfHeaviestPath = true;
						break;
					}
					if (i == 0)
						break;
				}
			}
			mHeaviestPathGuardian.unlock();

			//does the proposed chain contain more cumulative work than the one already set as 'current'?

			if (blockMemberOfHeaviestPath == false && getLeader() != nullptr)//if block member of heaviest path, no additional PoW verification needed.
			{
				uint64_t currentTotalChainWork = getLeader()->getTotalWorkDone(ver);
				if (ver.getStatus() != eBlockVerificationResult::eBlockVerificationResult::valid)
				{
					result.setAsLeader(false);
					result.setStatus(eBlockVerificationResult::eBlockVerificationResult::unknownBlockOnPath);
					return result;
				}
				tools->writeLine("The Blockchain proposed by the Block has " + std::to_string(proposedChainWork) + " work, the current one has " + std::to_string(currentTotalChainWork));
				if (proposedChainWork <= currentTotalChainWork && !(
					proposedChainWork == currentTotalChainWork && block->getIsLeadingAHardFork()))//compares the cumulated amount of work done on this chain
				{
					//the block might not result in highest cumulative PoW , BUT. it still may be member of the
					//heaviest chain. in such a case we MUST honor the membership and do not neglect this block on the grounds
					//of not having produced the heaviest chain.

					//we do not process block recursively SO, we need to check for membership within the Heaviest Chain-proof
					//iteratively right over here and now.
					mHeaviestPathGuardian.lock();
					if (mHeaviestPath.size())
					{
						if ((mHeaviestPath.size() - 1) >= block->getHeader()->getHeight())
						{
							if (tools->compareByteVectors(mHeaviestPath[block->getHeader()->getHeight()], blockID))
							{
								memberOfHeaviestPath = true;
							}
						}


						/*for (uint64_t i = mHeaviestPath.size() - 1; i >= 0; i--)
						{
							if (tools->compareByteVectors(mHeaviestPath[i], blockID))
							{
								memberOfHeaviestPath = true;
								break;
							}
							if (i == 0)
								break;
						}
						*/
					}

					mHeaviestPathGuardian.unlock();
					if (!memberOfHeaviestPath)
					{
						result.setAsLeader(false);
						result.setStatus(eBlockVerificationResult::eBlockVerificationResult::insufficientTotalPoW);
						return result;
					}
					else
					{
						tools->writeLine("The block does not produce heaviest chain BUT it is " + tools->getColoredString("member of the Heaviest Path", eColor::lightGreen) + ".. Validating further..");
					}
				}
				else
				{
					tools->writeLine("Thus, the chain represented by the block contains enough cumulative PoW to win over the current Chain. Validating further..");
					//we've got a new Leader block candidate indeed!
					//if  Flow verification succeeds; the block will be assumed as the current key-leader block.

				}
			}
			else if (blockMemberOfHeaviestPath)
			{
				tools->writeLine("Block is a " + tools->getColoredString("member of the Heaviest Chain Proof", eColor::lightGreen) + ". Validating further..");
			}
			// ******* CUMULATIVE CHAIN-WORK COMPARISON - END ********* ///

		}//Support of Forks - END
		return result;
	}
	catch (...)
	{
		result.setAsLeader(false);
		result.setStore(false); // Notice: nowadays we rarely need to abort storage since the heaviest chain-proof dictates what makes its way into Cold Storage.
		//         With the current version of the protocol Heviest Chain Proof dictates what gets downloaded but local processing MIGHT reject processing.
		//		  If processing is rejected, local node would begin generating an alternative history of events - on its own.
		result.setStatus(eBlockVerificationResult::criticalFailure);
		return result;
	}
}



void CBlockchainManager::setBlockIDAtKeyHeight(uint64_t height, std::vector<uint8_t> blockID, eChainProof::eChainProof chainProof)
{
	std::vector<std::vector<uint8_t>>* targetVector;
	std::mutex* targetMutex;

	switch (chainProof)
	{
	case eChainProof::verified:
		targetMutex = &mVerifiedKeyBlocksIndexGuardian;
		targetVector = &mVerifiedKeyBlockIDsAtHeights;
		break;
	case eChainProof::heaviest:
		targetMutex = &mHeaviestKeyBlocksIndexGuardian;
		targetVector = &mHeaviestKeyBlockIDsAtHeights;
		break;
	default:
		// Handle invalid chainProof value if necessary
		return;
	}

	std::lock_guard<std::mutex> lock(*targetMutex);
	if (targetVector->size() < (height + 1))
	{
		targetVector->resize(height + 1);
	}
	(*targetVector)[height] = blockID;
}



/**
 * @brief Retrieves the block ID at a specified height in the verified chain.
 *
 * This method accesses the mVerifiedChainProofDouble to get the block ID.
 * Height is measured from the bottom of the chain, where 0 is the genesis block.
 *
 * @param height The height of the block whose ID is to be retrieved.
 * @return std::vector<uint8_t> The block ID at the specified height, or an empty vector if out of bounds.
 *
 * Thread safety: This method is thread-safe, using a recursive mutex for synchronization.
 *
 * Note: This method assumes that mVerifiedChainProofDouble is ordered from oldest to newest,
 * allowing direct indexing by height.
 */
std::vector<uint8_t> CBlockchainManager::getBlockIDAtHeight(uint64_t height)
{
	// Thread Safety - BEGIN
	std::lock_guard<ExclusiveWorkerMutex> lock(mVerifiedPathDoubleGuardian);
	// Thread Safety - END

	// Validation - BEGIN
	if (height >= mVerifiedChainProofDouble.size())
	{
		return std::vector<uint8_t>();  // Return an empty vector if height is out of bounds
	}
	// Validation - END

	// Retrieval - BEGIN
	return mVerifiedChainProofDouble[height];
	// Retrieval - END
}

/**
 * @brief Retrieves the block ID of a key block at a specified height in the chosen chain.
 *
 * This method accesses either mVerifiedKeyBlockIDsAtHeights or mHeaviestKeyBlockIDsAtHeights
 * based on the specified chain proof to get the block ID of a key block.
 * Height is measured from the bottom of the chain, where 0 is the genesis block.
 *
 * @param height The key height of the block whose ID is to be retrieved.
 * @param chainProof The chain proof type to use (verified or heaviest).
 * @return std::vector<uint8_t> The block ID at the specified key height, or an empty vector if out of bounds or for invalid chain proof.
 *
 * Thread safety: This method is thread-safe, using a mutex specific to the chosen chain for synchronization.
 *
 * Note: This method assumes that the key block vectors are ordered from oldest to newest,
 * allowing direct indexing by height.
 */
std::vector<uint8_t> CBlockchainManager::getBlockIDAtKeyHeight(uint64_t height, eChainProof::eChainProof chainProof)
{
	// Local Variables - BEGIN
	std::vector<std::vector<uint8_t>>* targetVector;
	std::mutex* targetMutex;
	// Local Variables - END

	// Operational Logic - BEGIN
	switch (chainProof)
	{
	case eChainProof::verified:
		targetMutex = &mVerifiedKeyBlocksIndexGuardian;
		targetVector = &mVerifiedKeyBlockIDsAtHeights;
		break;
	case eChainProof::heaviest:
		targetMutex = &mHeaviestKeyBlocksIndexGuardian;
		targetVector = &mHeaviestKeyBlockIDsAtHeights;
		break;
	default:
		// Return an empty vector for invalid chainProof values
		return std::vector<uint8_t>();
	}

	std::lock_guard<std::mutex> lock(*targetMutex);

	// Bounds checking
	if (targetVector->size() <= height)
	{
		return std::vector<uint8_t>();
	}

	return (*targetVector)[height];
	// Operational Logic - END
}

/**
 * @brief Retrieves the block ID of a key block at a specified depth in the chosen chain.
 *
 * This method accesses either mVerifiedKeyBlockIDsAtHeights or mHeaviestKeyBlockIDsAtHeights
 * based on the specified chain proof to get the block ID of a key block.
 * Depth is measured from the top of the chain, where 0 is the latest key block.
 *
 * @param depth The key depth of the block whose ID is to be retrieved.
 * @param chainProof The chain proof type to use (verified or heaviest).
 * @return std::vector<uint8_t> The block ID at the specified key depth, or an empty vector if out of bounds or for invalid chain proof.
 *
 * Thread safety: This method is thread-safe, using a mutex specific to the chosen chain for synchronization.
 *
 * Note: This method assumes that the key block vectors are ordered from oldest to newest,
 * hence the need to reverse the index when accessing.
 */
std::vector<uint8_t> CBlockchainManager::getBlockIDAtKeyDepth(uint64_t depth, eChainProof::eChainProof chainProof)
{
	// Local Variables - BEGIN
	std::vector<std::vector<uint8_t>>* targetVector;
	std::mutex* targetMutex;
	// Local Variables - END

	// Operational Logic - BEGIN
	switch (chainProof)
	{
	case eChainProof::verified:
		targetMutex = &mVerifiedKeyBlocksIndexGuardian;
		targetVector = &mVerifiedKeyBlockIDsAtHeights;
		break;
	case eChainProof::heaviest:
		targetMutex = &mHeaviestKeyBlocksIndexGuardian;
		targetVector = &mHeaviestKeyBlockIDsAtHeights;
		break;
	default:
		// Return an empty vector for invalid chainProof values
		return std::vector<uint8_t>();
	}

	std::lock_guard<std::mutex> lock(*targetMutex);

	// Bounds checking
	if (depth >= targetVector->size())
	{
		return std::vector<uint8_t>();
	}

	// Calculate the index, considering the reverse ordering for depth
	size_t index = targetVector->size() - 1 - depth;
	return (*targetVector)[index];
	// Operational Logic - END
}

/// <summary>
/// Retrieves the effective total block reward for a given block ID from solid storage.
/// </summary>
/// <param name="blockID">32-byte block identifier</param>
/// <param name="totalReward">Reference to store the retrieved reward value. Set to 0 if not found.</param>
/// <returns>True if value was found in storage, false otherwise</returns>
bool CBlockchainManager::getTotalBlockRewardEffective(const std::vector<uint8_t>& blockID, BigInt& totalReward)
{
	CSolidStorage* ss = getSolidStorage();
	if (!ss)
	{
		totalReward = BigInt(0);
		return false;
	}
	return ss->getTotalBlockRewardEffective(blockID, totalReward);
}

/// <summary>
/// Stores the effective total block reward for a given block ID in solid storage.
/// </summary>
/// <param name="totalReward">The total block reward value to store</param>
/// <param name="blockID">32-byte block identifier</param>
/// <returns>True if storage was successful, false otherwise</returns>
bool CBlockchainManager::setTotalBlockRewardEffective(const BigInt& totalReward, const std::vector<uint8_t>& blockID)
{
	//Validation - BEGIN
	if (blockID.size() != 32)
		return false;
	//Validation - END

	CSolidStorage* ss = getSolidStorage();
	if (!ss)
		return false;

	return ss->setTotalBlockRewardEffective(totalReward, blockID);
}
/// <summary>
/// Retrieves the effective paid to miner amount for a given block ID from solid storage.
/// </summary>
/// <param name="blockID">32-byte block identifier</param>
/// <param name="paidToMiner">Reference to store the retrieved amount. Set to 0 if not found.</param>
/// <returns>True if value was found in storage, false otherwise</returns>
bool CBlockchainManager::getPaidToMinerEffective(const std::vector<uint8_t>& blockID, BigInt& paidToMiner)
{
	CSolidStorage* ss = getSolidStorage();
	if (!ss)
	{
		paidToMiner = BigInt(0);
		return false;
	}
	return ss->getPaidToMinerEffective(blockID, paidToMiner);
}

/// <summary>
/// Stores the effective paid to miner amount for a given block ID in solid storage.
/// </summary>
/// <param name="paidToMiner">The amount paid to miner to store</param>
/// <param name="blockID">32-byte block identifier</param>
/// <returns>True if storage was successful, false otherwise</returns>
bool CBlockchainManager::setPaidToMinerEffective(const BigInt& paidToMiner, const std::vector<uint8_t>& blockID)
{

	CSolidStorage* ss = getSolidStorage();
	if (!ss)
		return false;

	return ss->setPaidToMinerEffective(paidToMiner, blockID);

}


std::vector<uint8_t>  CBlockchainManager::getEffectivePerspective(const std::vector<uint8_t>& blockID)
{
	std::vector<uint8_t> perspective;

	//Validation - BEGIN
	if (blockID.size() != 32)
		return perspective;
	//Validation - END

	CSolidStorage* ss = getSolidStorage();

	if (!ss)
		return perspective;

	std::string key = "EP_" + getTools()->base58CheckEncode(blockID);

	perspective = ss->getValue(key);

	if (perspective.size() == 32)
	{
		return perspective;
	}
	else
		return std::vector<uint8_t>();

}
/**
 * @brief Truncates the key-block IDs index vector for the specified chain proof.
 *
 * This method invalidates (removes) all stored key-block IDs at or beyond the specified height.
 * It is used when making a cut in a chain proof (for example, after reorganization) so that the
 * key-block index remains consistent with the truncated chain proof.
 *
 * @param height The starting index (inclusive) from which all entries should be removed.
 * @param chainProof The chain proof type to update (e.g., eChainProof::verified or eChainProof::heaviest).
 * @return true if truncation was performed (or no action was necessary because height >= vector size),
 *         false if an invalid chainProof type is provided.
 */
bool CBlockchainManager::truncateKeyBlockIDsFromKeyHeight(uint64_t height, eChainProof::eChainProof chainProof)
{
	std::vector<std::vector<uint8_t>>* targetVector = nullptr;
	std::mutex* targetMutex = nullptr;

	switch (chainProof)
	{
	case eChainProof::verified:
		targetMutex = &mVerifiedKeyBlocksIndexGuardian;
		targetVector = &mVerifiedKeyBlockIDsAtHeights;
		break;
	case eChainProof::heaviest:
		targetMutex = &mHeaviestKeyBlocksIndexGuardian;
		targetVector = &mHeaviestKeyBlockIDsAtHeights;
		break;
	default:
		// Invalid chain proof type provided.
		return false;
	}

	std::lock_guard<std::mutex> lock(*targetMutex);
	if (height < targetVector->size())
	{
		targetVector->erase(targetVector->begin() + height, targetVector->end());
	}
	return true;
}


/**
 * Immunizes the node against a potentially harmful block by blacklisting it and
 * adjusting the heaviest chain proof if necessary.
 *
 * Implements proactive resilience mechanism described in:
 * https://talk.gridnet.org/t/proactive-resilience-enhancing-gridnet-core-in-response-to-unconventional-mining-practices/240
 *
 * The method performs two main operations:
 * 1. Blacklists the provided block for the specified duration
 * 2. If the block is part of the heaviest chain proof, truncates the chain at that point
 *
 * Note: This operation only makes sense for nodes capable of mining operations as it may
 * truncate a significant portion of the event history at the point of disagreement.
 *
 * @param block Pointer to the block to immunize against
 * @param blacklistDurationSeconds Duration in seconds for which the block should be blacklisted
 * @return void
 */
bool CBlockchainManager::immuniseAgainstBlock(const std::shared_ptr<CBlock>& block,
	const uint64_t blacklistDurationSeconds) {
	// Local Variables - BEGIN
	std::vector<uint8_t> blockID;
	std::shared_ptr<CTools> tools = getTools();
	blockID = block->getID();
	// Local Variables - END

	// Operational Logic - BEGIN
	// 1. Blacklist the block for specified duration
	blacklistBlock(blockID, blacklistDurationSeconds);

	// [ Rationale ]: - node is vaccinated against future processing of this block.
	//			      - node is vaccinated against accepting Chain Proofs containing this block (coming in from other other nodes).

	// 2. Attempt to make a cut in the Heaviest Chain Proof
	// Only blocks present in the Heaviest Chain-Proof can trigger this
	// [ Rationale ]: node is vaccinated against future processing of further blocks on this very blockchain path.
	
	std::lock_guard< ExclusiveWorkerMutex> lock(mHeaviestPathGuardian);

	uint64_t blockHeight = block->getHeader()->getHeight();

	// Make a cut in Heaviest Chain Proof - BEGIN
	if (mHeaviestChainProof.size() && blockHeight < mHeaviestChainProof.size()) {

		tools->writeLine("Attempting to make a cut in the Heaviest-Chain Proof to remove block " +
			tools->base58CheckEncode(blockID), eColor::lightPink);

		if (tools->compareByteVectors(mHeaviestPath[blockHeight], blockID)) {
			assertGN(mHeaviestChainProofCumulativePoWs.size() == mHeaviestChainProof.size() &&
				mHeaviestChainProof.size() == mHeaviestPath.size());

			mHeaviestChainProof.erase(mHeaviestChainProof.begin() + blockHeight,
				mHeaviestChainProof.end());
			mHeaviestChainProofCumulativePoWs.erase(mHeaviestChainProofCumulativePoWs.begin() + blockHeight,
				mHeaviestChainProofCumulativePoWs.end());
			mHeaviestPath.erase(mHeaviestPath.begin() + blockHeight,
				mHeaviestPath.end());

			{
				std::lock_guard<ExclusiveWorkerMutex> doubleGuard(mHeaviestPathDoubleGuardian);
				mHeaviestPathDouble.erase(mHeaviestPathDouble.begin() + blockHeight,
					mHeaviestPathDouble.end());
			}


			// This call ensures that the mHeaviestKeyBlockIDsAtHeights vector is truncated
			// from 'keyBlockHeight' onward to keep it in sync with the truncated chain proof.
			truncateKeyBlockIDsFromKeyHeight(block->getHeader()->getKeyHeight(), eChainProof::heaviest);

			mNetworkManager->forceSyncCheckpointsReferesh(); // invalidate cached synchronisation points

			updateHeaviestPathLeaders();

			if (mHeaviestChainProof.size()) {
				CBlockHeader::eBlockHeaderInstantiationResult instantiationResult;
				std::string errorMessage;

				// Update Global Dials - BEGIN
				if (!mHeaviestChainProof.empty() && !mHeaviestPath.empty() && !mHeaviestChainProofCumulativePoWs.empty()) {
					// Normal case - all vectors have elements
					CBlockHeader::eBlockHeaderInstantiationResult instantiationResult;
					std::string errorMessage;
					auto newLeader = CBlockHeader::instantiate(
						mHeaviestChainProof[mHeaviestChainProof.size() - 1],
						instantiationResult,
						errorMessage,
						false,
						getMode()
					);

					if (instantiationResult != CBlockHeader::eBlockHeaderInstantiationResult::failure) {
						setHeaviestChainProofKeyLeader(newLeader);
					}
					else {
						setHeaviestChainProofKeyLeader(nullptr);
						tools->writeLine("Failed to instantiate block header: " + errorMessage, eColor::cyborgBlood);
						return false;
					}

					const size_t newHeight = mHeaviestPath.size() - 1;
					setCachedHeaviestHeight(newHeight);
					setHeaviestChainProofLeadBlockID(mHeaviestPath[newHeight]);
					setHeaviestChainProofTotalDifficulty(mHeaviestChainProofCumulativePoWs[newHeight]);
				}
				else {
					// Handle empty vectors case
					setHeaviestChainProofKeyLeader(nullptr);
					setCachedHeaviestHeight(0);
					setHeaviestChainProofLeadBlockID(std::vector<uint8_t>());
					setHeaviestChainProofTotalDifficulty(0);
					tools->writeLine("Setting empty/zero values due to empty data structures", eColor::cyborgBlood);
				}
				// Update Global Dials - END

				tools->writeLine("Heaviest Chain Proof was truncated!", eColor::lightPink);
			}
		}
		else {
			tools->writeLine("The block was not found at the expected position while altering the Heaviest Chain Proof. " +
				tools->base58CheckEncode(blockID), eColor::cyborgBlood);
		}
	}

	// Make a cut in Heaviest Chain Proof - END

	return true;
	// Operational Logic - END
}

bool CBlockchainManager::setEffectivePerspective(const std::vector<uint8_t> perspective, const std::vector<uint8_t>& blockID)
{
	//Validation - BEGIN
	if (perspective.size() != 32 || blockID.size() != 32)
		return false;
	//Validation - END

	CSolidStorage* ss = getSolidStorage();

	std::string key = "EP_" + getTools()->base58CheckEncode(blockID);
	if (!ss)
		return false;

	return ss->saveValue(key, perspective);

}

/// <summary>
/// Verifies block-part specific to Data-Blocks.
/// </summary>
/// <param name="block"></param>
/// <param name="result"></param>
/// <returns></returns>
CBlockVerificationResult CBlockchainManager::doDataPartVerification(std::shared_ptr<CBlock> block, CBlockVerificationResult result)
{
	try {
		//LOCAL Variables - START
		std::vector<uint8_t> alternativePerspective;//this would override the Expected Perspective.
		std::shared_ptr<CBlock> currentLeader = getLeader();
		std::shared_ptr<CBCheckpoint> checkpoint = getCurrentCheckpoint(block->getHeader());
		std::shared_ptr<CBlock> parent;
		std::vector<uint8_t> blockID;
		std::shared_ptr<CTools> tools = getTools();
		blockID = block->getID();
	
		bool dataCoherent = false;
		std::vector<uint8_t> initialPerspective;
		eBlockInstantiationResult::eBlockInstantiationResult ir;
		
		std::shared_ptr<CBlock> recentKeyBlock;
		std::shared_ptr<CTransactionManager> verificationFlowManager = getVerificationFlowManager();
		//LOCAL Variables - END

		//Operational Logic -  BEGIN
		std::vector<uint8_t> actualHash;
		//check if all the receipts are there
		std::vector<std::vector<uint8_t>> recHashes = block->getReceiptsIDs();
		parent = block->getHeader()->getParent(ir, true, false, false, shared_from_this());

		std::shared_ptr<CBCheckpoint> parentCheckpoint;

		if (parent)
		{
			parentCheckpoint = getCurrentCheckpoint(parent->getHeader());
		}

		CReceipt r(mMode);
		for (int i = 0; i < recHashes.size(); i++)
		{

			bool retrieved = block->getReceipt(recHashes[i], r);

			if (!retrieved)
			{
				result.setAsLeader(false);
				result.setStore(false);
				result.setStatus(eBlockVerificationResult::receiptMissing);
				return result;
			}


			if (r.getGUID().size() <= 32)
			{
				result.setStatus(eBlockVerificationResult::eBlockVerificationResult::receiptMissing);
				result.setAsLeader(false);
				result.setStore(false); // Notice: nowadays we rarely need to abort storage since the heaviest chain-proof dictates what makes its way into Cold Storage.
				//         With the current version of the protocol Heviest Chain Proof dictates what gets downloaded but local processing MIGHT reject processing.
				//		  If processing is rejected, local node would begin generating an alternative history of events - on its own.
				return result;
			}

			actualHash = r.getHash();
			if (!tools->compareByteVectors(actualHash, recHashes[i]))
			{	//invalid mis-reported content, there is a receipt under the key, but its actual content is different
				result.setAsLeader(false);
				result.setStore(false);
				result.setStatus(eBlockVerificationResult::receiptMissing);
				return result;
			}
		}
		//check if all the transactions are there
		std::vector<std::vector<uint8_t>> txIDs = block->getTransactionsIDs();
		if (txIDs.size() > 0 && result.isKeyBlock())
		{
			result.setStatus(eBlockVerificationResult::invalid);
			result.setAsLeader(false);
			result.setStore(false); // Notice: nowadays we rarely need to abort storage since the heaviest chain-proof dictates what makes its way into Cold Storage.
			//         With the current version of the protocol Heviest Chain Proof dictates what gets downloaded but local processing MIGHT reject processing.
			//		  If processing is rejected, local node would begin generating an alternative history of events - on its own.
			return result;
		}
		CTransaction t;
		for (int i = 0; i < txIDs.size(); i++)
		{
			bool retrieved = block->getTransaction(txIDs[i], t);
			if (!retrieved)
			{
				result.setStatus(eBlockVerificationResult::transactionMissing);
				result.setAsLeader(false);
				result.setStore(false);
				return result;
			}

		}

		//check if all the verifiables are there
		std::vector<std::vector<uint8_t>> verIDs = block->getVerifiablesIDs();
		CVerifiable v;
		for (int i = 0; i < verIDs.size(); i++)
		{
			bool retrieved = block->getVerifiable(verIDs[i], v);
			if (!retrieved)
			{
				result.setStatus(eBlockVerificationResult::verifiableMissing);
				result.setAsLeader(false);
				result.setStore(false); // Notice: nowadays we rarely need to abort storage since the heaviest chain-proof dictates what makes its way into Cold Storage.
				//         With the current version of the protocol Heviest Chain Proof dictates what gets downloaded but local processing MIGHT reject processing.
				//		  If processing is rejected, local node would begin generating an alternative history of events - on its own.
				return result;
			}
		}
		if (parent != nullptr)
			initialPerspective = parent->getHeader()->getPerspective(eTrieID::state);//that's the initial Flow perspective.
		//we need to be able to revert to this perspective so the transactions/verifiables can commence and potentially succeed.
		//this will be attempted during the startFlow() sub-routine.
		/* *	*	*	START_THE_VALIDATION_FLOW	*	*	**/

		/*
		The Final Expected Perspective  - a Perspective defined within of a Block. The processing of  a block should result in this Perspective.
		The Final Effective Perspective - the actual Perspective which was reached after processing of a block.

		Under normal conditions, when block validation mechanics are not override by Checkpoints,  The Final Expected Perspective
		MUST match The Final Effective Perspective, before processing of the next block commences.

		The perspective might NOT be available if we haven't processed blocks leading to a particular Perspective.
		Also, if consecutive Core versions changed the EXACT results of processing of compiled Decentralized Processing Threads.
		In such a case - a Checkpoint would be needed.

		Do notice that the below Start Function attempts to initialize Flow mechanics, taking the Final perspective after processing of the parent block.
		Under normal circumstances this would be required to succeed and such a perspective would be REQUIRED to be available locally.
		Still, under a very specific circumstance, in which the parent block was covered by a checkpoint, the parent block might had been processed successfully
		while the Final Perspective (specified within of it) might had never been actually reached and allowed through a Checkpoint instead.

		In such a specific case, the Final Effective Perspective of the current block would differ from the Final Expected Perspective defined within of it.

		The Flow Mechanics (Database-System Transaction-like blocks' processing scheme) are initialized for each and every block which is being processed/ validated.
		The startFlow*() function takes The Final Expected Perspective of its parent block.
		Now, do notice that  perspective MIGHT NOT be available locally had we been processing with a different than the original
		(at the time the block was constructed) version of the Core software. In such a case the block could only have been let through a checkpoint.

		*Still, the Effective Perspective after processing of a Parent Block, in such a case - would be UNKNOWN as far as data within of the parent block are
		concerned.*

		---
		To cope with such a situation, we introduce the storeEffectivePerspective() and getEffectivePerspective function().
		These function take two parameters 1) the ID of a block 2) the Final Effective Perspective.
		These functions may be used ONLY when processing of blocks covered through a Checkpoint
		(the segment of 'check-pointed' blocks OR the single immediate consecutive block after).

		storeEffectivePerspective() - is used to store the Final Effective Perspective after block_N block covered through
		a Checkpoint has been successfully processed.

		getEffectivePerspective() - is then used during processing of block_N+1 within of the startFlow() to retrieve
		Final Effective Perspective of parent since the Final Expected Perspective MIGHT NOT be available.
		---



		*/

		if (currentLeader && currentLeader->getHeader()->getHeight() + 1 != block->getHeader()->getHeight())
		{
			//WRONG??:there is no point to validate data (and so to enter the flow) since the block does not extend the current leader.
			//^ that is because we need to support forking in any place.


			//if the block was scheduled for processing by the local scheduler then it can for out anything
			//since we assume the block is within the Heaviest Chain Proof and assume its validity (in terms of blocks' numerical ordering).
			if (block->getScheduledByLocalScheduler() == false &&
				!(block->getHeader()->isKeyBlock() && (currentLeader->getHeader()->getHeight() >= block->getHeader()->getHeight())))//only key-blocks can fork-out BUT only those that are in the past.
			{
				tools->writeLine(tools->getColoredString("Omitting Flow", eColor::orange) + " - " + " block does not extend current chain.");
				result.setStatus(eBlockVerificationResult::heightNotToBeConsidered);
				result.setAsLeader(false);
				return result;
			}
		}

		if (block->isGenesis() == false && parent)//the initial Perspective MIGHT be empty in case no parent is present. Only in case of the Genesis Block.
		{
			//Checkpoints and Alternative Perspectives - BEGIN
			parentCheckpoint = getCurrentCheckpoint(parent->getHeader());//check for an active checkpoint.



			if (parentCheckpoint)
			{
				cpFlags cf = parentCheckpoint->getFlags();
				//check for a cached Final Effective Perspective for the parent block.

				alternativePerspective = getEffectivePerspective(parent->getID());//check for a cached alternative Perspective.
				//Notice that the cached Effective Perspective would be available only for a parent block which has been already processed locally.

			}
			//Checkpoints and Alternative Perspectives - END

			//choose the Effective Initial Perspective (it must be available).


			if (alternativePerspective.size())//prefer the alternative Effective Perspective if available (only for 'check-pointed' block-segments).
			{
				tools->writeLine("Assuming an " + tools->getColoredString("alternative Initial Effective Perspective", eColor::lightPink) + " " +
					tools->getColoredString(tools->base58CheckEncode(alternativePerspective), eColor::lightCyan));

				initialPerspective = alternativePerspective;
			}
			else {
				initialPerspective = parent->getHeader()->getPerspective(eTrieID::state);

				tools->writeLine("Assuming a " + tools->getColoredString("parental Initial Effective Perspective", eColor::orange) + " " +
					tools->getColoredString(tools->base58CheckEncode(initialPerspective), eColor::lightCyan));
			}
		}
		else if (block->isGenesis())
		{
			initialPerspective = tools->getNullHash();

		}
		else
		{
			result.setStatus(eBlockVerificationResult::eBlockVerificationResult::unableToStartFlow);
			result.setAsLeader(false);
			result.setStore(false); // Notice: nowadays we rarely need to abort storage since the heaviest chain-proof dictates what makes its way into Cold Storage.
			//         With the current version of the protocol Heviest Chain Proof dictates what gets downloaded but local processing MIGHT reject processing.
			//		  If processing is rejected, local node would begin generating an alternative history of events - on its own.
			return result;
		}
		if (result.isLeader())
		{//applies only when scheduled by local Block Scheduler and not a direct network delivery.
		// Leader-Related Considerations - BEGIN


			// Initial Perspective Verification - BEGIN
			if (result.isLeader() && !block->getIsCheckpointed()) // check only once scheduled for Flow processing (not during downloads' verification ; we need in-order processing for this)
			{// notice: checkpointed blocks do not need to have initial perspective matching the current one.
			 // rationale: the processing logic of GridScript commands might have changed.

				std::vector<uint8_t> effectiveInitialCurrentPerspective = initialPerspective; //  getPerspective();
				std::vector<uint8_t> expectedInitialCurrentPerspective = block->getHeader()->getPerspective(eTrieID::state, false); /// supprted since BlockHeader v2
				std::stringstream ass;
				if (expectedInitialCurrentPerspective.size() == 32 && !tools->compareByteVectors(expectedInitialCurrentPerspective, effectiveInitialCurrentPerspective))
				{
					// Use a string stream for improved, multi-line logging.
					std::ostringstream oss;
					oss << "Incoherent initial Perspective when processing "
						<< (result.isKeyBlock() ? "Key" : "Data") << " block " + tools->base58CheckEncode(blockID) + "\n"
						<< "Expected initial perspective: " << tools->getColoredString(tools->base58CheckEncode(expectedInitialCurrentPerspective), eColor::neonBlue) << "\n"
						<< "Effective initial perspective: " << tools->getColoredString(tools->base58CheckEncode(effectiveInitialCurrentPerspective), eColor::synthPink) << "\n";

					// Use a single writeLine call for multi-line output
					tools->writeLine(oss.str());
					blacklistBlock(blockID, 60 * 15);//blacklist for 15 minutes
					result.setStatus(eBlockVerificationResult::eBlockVerificationResult::incoherentInitialPerspective);
					result.setAsLeader(false);//we might need it later on so do not disable storage
					return result;
				}
			}
			// Initial Perspective Verification - END

		//attempt to start Flow only if stil a leader candidate.
			if (result.isLeader() && !verificationFlowManager->startFlow(initialPerspective))//let's begin the transaction flow. 
			{//By default the System Perspective needs to match the final Perspective reported by a PARENT block (if present).
			 //This may be overridden by a checkpoint (yet again, one 'covering' the previous block). 

				if (alternativePerspective.size() == 0)
				{
					
						//serious data integrity error - we're unable to reach the 'parental perspective'.
						//it's either a data integrity error or the team needs to include a checkpoint due to a change in processing.
						tools->writeLine("Unable to reach the Parental Perspective.", eColor::cyborgBlood);

						//we will assume it's a data integrity error.

						//Try to fix things - BEGIN
						bool fixed = false;
						tools->writeLine("Assuming a data integrity error, attempting to fix...", eColor::orange);

						std::shared_ptr<CBlock> l = getLeader();

						if (!tools->compareByteVectors(mVerifiedPath[mVerifiedPath.size() - 1], l->getID()))
						{
							tools->writeLine(tools->getColoredString("Fatal data integrity error (Leader not proclaimed by Verfied Chain).", eColor::cyborgBlood));
							assertGN(false);
						}

						if (currentLeader && currentLeader->getHeader()->getHeight() > 1)
						{
							uint64_t currentLeaderHeight = currentLeader->getHeader()->getHeight();

							if (block->getHeader()->getHeight() && (block->getHeader()->getHeight() - 1 == currentLeaderHeight))
							{
								std::lock_guard<ExclusiveWorkerMutex> lVP(mVerifiedPathGuardian);
								std::lock_guard<std::recursive_mutex> lVP2(mLeaderGuardian);

								//40,145,167
								tools->writeLine("Attempting to remove the current leader..", eColor::lightPink);
								std::vector<uint8_t> currentleaderID = mLeader->getID();
								assertGN(mVerifiedPath.size() > 0 && tools->compareByteVectors(currentleaderID, mVerifiedPath[mVerifiedPath.size() - 1]));
								//store the grandpa leader.
								eBlockInstantiationResult::eBlockInstantiationResult ires;

								//use cache so that pointers are preserved.(otherwise we would neet to reconstruct parent-child pointer relationships).

								// [ IMPORTANT ]: use the 'verfied' chain-proof directly, not a cache, as seen below:
								std::shared_ptr<CBlock>  grandparentLeader = getBlockAtDepth(2, false, eChainProof::verified);//getBlockByHash(mVerifiedPath[mVerifiedPath.size() - 3], ires, true);
								std::shared_ptr<CBlock>  parentLeader = getBlockAtDepth(1, false, eChainProof::verified); //getBlockByHash(mVerifiedPath[mVerifiedPath.size() - 2], ires, true);

								if (grandparentLeader && parentLeader)
								{
									//remove TWO recent blocks from the verified path (parent and grandpaa).

									mVerifiedChainProof.erase(mVerifiedChainProof.begin() + currentLeaderHeight - 1, mVerifiedChainProof.end());
									mVerifiedPath.erase(mVerifiedPath.begin() + currentLeaderHeight - 1, mVerifiedPath.end());
									mLeader = grandparentLeader;//set the grandpa leader. 
									//grandpa leader is thus assumed as trusted. And

									// from 'keyBlockHeight' onward to keep it in sync with the truncated chain proof.
									truncateKeyBlockIDsFromKeyHeight(block->getHeader()->getKeyHeight(), eChainProof::verified);

									mFieldsGuardian.lock();
									mCachedLeader = mLeader;
									if (mLeader->getHeader()->isKeyBlock())
									{
										mCachedKeyLeader = mLeader;
									}
									if (mLeader && mLeader->getHeader()->isKeyBlock())
									{
										mKeyLeader = mLeader;
									}
									mFieldsGuardian.unlock();

									tools->writeLine("The Verified Chain Proof was altered.", eColor::orange);

									tools->writeLine("Attempting to set the Previous Leader..", eColor::lightPink);

									//not the current leader!
									if (setLeader(parentLeader))//  so that all the pow statistics etc. are accounted for.
									{	//next time processing would begin from this leader. The normal blockchain formation would commence.
										//we've just traveled back in time by a single block.
										fixed = true;
										tools->writeLine("Proclaimed previous leader.", eColor::orange);
									}
								}



							}
						}
						else
						{
							tools->writeLine("No leader available.", eColor::orange);
						}

						if (fixed)
						{
							tools->writeLine("Removed faulty leader..", eColor::orange);
						}
						else
						{
							tools->writeLine("Unable to fix..", eColor::cyborgBlood);
						}
						//Try to fix things - END

					
				}

				result.setStatus(eBlockVerificationResult::eBlockVerificationResult::unableToStartFlow);
				result.setAsLeader(false);
				result.setStore(true);

				return result;

			}

			/* *	*	*	VALIDATE TRANSACTIONS - START	*	*	*
		//The block might be empty; empty blocks still secure the chain with their PoW.
		*/
			if (block->getHeader()->isKeyBlock() && block->getVerifiablesCount() == 0)
			{
				verificationFlowManager->abortFlow();
				result.setStatus(eBlockVerificationResult::rewardVerifiableMissing);
				result.setAsLeader(false);
				result.setStore(false); // Notice: nowadays we rarely need to abort storage since the heaviest chain-proof dictates what makes its way into Cold Storage.
				//         With the current version of the protocol Heviest Chain Proof dictates what gets downloaded but local processing MIGHT reject processing.
				//		  If processing is rejected, local node would begin generating an alternative history of events - on its own.
				return result;
			}
			if (block->getTransactionsCount() > 0)
			{
				std::vector<CTransaction> trans = block->getTransactions();

				for (int i = 0; i < trans.size(); i++)
					verificationFlowManager->addTransactionToFlow(std::make_shared<CTransaction>(trans[i]));

			}
			/* *	*	*	VALIDATE TRANSACTIONS - END	*	*	*

			/* *	*	*	VALIDATE VERIFIABLES - START	*	*	*	*/
			if (block->getVerifiablesCount() > 0)
			{
				std::vector<CVerifiable> vers = block->getVerifiables();
				std::vector<CVerifiable*> versP;
				for (int i = 0; i < vers.size(); i++)
					verificationFlowManager->addVerifiableToFlow(std::make_shared <CVerifiable>(vers[i]));

			}
			/* *	*	*	ABORT_THE_VALIDATION_FLOW	*	*	**/ // (and do the actuall processing)
			std::vector<CReceipt> receiptsL;
			std::vector<uint8_t> finalPerspective;
			std::string errorMsg;
			//right now we are just validating the block proposal.


			if (verificationFlowManager->endFlow(false, true, false, errorMsg, receiptsL, finalPerspective, true, block) != success)
			{
				tools->writeLine("Analyzed block proposal was invalid (" + errorMsg + ")");
				result.setStatus(eBlockVerificationResult::eBlockVerificationResult::flowInvalid);
				result.setAsLeader(false);
				result.setStore(false); // Notice: nowadays we rarely need to abort storage since the heaviest chain-proof dictates what makes its way into Cold Storage.
				//         With the current version of the protocol Heviest Chain Proof dictates what gets downloaded but local processing MIGHT reject processing.
				//		  If processing is rejected, local node would begin generating an alternative history of events - on its own.
				return result;
			}

			/* *	*	*	VALIDATE VERIFIABLES - END	*	*	*	*/
				/* *	*	*	VALIDATE THE RESULTING PERSPECTIVE  - START	*	*	*	*/
			std::vector<uint8_t> supposedPerspective = block->getHeader()->getPerspective(eTrieID::state);
			if (supposedPerspective.size() != 32)
			{
				result.setAsLeader(false);
				result.setStore(false);
				return eBlockVerificationResult::eBlockVerificationResult::invalid;
			}
			//Error: the supposed perspective is the same as the current leader's.why?
			std::vector<uint8_t> actualPerspective = finalPerspective;

			if (tools->compareByteVectors(supposedPerspective, actualPerspective))
				dataCoherent = true;
			/*	*	*	*	VALIDATE THE RESULTING PERSPECTIVE  - END	*	*	*	*/
			if (!dataCoherent)
			{
				if (!checkpoint)
				{
					// Use a string stream for improved, multi-line logging.
					std::ostringstream oss;
					oss << "Incoherent result when processing "
						<< (result.isKeyBlock() ? "Key" : "Data") << " block " + tools->base58CheckEncode(blockID) + "\n"
						<< "Expected perspective: " << tools->getColoredString(tools->base58CheckEncode(supposedPerspective), eColor::neonBlue) << "\n"
						<< "Effective perspective: " << tools->getColoredString(tools->base58CheckEncode(actualPerspective), eColor::synthPink) << "\n";

					// Use a single writeLine call for multi-line output
					tools->writeLine(oss.str());
					result.setAsLeader(false);
					result.setStore(false);
					result.setStatus(eBlockVerificationResult::eBlockVerificationResult::inconsistentFinalPerspective);

					
					return result;
				}
				else
				{
					cpFlags cf = checkpoint->getFlags();
					//check if there is an explicit perspective provided within of the Checkpoint.
					std::vector<uint8_t> checkpointPerspective = checkpoint->getPerspective();

					if (checkpointPerspective.size())
					{
						tools->writeLine("Rejecting block. Perspective does not match the one in checkpoint.", eColor::lightPink);
						if (!tools->compareByteVectors(checkpointPerspective, actualPerspective))
						{
							result.setAsLeader(false);
							result.setStore(false); // Notice: nowadays we rarely need to abort storage since the heaviest chain-proof dictates what makes its way into Cold Storage.
							//         With the current version of the protocol Heviest Chain Proof dictates what gets downloaded but local processing MIGHT reject processing.
							//		  If processing is rejected, local node would begin generating an alternative history of events - on its own.
							result.setStatus(eBlockVerificationResult::eBlockVerificationResult::inconsistentFinalPerspective);
							return result;
						}
					}
					else
					{
						tools->writeLine("Warning: inconsistent perspective. Block allowed due to an " +
							std::string((checkpointPerspective.size() ? "explicit " : "implicit")) + std::string((cf.obligatory ? "obligatory " : " ")) + "checkpoint.");
					}
				}
			}



			if (checkpoint)
			{
				std::vector<uint8_t> cpExpectedPerspective = checkpoint->getPerspective();
				if (cpExpectedPerspective.size() && !tools->compareByteVectors(cpExpectedPerspective, actualPerspective))
				{
					result.setAsLeader(false);
					result.setStore(false); // Notice: nowadays we rarely need to abort storage since the heaviest chain-proof dictates what makes its way into Cold Storage.
					//         With the current version of the protocol Heviest Chain Proof dictates what gets downloaded but local processing MIGHT reject processing.
					//		  If processing is rejected, local node would begin generating an alternative history of events - on its own.
					result.setStatus(eBlockVerificationResult::eBlockVerificationResult::inconsistentFinalPerspective);
					return result;
				}
			}

			/* *	*	*	VALIDATE THE RESULTING PERSPECTIVE  - END	*	*	*	*/

			/* *	*	*	VALIDATE THE TOTAL-FEES VALUE  - BEGIN	*	*	*	*/

				//for this it suffices to check if Receipt from the leader's reward verifiable is OK
				//that's where the check already took place.

				/* *	*	*	VALIDATE THE TOTAL-FEES VALUE  - END	*	*	*	*/

			// Leader-Related Considerations - END
		}
		return result;
	}
	catch (...)
	{
		result.setAsLeader(false);
		result.setStore(false); // Notice: nowadays we rarely need to abort storage since the heaviest chain-proof dictates what makes its way into Cold Storage.
		//         With the current version of the protocol Heviest Chain Proof dictates what gets downloaded but local processing MIGHT reject processing.
		//		  If processing is rejected, local node would begin generating an alternative history of events - on its own.
		result.setStatus(eBlockVerificationResult::criticalFailure);
		return result;
	}
	//Operational Logic -  END
}

bool CBlockchainManager::cutHeaviest(uint64_t height, bool fromConsole)
{
	std::shared_ptr<CTools> tools = getTools();

	// Pre-flight checks
	eViewState::eViewState view = fromConsole == false ? eViewState::unspecified : eViewState::GridScriptConsole;

	if (!height)
	{
		tools->writeLine(tools->getColoredString("Height must be greater than 0 for cutting operation.", eColor::lightPink), view);
		return false;
	}

	// Create progress manager for operation feedback
	auto flashManager = FlashingProgressManager(
		mTools,
		"Cutting Heaviest Chain..",
		[]() { /* Optional completion callback */ }
	);

	auto progress = flashManager.createScoped(false);

	// Lock relevant mutexes for heaviest chain operations
	sync::SynchronizedLocker lock(
		sync::LockingPolicy::SequenceOrdered,
		mHeaviestPathGuardian,
		mHeaviestPathDoubleGuardian,
		mLeaderGuardian,
		mCacheOperationGuardian
	);

	progress.update(30.0);

	// Validate height against existing data structures
	bool heightOutOfRange = mHeaviestChainProof.size() <= height ||
		mHeaviestPath.size() <= height;

	if (heightOutOfRange)
	{
		tools->writeLine(tools->getColoredString("Invalid height provided: " + std::to_string(height), eColor::lightPink), true, false, view);
		return false;
	}

	progress.update(50.0);

	// Cut heaviest chain related containers
	mHeaviestChainProof.resize(height + 1);
	mHeaviestPath.resize(height + 1);

	// Update the double-guarded containers
	mHeaviestPathDoubleGuardian.lock();
	mHeaviestPathDouble.resize(height + 1);
	mHeaviestPathDoubleGuardian.unlock();

	// Recalculate total difficulty for heaviest chain
	uint64_t newTotalDifficulty = 0;
	std::vector<std::uint64_t> pows; // for tracking proof of work if needed
	for (size_t i = 0; i < mHeaviestChainProof.size(); ++i)
	{
		// Add difficulty calculation based on your specific implementation
		// This is a placeholder - implement according to your difficulty calculation logic
		// newTotalDifficulty += calculateDifficulty(mHeaviestChainProof[i]);
	}
	mHeaviestChainProofTotalDifficulty = newTotalDifficulty;

	progress.update(70.0);

	// Save modified structures
	setPath(mHeaviestPath, eChainProof::heaviest, true);
	setChainProof(mHeaviestChainProof, eChainProof::heaviest, true);

	progress.update(90.0);

	// Update cumulative PoWs if necessary
	mHeaviestChainProofCumulativePoWs.resize(height + 1);

	// Clear network manager's relevant data if needed
	std::shared_ptr<CNetworkManager> nm = getNetworkManager();
	if (nm)
	{
		nm->forgetReceivedChainProofs();
	}

	progress.complete();

	//todo: set heaviest cached leader and haviest leader

	// Confirmation
	tools->writeLine("[CONFIRMATION]" + tools->getColoredString(" heaviest chain was cut at height " + std::to_string(height), eColor::lightGreen), true, false, view);
	return true;
}

bool CBlockchainManager::registerReceiptWithinCache(const CReceipt& rec, const std::vector<uint8_t>& blockID, bool useHotStorage)
{

	std::lock_guard<std::recursive_mutex> lock(mReceiptsGuardian);

	if (useHotStorage)
	{
		addReceiptToHotCache(std::make_shared<CReceipt>(rec));
	}

	if (mReceiptsBlocksIndex.size() > mMaxReceiptsIndexCacheSize)
	{
		auto it = mReceiptsBlocksIndex.cbegin();

		while (it != mReceiptsBlocksIndex.cend() && mReceiptsBlocksIndex.size() > mMaxReceiptsIndexCacheSize)
		{
			it = mReceiptsBlocksIndex.erase(it);//this can be safely done as the erase method returns the next element after the one being delted
			++it;
		}
	}
	mReceiptsBlocksIndex[const_cast<CReceipt&>(rec).getGUID()] = blockID;
	return true;

}


/// <summary>
/// Performs block validation. *Extreme*, meticulous care needs to be taken over here.
/// Note: The essential security validation has been done during  Block's instantiation.
/// The function is capable of verifying both Key and Regular blocks.
/// 
/// </summary>
/// <param name="block"></param>
/// <returns></returns>
CBlockVerificationResult CBlockchainManager::validateBlock(std::shared_ptr<CBlock> block)
{

	//LOCAL Variables - START
	std::vector<uint8_t> blockID;
	//CBlockVerificationResult result(eBlockVerificationResult::eBlockVerificationResult::invalid, blockID);
	bool aimsToExtendTheCurrentChain = false;

	//LOCAL Variables - END


	/*
	* [The Verified and Heaviest Chain Proofs described] - BEGIN
	*
	* *[Double buffering of the History of Events] - BEGIN
	*
	* [In Brief]: blocks described by the The Heaviest Chain Proof steadily make their way into the Verified Chain Proof as they are both downloaded
	* and verified, on a per-block basis, in order. Nodes exchange (sub)chain(s) of the Verified Chain Proof only. At some points in time both chains might be the same which
	* might be especially true for the current round leader.
	*
	* [ Chain Proof vs Longest Path rationale]
	* Chain proof is a sequence of instantiated headers. A 'path' on the other hand is just a sequence of block identifiers. Thus, the latter is much
	* faster to process and utilizes less memory. Serves mainly as a look-up sequence. Always in sych with the respective Chain Proof.
	*
	* [The Heaviest Chain Proof] - it does NOT lead to the current world view i.e. to the current state of the DSM as far as the local node is concerned.
	* Not until it is verified. However, it  represents the heaviest (in terms of cumulative PoW) history of events encountered in the wild. I.e it does
	* lead to the state of the DSM as far as the Network is concerned.
	*
	* Notice: Any chain proof is not enough to validate contents of data blocks as these are not present within. Still, it is enough to validate integrity of a particular
	* sequence of blocks through verification of PoW and signatures (coupling data blocks).

	The Heaviest Chain Proof is maintained by each node locally and assumed as not-trusted, until verified - as it steadily transitions into the The Verified Chain Proof,
	as a result of a block-by-block verification and processing. The Heaviest Chain Proof thus helps lower data-exchange overheads as peers search for and exchange only blocks as dictated by the
	history of events verified through PoW (and signatures) in the case of data-blocks.
	This also mitigates attacks in which an attacker would broadcast falsified versions of blocks, making other nodes
	waste both bandwidth and processing power.

	*
	* [The Verified Chain Proof] - as blocks from the Heaviest Chain Proof are sequentially verified,
	* they steadily make their way into the Verified Chain Proof. It is the representation of the current trusted and best known history of events (from the local perspective).
	* It thus represents the 'path' to the actual current state of the Decentralized State Machine. It leads to the current world-view. In other words, processing of blocks
	* referenced within it leads to the current state of the DSM.
	*
	* The Verified and Heaviest Chain Proofs described - END
	*
	* *Double buffering of the History of Events - BEGIN
	*
	 [Block synchronization mechanics described] - BEGIN

	 [At the beginning, each node kick-starts with generation of its own history of events (extending upon both the Verified and Heaviest Chain Proof), locally.
	 Just like it would be the only node in town.
	 Most likely, it is quickly to get to know, though, that others might be having a much better i.e. heavier histories of events. In the face of that, the node halts all mining operations up UNTIL
	 it deems to be having any chance of winning.]

	 [The construction of the Heaviest Chain-Proof]:

	1) A tells B: 'hey! my total PoW is X and the total length of the history of events is Y (the latter to account for both the key and data blocks)'
	Note: the above claim is NOT trusted by B in ANY way. It is just to catch B's interest.
	2) B answers A with: 'oh ,really? Show me your Chain Proof at once! These are the checkpoints I hereby provide. I want it, the Chain Proof which you are to deliver,-
	to start at any of these. Oh, as for that matter, I want you to choose the nearest i.e. latest checkpoint which overlaps with your Verified Chain Proof (NOT the Heaviest one!)
	as I do NOT care about the alternative histories of events which you have NOT managed to fully verify yourself, at least as of yet. Be quick please. Every ms counts.'.

	Note: the last checkpoint, provided by B to A is the Genesis block. Arbitrary number of consecutive, ordered checkpoints may be provided after it, though.

	‌3) B compares the received (sub)Chain Proof with the Heaviest Chain Proof on file. The (resulting) Heaviest Chain-Proof
	always wins - i.e the local one is replaced INSTANTLY by analyzeAndUpdateChainProof().

	([IMPORTANT]: that stays in contrast with the Verified Chain Proof as it is altered ONLY as a result of individual blocks' analysis
	i.e. commitment attempts, during Flows,- as described below).
		[CODE]: *[Heaviest Chain Proof]: updating is taken care of by analyzeAndUpdateChainProof() - the function is capable of taking both the entire Chain Proofs AND sub-Chain Proofs.
				It would attempt to find a common point, in both cases, and update the provided target Chain Proof accordingly. The function triple checks not to modify the
				local Verified Chain Proof, even if provided as a parameter (pointer comparison).
				Under the hood the function employs verifyChainProof() which first verifies
				the provided (sub)chain, in terms of both data integrity and the cumulative PoW - represented by the provided (sub)chain only.
				The provided sub-chain is then concatenated with the one on file, if needed - in case the first argument was a sub-chain, and the cumulative PoW of the resulting full Heaviest Chain Proof (proposal)
				is compared with what had been previously established (previous version of the Heaviest Chain Proof).
				The heavier chain wins. The old one is replaced.

				*[Verified Chain Proof]: Modified only during a Flow. Proclaimed Leader always rules.
				The function updatePathWithLeader(), invoked by setLeader(), during but at the end of a Flow -
				within of processBlock(). The first, invokes setChainProof() and setPath(), updating both the Verified Chain Proof and the Longest Path,
				based on the current leading block. The function would truncate the current history of blocks, within both, and inject the leading block, as needed.
				IMPORTANT: This is the only place, the Verifies Chain Proof gets to be modified.
				===> processBlock() is invoked only on the first, not yet processed block from the Heaviest Chain Proof. All prior blocks need to be available
				locally, otherwise the process would not succeed, with an appropriate error result returned.  It always suffices to invoke processBlock() on the
				most recent block as all the prior would be retrieved from the local cold storage as needed during verification of the new-chain proposal.

	+ updatePathWithLeader() is called for both Key and Data blocks i.e. meta-data regarding both are present.

	[BLOCK PROCESSING]:

	Current leader keeps forming blocks and directly pushing these for processing through pushBlock(). The resulting chain-proofs are affected and updated during processing.
	All nodes (including the current leader) also attempt to process blocks referenced within the Heaviest Chain Proof also by calling pushBlock() it all relies
	on the very same block processing queue. Locally produced blocks are enqueued first as each node is rational.

‌	+ Blockchain Manager processes ONLY blocks referenced within the Heaviest Chain Proof. In order. One by one.
	  In other words, external nodes cannot influence local processing of arbitrary data-blocks, unless, the headers of these have been verified,
	  - as part of a received Heaviest Chain Proof, and the node has locally confirmed that these indeed make up the Heaviest Chain Proof
	  (in terms of the cumulative Proof-of-Work) history of events.
	+ Chain-Proof includes headers of both the Key Blocks and the Data Blocks. First is prioritized PoW, then - the total length of both the Key and Data blocks.
‌	+ verifyChainProof() enqueues locally available blocks for processing.
	  It traverses the Heaviest Chain Proof, by going from the earliest to the latest available block - in order.
	 [Traversal]: During the traversal, first, a common point between the Verified and the Heaviest chain-proof needs to be found.
			Second, the function checks whether the next following block (not yet part of the  Verified Chain Proof) is available locally,
			and if so - it enqueues it for processing.

	+ Network Manager constantly queries nodes for the looked-for blocks, by looking at the Heaviest Chain Proof.
	  A keeps asking other nodes: 'Hey! I'm looking  for block: [Hash] you got it?.
	  B responds either with 'sure! my per-byte data delivery fee is XYZ.' or with 'nope'.

	  Now, A can decide whether to fetch.. and pay.

‌	+ locally missing blocks (yet referenced within of the Heaviest Chain-Proof) are marked and thus scheduled for download.
‌	+ the chain proof processing function dispatches the earliest, not yet processed block referenced within the Heaviest Chain Proof for processing.
‌	+ [IMPORTANT]: only the block processing function, during a Flow, can alter the Verified Chain Proof i.e. acting on a per-block basis.

	Block synchronization mechanics described - END
	*/


	/*
	- Block verification mechanics (simplified) -

	Overall::

	+ Received blocks are processed with respect to the current key- and data- block leaders ONLY.

	+ We maintain TWO separate, distinct (possibly) chain-proofs. The mVerfifiedChainProof and mHeaviestChainProof.

	+ mVerfifiedChainProof is the chain-proof whose blocks have been fully verified (locally!) (transactions processed etc.), leading to the current
	mLeader and mKeyLeader

	+ all responses to other nodes are based on the mVerfifiedChainProof (doing otherwise would open the network to be susceptible to an attack where attacker extends the chain but withholds blocks)
	NOTE: we DO NOT want an army of zombies following the heaviest chain. We want nodes to actually verify the incoming data-blocks. And be sure that we can deliver when asked for.

	+we DO NOT save/download and/or process blocks that are too far behind the mHeaviestChainProof (i.e. threshold). reason: why should we keep mining
	or waste storage on old blocks if the probability of them being useful is negligible (yes, it wouldn't be possible to fork the chain below certain threshold - that's good.- an assumption)

	+[BLOCK DOWNLOADING]: before we download any block from another peer, the peer is asked to provide a chain-proof (for 3 distinct 'fall-back' points, the worst case is when the other peer finds a match only starting at the 3rd fall-back point which is the Geneis block
	,which is when, the other peer needs to transmit the entire chain-proof to us, for verification). For each received chain-proof we do analyzeAndUpdateChainProof(), if the function returns saying that the main, heaviest chain proof has been updated, we proceed with downloading
	of the block/blocks. (note: the current version of analyzeAndUpdateChainProof automatically marks missing blocks for download).

	+The above prevents various kinds of SPAM attacks. For instance
	it is not possible to verify a data-block (no weight) without knowing its parental key-block. The chain-proof ensures the required amount of PoW was performed.

	+ as a result, blocks outside of the heaviest known chain-proof are never to be processed (that is GOOD, if a neighboor presents us with a proper chain-proof, THEN we become interested
	in these blocks , IF AND ONLY IF, the chain-proof results in heaviest cumulative PoW - by looking at key-block headers ONLY)

	+ [NOTE 1]: thus, when broadcasting chain-proofs, the total cumulative PoW has HIGHER priority than the actual validity of transactions. They are not verified at this stage, but later.
	Nodes choose whether to download blocks based on the acquired chain-proofs.
	That is to protect against SPAM and against waste of storage for blocks that wouldn't make it to the final chain anyway.

	+For a block, to be assumed as a leader, => it NEEDS TO result in the heaviest chain.
	[Note 2]: data-blocks do not contain ANY weight, THUS for a data block to be considered as a Leader, it needs to be an offspring of the current Key-Block Leader (mKeyLeader)
	and have index higher by *exactly ONE* compared to the already known data-block offspring (mLeader).

	+ the BlockchainManager is always 'mining' on mKeyLeader (on success, it includes a signature of the best known data-block on success into the key-block-leader-proposal).

	+  mHeaviestChainProof is IGNORED during mining AND it is ignored during data-broadcasting/network inquiries.
	[Rationale]: if we were NOT able to verify the transactions we WON"T assume the proclaimed headers as valid. Once we verify the missing blocks, they'll make it to the mVerfifiedChainProof.
	Still, the pow performed is enough for us to make decision as whether download blocks in a given path or not and whether to continue mining on the current verified by us leader
	or if it would be better to download the missing blocks.
	[NOTE 3]: Whereas, the heaviest chain rule has highest priority when broadcasting information, -i.e. when deciding whether to download blocks. yet
	it has lower priority when doing block verification/mining operations.
	We *WILL NOT* be mining on a block by knowing parent's hash *WE WANT* to fully validate all the transactions, perspectives. No exceptions.

	+ The perspective in block B_i+1 always needs to be a result of parent's 'Perspective' (Merkle-Patricia State-Trie's hash) AND transactions/verifiables present in B_i+1

	+ When processing block B_i+1 we always begin the Flow starting from  Perspective available in B_i.
	The result of Flow processing needs to match the Perspective given in B_i+1. Otherwise, the block is assumed to be INVALID, it is NOT even stored.

	+ We *NEED* two chain-proofs. Although, mVerfifiedChainProof is used mainly (mining, responses to other peers), the mHeaviestChainProof is used for strategic decisions (should we keep
	mining on the current leader? do we have a change to win the race?) and for knowing what blocks are needed to be downloaded.

	+ The NetworkFactory would always be outlooking for a better mHeaviestChainProof, if a better is found, it would immediately replace the one currently proclaimed.
	IMPORTANT: as soon as it if fully verified it would replace mVerfifiedChainProof as well.

	Thus,

	+ The BlockchainManager would ALWAYS keep trying to verify the validity of mHeaviestChainProof by processing blocks starting from
	the block one after a block whose perspective is known/verifiable/achievable.

	[Algorithm]: Thus, the mHeaviestChainProof would be traversed backwards, up towards older blocks, while encountered block IDs are cached
	during traversal; once a block whose Perspective is achievable (can be retrieved), we would start going back, the other way, towards newer blocks in an attempt to fetch them from Cold Storage(HDD)
	and PROCESS. Note: blocks MIGHT NOT be available locally. If a single block fails verification the entire mHeaviestChainProof is assumed to be INVALID. IF a block is verified properly and IF
	the total cumulative weight at this height EXCEEDS the total cumulative weight of mVerfifiedChainProof, then AND ONLY THEN, the part of mHeaviestChainProof *UP TO THIS BLOCK* is assumed as mVerfifiedChainProof.
	Note mutex-protection during data-copies.

	[Data exchange]
	[classified information] part of CI appendix 2. To be made available for public after publication.


	#Data-block processing#:
	+ fetch the parent-key-block by traversing the chain starting from the reported parent (key or data-block)
	assume the first encountered key-block as the parent-key-block (PKB)
	+ the signature would be verified using pubKey from within the PKB
	+ IF the verified block is NOT an offspring of the currently leading key-block the block WOULD NOT be assumed as leader
	+ it might happen that a block B_i+1 was delivered before block B_i. In such a case, the verification of block B_i+1 would FAIL, BUT
	the block B_i+1 would be chosen to be saved to Cold Storage anyway (if other semantics are ok).
	Later on, once B_i arrives and is properly verified,  B_i+1 would have a chance to be
	properly verified again. The second verification of B_i+1 would trigger ONLY upon arrival of B_i+2. (we do not keep already verified blocks within the block-processing queue)

	#Key-block processing#:
	+ check if the block's PoW results in the heaviest cumulative chain - if not then DO NOT assume as leader
	+ check if Flow valid (transactions, verifiables etc.)
	+ the key-block can fork-out anything (BUT for the Genesis Block), whereas the data-block can not-out the key-block above it.
	+IF any ONLY if, the full-chain up to this point has been verified of which a successful flow is an indicator of
	(as flow processing of each block starts from its parent's Perspective i.e. hash of the decentralized state machine's global state)
	*/

	try {
		std::lock_guard<std::recursive_mutex> lock(mBlockProcessingGuardian);
		setBlockProcessingStatus(eBlockProcessingStatus::validating);

		//the initial (risky) presumption is that we're dealing with a new Leader
		//all the tests below (and future data fuzzing test are to ensure that a wrong leaedr is NEVER proclaimed)
		//if a function makes a Retun it ALWAYS needs to set that the block IS NOT a leader if it shouldn't be.

		//Note: the current Leader (either key-block or data-block) has the power of the current Perspective; which in short is the hash of the current state of things.
		//The Perspective represents the current balance of all the accounts - among others.


		CBlockVerificationResult result = doCommonVerification(block);
		//intermediary validation results are passed on to specialized verifierspi

		if (result.getStatus() != eBlockVerificationResult::eBlockVerificationResult::valid)
		{
			if (!block->getScheduledByLocalScheduler())
			{
				return result;
			}
			else
			{
				result.setStatus(eBlockVerificationResult::prevalidationOnly); // override status if any
				//  ^--- [ RATIONALE ]: we have specific flags instructing whether the block is to be saved or not etc.
				//       Consider introducing a 'prevalidaitonOnly' flag instead of using processing result.
				//       Notice: prevalidationOnly result has massive implications once returned - basically all the security measures are avoided.
				return result;
			}
		}

		if (!block->getScheduledByLocalScheduler())
		{
			result.setStatus(eBlockVerificationResult::prevalidationOnly);
			result.setAsLeader(false);//to prevent Flow Mechanics
		}
		result = doDataPartVerification(block, result);

		if (result.isKeyBlock())//additional verification for key-blocks
		{//note: a data block whose parent-key block is not  the currently leading key-block would never become a leader 
			result = doKeyPartVerification(block, result);
		}


		return result;
	}
	catch (...)
	{
		return CBlockVerificationResult(eBlockVerificationResult::eBlockVerificationResult::criticalFailure);
	}
}

void CBlockchainManager::setBlockProcessingStatus(eBlockProcessingStatus::eBlockProcessingStatus status)
{
	std::lock_guard<std::mutex> lock(mProcessingStatusGuardian);
	mProcessingStatus = status;
}

eBlockProcessingStatus::eBlockProcessingStatus CBlockchainManager::getBlockProcessingStatus()
{
	std::lock_guard<std::mutex> lock(mProcessingStatusGuardian);
	return mProcessingStatus;
}

/// <summary>
/// Resets the heaviest-chain-proof to what is known in mVerifiedChainProof. 
/// used for maintanance and testing.
/// </summary>
/// <returns></returns>
bool CBlockchainManager::resetHeaviestChainProof()
{
	// Use MemoryOrdered policy to prevent deadlocks
	sync::SynchronizedLocker lock(sync::LockingPolicy::MemoryOrdered, mChainGuardian, mVerifiedPathGuardian, mLeaderGuardian, mHeaviestPathGuardian);

	getTools()->writeLine("Proceeding with heaviest chain-proof reset..");
	assertGN(setChainProof(mVerifiedChainProof, eChainProof::heaviest));
	assertGN(setPath(mVerifiedPath, eChainProof::heaviest));
	return true;
}
std::vector<uint8_t> CBlockchainManager::getLocalPeerId()
{
	std::lock_guard<std::mutex> lock(mLocalPeerIDGuardian);
	return mLocalPeerID;
}
void CBlockchainManager::setLocalPeerId(std::vector<uint8_t> id)
{
	std::lock_guard<std::mutex> lock(mLocalPeerIDGuardian);
	mLocalPeerID = id;
}
void CBlockchainManager::pingLastTimeStatsToFile()
{
	std::lock_guard<std::mutex> lock(mFieldsGuardian);
	mLastTimeStatsToFile = getTools()->getTime();
}
uint64_t CBlockchainManager::getLastTimeStatsToFile()
{
	std::lock_guard<std::mutex> lock(mFieldsGuardian);
	return mLastTimeStatsToFile;
}

void CBlockchainManager::clearCheckpoints()
{
	std::lock_guard<std::mutex> lock(mCheckpointsGuardian);
	for (uint64_t i = 0; i < mCheckpoints.size(); i++)
	{
		mCheckpoints[i]->setIsActive(false);
	}
}

uint64_t CBlockchainManager::getForcedResyncSequenceNumber(eBlockchainMode::eBlockchainMode mode)
{
	uint64_t toRet = 0;
	switch (mode)
	{
	case eBlockchainMode::LIVE:

		break;
	case eBlockchainMode::TestNetSandBox:
	case eBlockchainMode::TestNet:
		toRet = FORCED_RESYNC_SEQUENCE_NUMBER;
		break;
	case eBlockchainMode::LIVESandBox:
		break;

	case eBlockchainMode::LocalData:
		break;
	case eBlockchainMode::Unknown:
		break;
	default:
		break;
	}

	return toRet;

}

void CBlockchainManager::loadCheckpoints()
{


	std::lock_guard<std::mutex> lock(mCheckpointsGuardian);
	if (mCheckpoints.size())
		return;//already loaded.

	std::vector<uint8_t> tempBytes;
	cpFlags flags;
	switch (mMode)
	{
	case eBlockchainMode::LIVE:
		break;
	case eBlockchainMode::TestNet:
	case eBlockchainMode::TestNetSandBox:
		//IMPORTANT: ****** update the  getCheckpointsCount() method above ******* CURRENTLY: 1
		flags.obligatory = true;


		mTools->base58CheckDecode("pzu8CNKbA3kuutS3jJ8UBRhojZJ7Z1R36DGNWfcJaA9F4sqvV", tempBytes);
		mCheckpoints.push_back(std::make_shared<CBCheckpoint>(flags, 13668, tempBytes));


		mTools->base58CheckDecode("JyTvdoA2BgDNGT3HjiVPT3XcZn55eK7x4YXUpvJAk46HfrN5F", tempBytes);
		mCheckpoints.push_back(std::make_shared<CBCheckpoint>(flags, 21237, tempBytes));

		mTools->base58CheckDecode("FBqJEPcXUsrAR7dBwMnnqMUuRhyxt214TvCX6eEjeiHYbdwG6", tempBytes);
		mCheckpoints.push_back(std::make_shared<CBCheckpoint>(flags, 23911, tempBytes));

		mTools->base58CheckDecode("2wMmH92iPAyAmiUGyf1m3KmPLAzKcuRNvz97Udrno6LB4oaG5n", tempBytes);
		mCheckpoints.push_back(std::make_shared<CBCheckpoint>(flags, 27600, tempBytes));

		mTools->base58CheckDecode("peVBBas9aejTJw3j3KXfTRVCNgCXGerusH2ZrrYCDSC9pzmd2", tempBytes);
		mCheckpoints.push_back(std::make_shared<CBCheckpoint>(flags, 28489, tempBytes));

		mTools->base58CheckDecode("SFEotoxEtTc9bQdeBiEaqyTuQHCqyFndiMRToqXuMARY28Fqo", tempBytes);
		mCheckpoints.push_back(std::make_shared<CBCheckpoint>(flags, 30864, tempBytes));

		mTools->base58CheckDecode("215vf8pjhrwystmiQHtJAUqtghs1QPujeuBhkZEwDGCqJRor9b", tempBytes);
		mCheckpoints.push_back(std::make_shared<CBCheckpoint>(flags, 34515, tempBytes));
		mTools->base58CheckDecode("215vf8pjhrwystmiQHtJAUqtghs1QPujeuBhkZEwDGCqJRor9b", tempBytes);//duplicate yes
		mCheckpoints.push_back(std::make_shared<CBCheckpoint>(flags, 34515, tempBytes));

		mTools->base58CheckDecode("2HA8671BcyTL3S5azCeowfCDrwZ2TggewvRgU1Vs4HMLG2gDj7", tempBytes);
		mCheckpoints.push_back(std::make_shared<CBCheckpoint>(flags, 34703, tempBytes));

		mTools->base58CheckDecode("WJMav3n7iAJsD1LhaXcj1BHrkQ24px1fQCpTJe18B5rb1xYSq", tempBytes);
		mCheckpoints.push_back(std::make_shared<CBCheckpoint>(flags, 37737, tempBytes));


		mTools->base58CheckDecode("jFivJrVSMZsu9hJmb99RBYTtHqn64VrDd1Jpc62K6KGZXdhCS", tempBytes);
		mCheckpoints.push_back(std::make_shared<CBCheckpoint>(flags, 60274, tempBytes));

		mTools->base58CheckDecode("rou162x6VX6EWk2n9rNA2K2Er8wynJDmHMKpGRfvRsr7eYBvY", tempBytes);
		mCheckpoints.push_back(std::make_shared<CBCheckpoint>(flags, 60902, tempBytes));

		mTools->base58CheckDecode("oF7Z9NtzJAiaN7EPG2g4egJvGsPiKozttG4mxSefpqoyyCVu2", tempBytes);
		mCheckpoints.push_back(std::make_shared<CBCheckpoint>(flags, 82037, tempBytes));

		mTools->base58CheckDecode("Yb595uGzuLJnDxGXdttUJrUM6TVu5azwZAtcMDxBX3NbiP8u7", tempBytes);
		mCheckpoints.push_back(std::make_shared<CBCheckpoint>(flags, 84168, tempBytes));
		// ^--- [ Prior Hard Forks ] 

		// Checkpoint 1 - the point at which we are forking (latest leading block). 
		// Checkpoint 2 - heihgt of a block produced as a result of the Interactive Stage.

		// Latest Hard Fork Point - BEGIN

		// 1) Comment the below [ Part A ] out:
		//   So that during Interactive Procedure the detected number of checkpoints does not change - we do not want full re-sync to trigger, just yet).
		// 	Thanks to this other operators would not need to re - sync from Genesis Block. < -THIS IS * HIGHLY * DISCOURAGED.

		//LATEST:
	
	
		mTools->base58CheckDecode("2ibWEynesS5oegS52dfbERETT1ZB4uWyWEf18NbzeJPdAidShE", tempBytes);
		mCheckpoints.push_back(std::make_shared<CBCheckpoint>(flags, 90075, tempBytes)); // [ WARNING ] CVE_804 - from this hard fork onwards - TX Failures in the past PREVAIL to post future Hard Forks.




		// TEST - BEGIN
		//mTools->base58CheckDecode("2r3A1aQkLU6Wkj9ffkBwhYKdWo3oLvajoh51F5ZmYktAuwC6BJ", tempBytes);
		//mCheckpoints.push_back(std::make_shared<CBCheckpoint>(flags, 89997, tempBytes));
		// TEST - END

		// Latest Hard Fork Point - END

		// 2) During Interactive Hard Fork Step Uncomment the below:
		//mTools->base58CheckDecode(FORK_POINT_ID, tempBytes);
		//mCheckpoints.push_back(std::make_shared<CBCheckpoint>(flags, FORK_POINT, tempBytes));

		// After Checkpoint 2 produced:
		// 3) Copy [ Part A ] to  [ Prior Hard Forks ] (uncommented).
		// 4) Update [ Part A ] to describe Checkpoint 2
		// 5) Increment checkpoints' count  (above in getCheckpointsCount() ).


		//mTools->base58CheckDecode("rou162x6VX6EWk2n9rNA2K2Er8wynJDmHMKpGRfvRsr7eYBvY", tempBytes);
		//mCheckpoints.push_back(std::make_shared<CBCheckpoint>(flags, 60902, tempBytes));
		/*
			[IMPORTANT]: changes to GRIDNET Core might result in a need for a hard-fork.
						 How to tell? When new node synchronizes from Genesis Block and a block at blockchain height
						 equal to Hard Fork Point + 1 cannot be accepted due to a reported 'Invalid Perspective'.
		*/
		break;
	case eBlockchainMode::LIVESandBox:
		break;
	case eBlockchainMode::LocalData:
		break;
	case eBlockchainMode::Unknown:
		break;
	default:
		break;
	}
}

uint64_t CBlockchainManager::getChainProofCSSyncTime(eChainProof::eChainProof which)
{
	std::lock_guard<std::mutex> lock(mFieldsGuardian);
	switch (which)
	{
	case eChainProof::verified:
		return mVerfiedChainCSSyncTimestamp;
		break;
	case eChainProof::verifiedCached:
		return 0;
		break;
	case eChainProof::heaviest:
		return mHeaviestChainCSSyncTimestamp;
		break;
	case eChainProof::heaviestCached:
		return 0;
		break;
	default:
		break;
	}
	return 0;
}

void CBlockchainManager::pingChainProofCSSyncTime(eChainProof::eChainProof which)
{
	std::lock_guard<std::mutex> lock(mFieldsGuardian);
	switch (which)
	{
	case eChainProof::verified:
		mVerfiedChainCSSyncTimestamp = std::time(0);
		break;
	case eChainProof::verifiedCached:

		break;
	case eChainProof::heaviest:
		mHeaviestChainCSSyncTimestamp = std::time(0);
		break;
	case eChainProof::heaviestCached:

		break;
	default:
		break;
	}
}


bool CBlockchainManager::resync(bool cutHeaviestCP, uint64_t height, bool fromConsole)
{


	setIsSynchronizationPaused(true);// pause synchronization so that we have higher chances of locking all the mutexes promptly


	// Establish RAII to ensure synchronization is resumed when scope exits
	FinalAction unlockChainGuardian([this]() { this->setIsSynchronizationPaused(false); });

	std::shared_ptr<CTools> tools = getTools();
	std::vector<std::uint64_t> pows;// to be used during cache formation (optional optimization the FLow mechanics does not really need that).
	uint64_t validUpUntil = 0;

	if (height > 0)
	{
		height = height - 1;
	}

	//Pre-Flight - BEGIN
	eViewState::eViewState view = fromConsole == false ? eViewState::unspecified : eViewState::GridScriptConsole;
	if (height && cutHeaviestCP)
	{
		tools->writeLine(tools->getColoredString("Cutting the the Heaviest Chain at height" + std::to_string(height) + " is not supported.", eColor::lightPink), view);

		return false;
	}


	tools->flashLine(mTools->getColoredString("Halting Operations..", eColor::alertWarning), true, eViewState::GridScriptConsole);

	// First, lock all the mutexes atomically to prevent deadlocks

	// Group 1: Lock native mutexes atomically
	// IMPORTANT 1: these constructs are locked with a unique lock (not shared lock).
	//			autonomous dead-lock avoidance is in place through a 'scoped_lock'.

// Create the manager with an optional completion callback

	auto flashManager = FlashingProgressManager(
		mTools,
		"Halting Operations..",
		[]() { /* Optional: do something when complete */ }
	);

	// Create a scoped progress object - will start flashing
	// false means we'll control completion manually
	auto progress = flashManager.createScoped(false);

	// Update progress before locking


	sync::SynchronizedLocker lock(
		sync::LockingPolicy::MemoryOrdered,
		mChainGuardian,
		mBlockCacheFlatGuardian,
		blockQueueGuardian,
		mBlockProcessingGuardian,
		mLeaderGuardian,
		mHeaviestPathGuardian,
		mVerifiedPathGuardian,
		mDiffCoefficientsGuardian,
		mReceiptsGuardian,
		mCacheOperationGuardian,
		mHeaviestPathDoubleGuardian,
		mVerifiedPathDoubleGuardian
	);

	// Update progress after locks acquired
	progress.update(50.0);

	// Proceed with your operations while the locks are held

	// consider mBlockIDMapMutex


	// Now, all mutexes are locked and will be automatically released when the lock_guard objects go out of scope


	std::shared_ptr<CNetworkManager> nm = getNetworkManager();
	//Pre-Flight - END

	//Operational Logic - BEGIN

	//first clear the enture queue of scheduled blocks
	mBlockQueue.clear();

	// clear Hot-Storage cache
	clearBlockCache();


	// clear recent TX cache
	clearRecentTXCache();

	//then clear current leading block
	setCachedLeader(nullptr);


	// Heaviest Chain-Proof - BEGIN
	if (cutHeaviestCP)
	{
		if (!height)
		{
			setHeaviestChainProofKeyLeader(nullptr);
			setHeaviestChainProofLeader(nullptr);

			mHeaviestChainProofCumulativePoWs.clear();
			mHeaviestChainProof.clear();
			mHeaviestChainProofTotalDifficulty = 0;
			mHeaviestPath.clear();


			mHeaviestPathDoubleGuardian.lock();
			mHeaviestPathDouble.clear();
			mHeaviestPathDoubleGuardian.unlock();

			setPath(std::vector<std::vector<uint8_t>>(), eChainProof::heaviest);
			setChainProof(std::vector<std::vector<uint8_t>>(), eChainProof::heaviest);
		}
	}
	// Heaviest Chain-Proof - END


	mSettings->setEMALastBlockIndex(0);
	mSettings->setEMATimeBetweenBlocks(0);//As far as time-between blocks is concerned, for difficulty adjustments, we need to store only this EMA value (not the SMA time between blocks).
	setAverageDataBlockInterval(0);
	mSettings->setMinDifficultyCoefficientSummedTimeDiffs(0);
	mSettings->setMinDifficultyCoefficientTimeSlotsCount(0);
	mSettings->setEMADifficultyCoefficient(0);
	mSettings->setEMADifficulty(0);

	mFieldsGuardian.lock();//Member-fields Critical Section - BEGIN
	mLeader = nullptr;
	mSynchronizationPercentage = 0;
	mKeyLeader = nullptr;
	mCachedKeyLeader = nullptr;
	mCachedLeader = nullptr;
	mCurrentKeyHeight = 0;
	mCurrentHeight = 0;
	mFieldsGuardian.unlock();//Member-fields Critical Section - END

	mVerifiedChainProofTotalDifficulty = 0;

	if (height == 0)
	{
		mVerifiedPathDouble.clear();
		updateMinDifficultyCoefficients();//zero out the required difficulty
		setPath(std::vector<std::vector<uint8_t>>(), eChainProof::verified);
		setChainProof(std::vector<std::vector<uint8_t>>(), eChainProof::verified);
	}
	else
	{

		// Validate the provided height is within the bounds of our data structures.
	   // The height check is adjusted to ensure it's within the range of existing proofs and paths.
		bool heightOutOfRange = mVerifiedChainProof.size() <= height ||
			mVerifiedChainProofDouble.size() <= height ||
			mVerifiedPath.size() <= height ||
			mVerifiedPathDouble.size() <= height;

		if (heightOutOfRange)
		{
			tools->writeLine(tools->getColoredString("Invalid height provided: " + std::to_string(height), eColor::lightPink), true, false, view);
			return false;
		}

		// Perform the cutting operation at the specified height - BEGIN
		mVerifiedChainProof.resize(height + 1);
		mVerifiedChainProofDouble.resize(height + 1);
		mVerifiedPath.resize(height + 1);
		mVerifiedPathDouble.resize(height + 1);
		// Perform the cutting operation at the specified height - END
		
		// After cutting, update mCurrentHeight to the specified height.
		mCurrentHeight = height;
		progress.update(70.0);
		tools->writeLine("Verifying chain after a cut was made..", true, false, view);

		eChainProofValidationResult::eChainProofValidationResult result = verifyChainProof(mVerifiedChainProof, mVerifiedChainProofTotalDifficulty, true, true, nullptr, false, pows, nullptr, 0, false, false, 999, false, validUpUntil);
		
		// Negative (0) is POSITIVE (enum). Positive is Wrong.
		bool chainOK = !result;
		
		progress.update(90.0);
		if (!chainOK)
		{
			return false;
		}

		// Check if initialization is needed
		if ((mLeader == nullptr || mKeyLeader == nullptr) && !mVerifiedPath.empty()) {
			std::string errStr;
			eBlockInstantiationResult::eBlockInstantiationResult bir;
			CBlockHeader::eBlockHeaderInstantiationResult hir;


			// OPERATION: Proclain Leaders - BEGIN
			if (mLeader == nullptr) {
				tools->writeLine("[LEADER PROCLEMATION]: Searching for a confirmed leader..", true, false, view);
				// INITIATE SEARCH: Begin iterating through mVerifiedChainProof for a leading perspective

				auto& lastProof = mVerifiedChainProof.back();
				auto lastHeader = CBlockHeader::instantiate(lastProof, hir, errStr, false, mMode);


				mLeader = getBlockAtHeightSSDirect(lastHeader->getHeight(), eChainProof::verified, true);
				setCachedLeader(mLeader);
				setCachedHeight(lastHeader->getHeight());
				setCachedHeight(lastHeader->getKeyHeight(), true);

			}
			// OPERATION: Proclain Leaders - END
			if (!mLeader)
			{
				tools->logEvent("[CRITICAL]: Leading Block from the Verified Path not available locally.", eLogEntryCategory::localSystem, 100, eLogEntryType::failure, eColor::cyborgBlood);
				CGRIDNET::getInstance()->shutdown();
				return false;
			}


			// OPERATION: Validate and find the key leader - BEGIN
			if (mKeyLeader == nullptr) {
				mKeyLeader = mSolidStorage->getBlockByHash(mVerifiedPath.back(), bir);
				if (!mKeyLeader) {
					// FAILURE ACTION: Critical log and system shutdown due to unavailable key block
					tools->logEvent("[CRITICAL]: Leading Key-Block from the Verified Path not available locally.", eLogEntryCategory::localSystem, 100, eLogEntryType::failure, eColor::cyborgBlood);
					CGRIDNET::getInstance()->shutdown();
					return false; // TERMINATE OPERATION: Missing key block
				}

				if (!mKeyLeader->getHeader()->isKeyBlock()) {
					bool keyBlockFound = false;
					int depth = 0;
					for (int i = mVerifiedPath.size() - 1; i >= 0; --i) {
						auto h = CBlockHeader::instantiate(mVerifiedChainProof[i], hir, errStr, false, mMode);
						if (h && h->isKeyBlock()) {
							mKeyLeader = std::make_shared<CBlock>();
							mKeyLeader->setBlockHeader(h);
							keyBlockFound = true;

							// SUCCESS ACTION: Log the depth at which the key block was found
							depth = mVerifiedPath.size() - 1 - i; // CALCULATION: Determine depth from the end of the verified path
							tools->writeLine(tools->getColoredString("[INFO]: Key Block found at depth " + std::to_string(depth) + ".", eColor::lightGreen), true, false, view);

							break; // TERMINATE LOOP: Key block found
						}
					}

					if (!keyBlockFound) {
						// WARNING ACTION: Log failure to find a key block in the verified path
						tools->writeLine(tools->getColoredString("[WARNING]: No Key Block found in the verified path.", eColor::lightPink), true, false, view);
					}
				}
			}
			// OPERATION: Validate and find the key leader - END

		}

		// Update Perspective - BEGIN
		if (mLeader)
		{
			tools->writeLine("Updating Perspective..", true, false, view);

			std::vector<uint8_t> effectivePerspective = getEffectivePerspective(mLeader->getID());

			if (effectivePerspective.empty())
			{
				effectivePerspective = mLeader->getHeader()->getPerspective(eTrieID::state, true);
			}
			if (!setPerspective(effectivePerspective))
			{
				return false;
			}
		}
		// Update Perspective - END

		tools->writeLine("Preparing blockchain cache..", true, false, view);


		if (!prepareCacheMT(true, pows))// && !prepareCache(true, pows))
		{
			CTools::writeLineS(tools->getColoredString("Could not prepare block-cache. Aborting..", eColor::cyborgBlood));
			exit(0);
			return false;
		}


		tools->writeLine("Updating required PoW difficulty..", true, false, view);
		updateMinDifficultyCoefficients(false);
		tools->writeLine("Recalculating min. ERG price..", true, false, view);
		updateMinERGPrice();
		setAchievablePerspectiveAtIndex(mVerifiedChainProof.size() ? (mVerifiedChainProof.size() - 1) : 0);

		tools->writeLine("Saving modified state into the Cold Storage", true, false, view);
		setPath(mVerifiedPath, eChainProof::verified, true);
		setChainProof(mVerifiedChainProof, eChainProof::verified, true);

	}

	if (nm)
	{
		nm->forgetReceivedChainProofs();
	}
	//Operational Logic - END

	//Confirmation
	tools->writeLine("[CONFIRMATION]" + tools->getColoredString(" chain was modified.", eColor::lightGreen), true, false, view);
	return true;
}

/// <summary>
/// Activates checkpoints based on the current Leader (from the Verified Chain-Proof) and the state of the current Heaviest Chain-Proof.
/// </summary>
/// WARNING: the provided chain-proof MUST NOT be the heaviest chain-proof (used by default).
/// <returns></returns>
std::vector<std::shared_ptr<CBCheckpoint>>  CBlockchainManager::activateCheckpoints(eChainProof::eChainProof chainProofType, const std::vector < std::vector<uint8_t>>& chainproof)
{
	//Local Variables - BEGIN part 1
	bool useHeaviestPath = (chainProofType == eChainProof::heaviest);
	bool useVerifiedPath = (chainProofType == eChainProof::verified);
	std::shared_ptr<CTools> tools = getTools();
	std::shared_ptr<CBlock> leadingBlock;
	std::shared_ptr<CBlockHeader> leadingHeader;
	std::vector<std::shared_ptr<CBCheckpoint>> tempCheckpoints;
	//Locks - BEGIN
	std::unique_lock <ExclusiveWorkerMutex> heaviestPathLock;
	std::unique_lock<std::mutex> globalCheckpointsLock;
	//Locks - END

	std::shared_ptr<CCryptoFactory> cf = CCryptoFactory::getInstance();
	const std::vector < std::vector<uint8_t>>* chainProofToUse = nullptr;
	CBlockHeader::eBlockHeaderInstantiationResult hir;
	std::string errorStr;
	std::vector<std::shared_ptr<CBCheckpoint>> activated;
	const std::vector<std::shared_ptr<CBCheckpoint>>* checkPointsToUse = &mCheckpoints;
	bool logEvents = false;
	if (chainProofType == eChainProof::heaviest || chainProofType == eChainProof::verified)
	{
		logEvents = true;
	}
	//Local Variables - END

	//Pre-Flight - BEGIN

	if (useHeaviestPath)
	{

		clearCheckpoints();
		//Lock Relevant Critical Sections - BEGIN
		globalCheckpointsLock = std::unique_lock<std::mutex>(mCheckpointsGuardian);
		heaviestPathLock = std::unique_lock<ExclusiveWorkerMutex>(mHeaviestPathGuardian);
		//Lock Relevant Critical Sections - END

		chainProofToUse = &mHeaviestChainProof;
	}
	else
	{
		cpFlags f;
		mCheckpointsGuardian.lock();
		for (uint64_t i = 0; i < mCheckpoints.size(); i++)
		{
			f = mCheckpoints[i]->getFlags();
			f.active = false;
			tempCheckpoints.push_back(std::make_shared< CBCheckpoint>(f, mCheckpoints[i]->getHeight(), mCheckpoints[i]->getHash(), mCheckpoints[i]->getPerspective()));
		}
		mCheckpointsGuardian.unlock();

		chainProofToUse = &chainproof;
		checkPointsToUse = &tempCheckpoints;
	}
	//Pre-Flight - END


	//Local Variables - BEGIN part 2
	if (useHeaviestPath)
	{
		leadingBlock = getCachedLeader();// cached leader is enough. Let's do not block the Flow mechanics.

		if (leadingBlock)
		{
			leadingHeader = leadingBlock->getHeader();
		}
	}
	else if (chainproof.size())
	{
		//we need to instantiate last header in the chain-proof provided
		leadingHeader = CBlockHeader::instantiate(chainproof[chainproof.size() - 1], hir, errorStr, false);
	}
	else
	{
		return activated;
	}
	//IMPORTANT: leadingHeader MIGHT be EMPTY since no block might be known when analyzing a local system-wide chain-proof.
	// It needs to be known though when analyzing an external chain-proof.

	if (!leadingHeader && !useHeaviestPath)
	{
		return activated;
	}

	uint64_t chainProofSize = (*chainProofToUse).size();
	uint64_t leaderHeight = leadingHeader ? leadingHeader->getHeight() : 0;
	uint64_t checkpointsSize = (*checkPointsToUse).size();
	//Local Variables - END part 2

	if (!chainProofSize)
	{

		return activated;
	}
	std::string checkpointsScopeStr = (useHeaviestPath ? "system-wide" : "path-local");
	if (logEvents)
	{
		tools->logEvent("Attempting to activate " + checkpointsScopeStr + " checkpoints..", "Checkpoints", eLogEntryCategory::localSystem, 1, eLogEntryType::notification);
	}
	//Operational Logic - BEGIN
	for (uint64_t i = 0; i < checkpointsSize; i++)
	{
		auto& checkpointFlags = (*checkPointsToUse)[i]->getFlags();


		if (checkpointFlags.active)
		{
			continue;//already active. Skip it.
		}

		//Obligatory Checkpoints - BEGIN
		//The checkpoint is obligatory. We need to activate it.
		if (checkpointFlags.obligatory && !checkpointFlags.active)
		{
			/*
				[Bottom Line]: Activating checkpoints not only requires presence of the corresponding blocks but also it lets otherwise now incompatible blocks through.

				[IMPORTANT]: We cannot honor all obligatory checkpoints for the Verified Chain-Proof since the verified chain proof might not be fully synced yet.
				In the case of a not yet fully synchronized node - blocks represented by the obligatory checkpoints - these would not be yet be present (in the Verified Chain-Proof) to begin with.

				As such, in the case of the Verified Chain-Proof, we activate checkpoints for heights that have been already reached but ALSO  for heights that have NOT been reached, YET.
				[Rationale]: otherwise, the blocks proceeding the checkpoint - these WOULD NOT be verified properly (due to constant changes to processing of the DSM).

				Thus, for the Verified Chain Proof,- we activate ALL obligatory checkpoints BUT do not require corresponding headers in the chain-proof, YET.
				This is assured by the verifyChainProof() function which checks which chain-proof it is dealing with and it assures the above holds.

				This allows for the now incompatible blocks to be allowed for, while the blocks represented by the obligatory checkpoints - these might have not been event considered yet.
				IF, the current height of the Verified Chain-Proof is at least checkpoint_height+1, then the checkpoint needs to match the present block header at a corresponding height.
				//todo: cut verified chain proof right before one of the obligatory checkpoint fails - do not wipe away the entire thing.
			*/

			//if (!useHeaviestPath || !leadingHeader || leaderHeight < (*checkPointsToUse)[i]->getHeight())
			//{
			(*checkPointsToUse)[i]->setIsActive(true);
			activated.push_back((*checkPointsToUse)[i]);
			if (logEvents)
			{
				tools->logEvent("Obligatory checkpoint for height " + std::to_string((*checkPointsToUse)[i]->getHeight()) + tools->getColoredString(" activated", eColor::lightGreen) + ".", useHeaviestPath ? "System Checkpoints" : "Chain-Proof Validation", eLogEntryCategory::localSystem, 1, eLogEntryType::notification);
			}
			continue;//nothing more to do in regards to this checkpoint.
			//}
		}
		//Obligatory Checkpoints - END

		//Optional Checkpoints - BEGIN
		//The checkpoint would allow for certain histories of events but these checkpoints do not strictly enforce those histories.
		//Other alternative histories of events may play out as well.

		checkpointFlags = (*checkPointsToUse)[i]->getFlags();//might have been updated.

		//if (leadingHeader && leaderHeight >= (*checkPointsToUse)[i]->getHeight() && useHeaviestPath)//Activate any relevant (leading height>=checkpoint_height) checkpoint if analyzing external chain-proof.
			//continue; //we're past this checkpoint already. No need to activate it.<- WRONG. Checkpoints not only enforce histories of events but let these through as well (with otherwise invalid blocks
																							 // It is thus of a paramount important we activate ALL relevant checkpoints.


		if ((*checkPointsToUse)[i]->getHeight() > (chainProofSize - 1))//Angle: won't activate since not present in chain-proof.
			continue;//can't verify validity of a checkpoint since current Heaviest Chain-Proof does not go that far.
		//and we need to validate checksum of the block present at the height specified by checkpoint in order to activate it.

		//Compare integrity of a checkpoint with block-header present.
		if (tools->compareByteVectors(useHeaviestPath ? mHeaviestPath[(*checkPointsToUse)[i]->getHeight()] : cf->getSHA2_256Vec((*chainProofToUse)[i]), (*checkPointsToUse)[i]->getHash()))
		{
			(*checkPointsToUse)[i]->setIsActive(true);
			activated.push_back((*checkPointsToUse)[i]);
		}
		else
		{
			if (logEvents) {
				tools->logEvent("Checkpoint for height " + std::to_string((*checkPointsToUse)[i]->getHeight()) + " not activated due to an incoherent checksum.", "Checkpoints",
					eLogEntryCategory::localSystem, 3, eLogEntryType::warning);
			}
		}
		//Optional Checkpoints - END

	}
	//Operational Logic - END
	if (activated.empty())
	{
		if (logEvents)
		{
			tools->logEvent("No checkpoints were activated.", "Checkpoints", eLogEntryCategory::localSystem, 1, eLogEntryType::notification);
		}
	}


	return activated;
}



uint64_t CBlockchainManager::getActiveCheckpointsCount()
{
	uint64_t active = 0;
	std::lock_guard<std::mutex> lock(mCheckpointsGuardian);

	//Operational Logic - BEGIN
	for (uint64_t i = 0; i < mCheckpoints.size(); i++)
	{
		if (mCheckpoints[i]->getIsActive())
			active++;
	}
	//Operational Logic - END
	return active;
}

bool CBlockchainManager::addCheckpoint(std::shared_ptr<CBCheckpoint> checkpoint)
{
	mCheckpointsGuardian.lock();
	mCheckpoints.push_back(checkpoint);
	mCheckpointsGuardian.unlock();
	return true;
}

std::vector<std::shared_ptr<CBCheckpoint>> CBlockchainManager::getCheckpoints()
{
	std::lock_guard<std::mutex> lock(mCheckpointsGuardian);
	return mCheckpoints;
}

std::shared_ptr<CBCheckpoint> CBlockchainManager::getLatestObligatoryCheckpoint()
{
	std::lock_guard<std::mutex> lock(mCheckpointsGuardian);

	for (auto it = mCheckpoints.rbegin(); it != mCheckpoints.rend(); ++it)
	{
		if ((*it)->getFlags().obligatory)
		{
			return *it;  // Return the shared_ptr pointing to the CBCheckpoint with obligatory flag set to true
		}
	}
	return nullptr;  // Return nullptr if no such CBCheckpoint found
}

uint64_t CBlockchainManager::getVPInColdStorageBehindCount()
{
	std::lock_guard<std::mutex> lock(mFieldsGuardian);
	return mVPInColdStorageBehindCount;
}

void CBlockchainManager::incVPInColdStorageBehindCount()
{
	std::lock_guard<std::mutex> lock(mFieldsGuardian);
	++mVPInColdStorageBehindCount;
}

void CBlockchainManager::clearVPInColdStorageBehindCount()
{
	std::lock_guard<std::mutex> lock(mFieldsGuardian);
	mVPInColdStorageBehindCount = 0;
}


/// <summary>
/// Returns closest active checkpoint.
/// </summary>
/// <param name="blockHeader"></param>
/// <returns></returns>
std::shared_ptr<CBCheckpoint> CBlockchainManager::getCurrentCheckpoint(std::shared_ptr<CBlockHeader> blockHeader)
{
	// Local Variables - BEGIN
	std::shared_ptr<CBCheckpoint> closestCheckpoint = nullptr;
	uint64_t closestDistance = UINT64_MAX; // Initialize with max value.
	uint64_t blockHeight, checkpointHeight, currentDistance;
	std::vector<uint8_t> expectedHash, actualHash;
	// Local Variables - END

	// If the blockHeader is null, return immediately.
	if (!blockHeader)
	{
		return nullptr;
	}

	std::lock_guard<std::mutex> lock(mCheckpointsGuardian);

	blockHeight = blockHeader->getHeight();

	for (auto& checkpoint : mCheckpoints)
	{
		if (!checkpoint->getIsActive())
		{
			continue;
		}
		//notice: we NEED lower or equal since otherwise hard-forks would not go through - last block at fork point would have an inconsistent perspective error.
		if (blockHeader->getHeight() > checkpoint->getHeight())// only blocks lower or uqual than the checkpoint are to be considered as 'checkpointed'
		{																	//WARNING: should this logic change, update isCheckpointed() as well.
			continue;
		}

		checkpointHeight = checkpoint->getHeight();

		// Only consider checkpoints whose height is greater than or equal to the block height.
		if (checkpointHeight >= blockHeight)
		{
			currentDistance = checkpointHeight - blockHeight;

			if (currentDistance < closestDistance)
			{
				if (blockHeight == checkpointHeight)
				{
					expectedHash = checkpoint->getHash();
					actualHash = blockHeader->getHash();
					// If the hashes are not equal, continue to the next checkpoint.
					if (!getTools()->compareByteVectors(expectedHash, actualHash))
					{
						continue;
					}
				}

				closestCheckpoint = checkpoint;
				closestDistance = currentDistance;
			}
		}
	}

	return closestCheckpoint;
}





/// <summary>
/// The function checks whether the provided block is followed by a Checkpoint, according to the Verified Chain-proof.
/// </summary>
/// WARNING: checkpoints passed MUST NOT be the system-wide local checkpoints (these are used by default).
/// Usually, if not the system-wide checkpoints are to be used, we would want to pass checkpoints activated during processing of an ephemeral chain-proof delivered from another node.
/// <param name="blockHeader"></param>
/// <returns></returns>
bool CBlockchainManager::isCheckpointed(std::shared_ptr<CBlockHeader> blockHeader, std::vector<std::shared_ptr<CBCheckpoint>> checkpoints)
{
	if (!blockHeader)
	{
		return false;
	}
	std::vector<uint8_t> expectedHash, actualHash;
	std::shared_ptr<CTools> tools = getTools();
	// Determine which checkpoints to use
	std::vector<std::shared_ptr<CBCheckpoint>>* checkpointsToUse;

	if (checkpoints.empty())
	{
		checkpointsToUse = &mCheckpoints;
	}
	else
	{
		checkpointsToUse = &checkpoints;
	}

	// If using mCheckpoints, lock the mutex for the duration of the function
	std::unique_lock<std::mutex> lock;
	if (checkpointsToUse == &mCheckpoints)
	{
		lock = std::unique_lock<std::mutex>(mCheckpointsGuardian);
	}

	for (uint64_t i = 0; i < checkpointsToUse->size(); i++)
	{
		if ((*checkpointsToUse)[i]->getIsActive())
		{																		 //notice: we NEED lower or equal since otherwise hard-forks would not go through - last block at fork point would have an inconsistent perspective error.
			if (blockHeader->getHeight() <= (*checkpointsToUse)[i]->getHeight())// only blocks lower (change:or uqual) than the checkpoint are to be considered as 'checkpointed'
			{																	//WARNING: should this logic change, update getCurrentCheckpoint() as well.
				return true;
			}

			if (blockHeader->getHeight() == (*checkpointsToUse)[i]->getHeight())
			{
				expectedHash = (*checkpointsToUse)[i]->getHash();
				actualHash = blockHeader->getHash();

				if (expectedHash.size())
				{
					if (tools->compareByteVectors(expectedHash, actualHash))
						return true;
					else
						return false;
				}
			}
		}
	}

	return false;
}


bool CBlockchainManager::getIsProcessingLongChainProof()
{
	std::lock_guard<std::mutex> lock(mFieldsGuardian);
	if (mProcessingLongChainProof)
		return true;
	else
		return false;
}

void CBlockchainManager::setIsProcessingLongChainProof(bool isIt)
{
	std::lock_guard<std::mutex> lock(mFieldsGuardian);
	if (isIt)
	{
		mProcessingLongChainProof++;//a number since multiple threads might be processing
	}
	else if (mProcessingLongChainProof)
	{
		--mProcessingLongChainProof;
	}
}

bool CBlockchainManager::markChainProofAsProcessed(const std::vector<uint8_t>& chainProofBytes)
{
	if (chainProofBytes.empty()) {
		return false;
	}

	std::shared_ptr<CCryptoFactory> cf = getCryptoFactory();
	std::vector<uint8_t> hash;

	if (chainProofBytes.size() <= 10 * 1024) {
		hash = cf->getSHA2_256Vec(chainProofBytes);
	}
	else {
		std::vector<uint8_t> subsetBytes;
		subsetBytes.reserve(10 * 1024);

		// Calculate the interval between the start of each portion
		uint64_t interval = (chainProofBytes.size() - 1024) / 9;

		for (int i = 0; i < 10; ++i) {
			// Use std::next to safely get iterators at desired positions
			auto start = std::next(chainProofBytes.begin(), i * interval);
			auto end = std::next(start, 1024); // it's assumed chainProofBytes has a size > 10 * 1024

			subsetBytes.insert(subsetBytes.end(), start, end);
		}

		hash = cf->getSHA2_256Vec(subsetBytes);
	}

	std::lock_guard<std::mutex> lock(mRecentlyProcessedChainProofsGuardian);
	mRecentlyProcessedChainProofs[hash] = static_cast<uint64_t>(std::time(0));
	return true;
}


bool CBlockchainManager::wasChainProofRecentlyProcessed(const std::vector<uint8_t>& chainProofBytes, bool markAsProcessed)
{
	if (chainProofBytes.empty()) {
		return false;
	}

	std::shared_ptr<CCryptoFactory> cf = getCryptoFactory();
	std::vector<uint8_t> hash;

	if (chainProofBytes.size() <= 10 * 1024) {
		hash = cf->getSHA2_256Vec(chainProofBytes);
	}
	else {
		std::vector<uint8_t> subsetBytes;
		subsetBytes.reserve(10 * 1024);

		// Calculate the interval between the start of each portion
		uint64_t interval = (chainProofBytes.size() - 1024) / 9;

		for (int i = 0; i < 10; ++i) {
			// Use std::next to safely get iterators at desired positions
			auto start = std::next(chainProofBytes.begin(), i * interval);
			auto end = std::next(start, 1024);

			subsetBytes.insert(subsetBytes.end(), start, end);
		}

		hash = cf->getSHA2_256Vec(subsetBytes);
	}

	std::lock_guard<std::mutex> lock(mRecentlyProcessedChainProofsGuardian);

	auto it = mRecentlyProcessedChainProofs.find(hash);

	if (it != mRecentlyProcessedChainProofs.end()) {
		uint64_t currentTime = static_cast<uint64_t>(std::time(0));
		if ((currentTime - it->second) <= 30) {
			return true;
		}
		else {
			mRecentlyProcessedChainProofs.erase(it);
		}
	}

	if (markAsProcessed) {
		mRecentlyProcessedChainProofs[hash] = static_cast<uint64_t>(std::time(0));
	}

	return false;
}




bool CBlockchainManager::cleanUpRecentlyProcessedChainProofs(uint64_t pruneEverySec)
{
	std::lock_guard<std::mutex> lock(mRecentlyProcessedChainProofsGuardian);
	uint64_t now = std::time(0);
	if ((now - mRecentlyProcessedChainProofsClearedTimestamp) > pruneEverySec)
	{
		mRecentlyProcessedChainProofs.clear();
		mRecentlyProcessedChainProofsClearedTimestamp = now;
		return true;
	}

	return false;

}

std::shared_ptr<CBlock> CBlockchainManager::getKeyBlockAtKeyBlockHeight(uint64_t keyHeight, bool useColdStorage)
{
	//currently we implement only searching though Hot-Storage
	//it's fast and no need for Cold-Storage traversal
	//for Proof-of-fraud it would be too late to penalize anyway.

	std::lock_guard<ExclusiveWorkerMutex> lock(mChainGuardian);
	mLeaderGuardian.lock();
	std::shared_ptr<CBlock> current = mLeader;
	mLeaderGuardian.unlock();
	uint64_t travered = 0;
	if (current == nullptr)
		return nullptr;

	if (current->getHeader()->getHeight() < keyHeight)
		return nullptr;

	while (current != nullptr)
	{
		if (current->getHeader()->isKeyBlock() && current->getHeader()->getKeyHeight() == keyHeight)
		{
			return current;
		}
		current = current->getParentPtr();
		travered++;
	}
	return nullptr;

}

void CBlockchainManager::incCommitedHeaviestChainProofBlocksCount(uint64_t incBy)
{
	std::lock_guard<std::mutex> lock1(mCommitedHeaviestChainProofBlocksCountGuardian);
	mCommitedHeaviestChainProofBlocksCount += incBy;
}
uint64_t CBlockchainManager::getCommitedHeaviestChainProofBlocksCount()
{
	std::lock_guard<std::mutex> lock1(mCommitedHeaviestChainProofBlocksCountGuardian);
	return mCommitedHeaviestChainProofBlocksCount;
}
/// <summary>
/// Forces BlockchainManager to enter the maintenance mode.
/// </summary>
void CBlockchainManager::enterMaintenanceMode()
{
	getTools()->writeLine("Warning: BlockchainManager is entering maintenance mode. All its sub-systems will halt NOW..");
	pause();//let's pause all the operations

}

void CBlockchainManager::exitMaintenanceMode()
{
	getTools()->writeLine("Warning: BlockchainManager is exiting the maintenance mode. All of its sub-systems will be switched on-line NOW..");
	resume();//let's resume all the operations
}

/// <summary>
/// The heaviest chain-proof will reset to the verified-chain proof. (asynchronism) Wait-time needed.
/// </summary>
void CBlockchainManager::issueHeaviestChainProofReset()
{
	std::lock_guard<std::mutex> lock(mIssueHeaviestChainProofResetGuardian);
	mIssueHeaviestChainProofReset = true;
}

bool CBlockchainManager::isHeaviestChainProofResetToBeMade()
{
	std::lock_guard<std::mutex> lock(mIssueHeaviestChainProofResetGuardian);
	return mIssueHeaviestChainProofReset;
}


/// <summary>
/// For testing only.
/// 
/// DeRoutes *AT LEAST* keyBlocksNr KEY-BLOCKS *AND* *AT LEAST* dataBlocksNr DATA-BLOCKS.
/// The function is NOT guaranteed to deRoute asked amounts of blocks if not enough blocks of that type are present.
/// It only checks if the total amount of blocks is more than any of the two types.
/// 
/// Sets the number of consecutive, recent-key blocks (together with their data blocks to be cut away from the confirmed history of events
/// and made part of the mHeaviestChainProof instead)
/// 
/// The function is blocking and will wait till everything is performed.
/// 
/// By default the mHeaviestChainProof is reset.
/// 
/// All the detoured blocks, are delayed for amount of time specified by a call to setDeRouteDelay (globally). Blocks are delayed after they were added to mHeaviestChainProof.
/// So the delay affects only processing by commitHeaviestChainProofBlocks().
/// 
/// The BlockchainManager would be trying to commit those blocks with calls to commitHeaviestChainProofBlocks().
/// 
/// After the timeout expires, the blocks would be fetched successfully by commitHeaviestChainProofBlocks() and processed to become the valid history of events.
/// 
/// </summary>
/// <param name="nr"></param>
bool CBlockchainManager::deRouteBlocksToHeaviestChain(uint64_t keyBlocksNr, uint64_t dataBlocksNr, bool resetHeaviestChainproof, bool AffectColdStorage)
{
	if (getStatus() != eManagerStatus::eManagerStatus::paused)
	{
		getTools()->writeLine("I need to be in Maintenance Mode for this.");
		return false;
	}

	// Use MemoryOrdered policy to prevent deadlocks
	sync::SynchronizedLocker lock(sync::LockingPolicy::MemoryOrdered, mChainGuardian, mVerifiedPathGuardian, mHeaviestPathGuardian, mLeaderGuardian);

	//LOCAL VARIABLES - BEGIN
	uint64_t deRoutedKeyBlocksCount = 0;
	uint64_t deRoutedDataBlocksCount = 0;
	CBlockHeader::eBlockHeaderInstantiationResult hir;
	std::string errorStr;
	std::vector<std::vector<uint8_t>> delayedIDs;
	//LOCAL VARIABLES - END

	if (mVerifiedChainProof.size() <= max(deRoutedKeyBlocksCount, deRoutedDataBlocksCount))
	{
		getTools()->writeLine("Insufficient nr. of blocks to perform a de-route (" + std::to_string(mVerifiedChainProof.size()) + ")");
	}

	if (resetHeaviestChainproof)
		resetHeaviestChainProof();

	uint64_t currentIndex = mVerifiedChainProof.size() - 1;

	while (deRoutedKeyBlocksCount < keyBlocksNr && deRoutedDataBlocksCount < dataBlocksNr && currentIndex >= 0)
	{
		std::shared_ptr<CBlockHeader> h = CBlockHeader::instantiate(mVerifiedChainProof[currentIndex], hir, errorStr, false);
		assertGN(h != nullptr);

		if (h->isKeyBlock())
			deRoutedKeyBlocksCount++;
		else
			deRoutedDataBlocksCount++;

		delayedIDs.push_back(mVerifiedPath[currentIndex]);

		mVerifiedChainProof.pop_back();
		mVerifiedPath.pop_back();
	}

	if (AffectColdStorage)
	{
		setChainProof(mVerifiedChainProof, eChainProof::verified);
		setPath(mVerifiedPath, eChainProof::verified);
	}

	//delay processing of blocks (for commitHeaviestChainProofBlocks())
	for (uint64_t i = 0; i < delayedIDs.size(); i++)
	{
		delayProcessingOfBlock(delayedIDs[i], i * getDefaultDeRouteDelay());
	}

	return true;
}



void CBlockchainManager::setDefaultDeRouteDelay(uint64_t forHowLongSec)
{
	std::lock_guard<std::mutex> lock(mBlockProcessingDelaysByBlockIDGuardian);
	mDefaultDerouteDelay = forHowLongSec;
}

uint64_t CBlockchainManager::getDefaultDeRouteDelay()
{
	std::lock_guard<std::mutex> lock(mBlockProcessingDelaysByBlockIDGuardian);
	return mDefaultDerouteDelay;
}

bool CBlockchainManager::delayProcessingOfBlock(std::shared_ptr<CBlock> block, uint64_t delayInSec)
{
	if (block == nullptr || block->getHeader() == nullptr)
		return false;
	return delayProcessingOfBlock(block->getID(), delayInSec);
}

/// <summary>
/// Used for testing.
/// Delays processing of a block. Used for tests related to commits from mHeaviestChainProof.
/// </summary>
/// <param name="blockID"></param>
/// <param name="delayInSec"></param>
/// <returns></returns>
bool CBlockchainManager::delayProcessingOfBlock(std::vector<uint8_t> blockID, uint64_t delayInSec)
{
	if (blockID.size() != 32)
		return false;
	std::lock_guard<std::mutex> lock(mBlockProcessingDelaysByBlockIDGuardian);
	mBlockProcessingDelaysByBlockID[blockID] = getTools()->getTime() + delayInSec;
	return true;
}

//Retrieves timestamp at which processing of block is allowed.
//return 0 if not limit was set.
uint64_t CBlockchainManager::getBlockProcessingDelay(std::vector<uint8_t> blockID, bool remove)
{
	uint64_t val = 0;
	if (mBlockProcessingDelaysByBlockID.find(blockID) != mBlockProcessingDelaysByBlockID.end())
	{
		val = mBlockProcessingDelaysByBlockID[blockID];
		if (remove)
			mBlockProcessingDelaysByBlockID.erase(blockID);
		return val;
	}
	else
		return 0;
}

uint64_t CBlockchainManager::getTotalPoWAvailableAtAcivableIndex()
{
	std::lock_guard<std::mutex> lock(mAchievablePerspectiveAtIndexGuardian);
	return mTotalPoWAvailableAtAchievableIndex;
}

void CBlockchainManager::setTotalPoWAvailableAtAcivableIndex(uint64_t pow)
{
	std::lock_guard<std::mutex> lock(mAchievablePerspectiveAtIndexGuardian);
	mTotalPoWAvailableAtAchievableIndex = pow;
}

/// <summary>
/// Gets the index up of a header within mHeaviestChainProof, up to which the Perspective has been achievable so far.
/// The index will increase with new blocks being made available locally, processed and verified => making their way to the Verified histort of events.
/// </summary>
/// <returns></returns>
uint64_t CBlockchainManager::getAchievablePerspectiveAtIndex()
{
	std::lock_guard<std::mutex> lock(mAchievablePerspectiveAtIndexGuardian);
	return mAchievablePerspectiveAtIndex;
}

void CBlockchainManager::setAchievablePerspectiveAtIndex(uint64_t index)
{
	std::lock_guard<std::mutex> lock(mAchievablePerspectiveAtIndexGuardian);
	mAchievablePerspectiveAtIndex = index;
}

uint64_t CBlockchainManager::getHeaviestChainProofTotalDifficulty()
{
	std::lock_guard<std::mutex> lock(mHeaviestChainProofTotalDifficultyGuardian);

	return mHeaviestChainProofTotalDifficulty;
}

std::shared_ptr<CBlockHeader> CBlockchainManager::getHeaviestChainProofKeyLeader()
{
	std::lock_guard<std::mutex> lock(mFieldsGuardian);

	return mHeaviestChainProofLeaderKeyBlock;

}

std::shared_ptr<CBlockHeader> CBlockchainManager::getHeaviestChainProofLeader()
{
	std::lock_guard<std::mutex> lock(mFieldsGuardian);

	return mHeaviestChainProofLeaderBlock;

}

void CBlockchainManager::setHeaviestChainProofLeader(std::shared_ptr<CBlockHeader> header)
{
	std::lock_guard<std::mutex> lock(mFieldsGuardian);

	mHeaviestChainProofLeaderBlock = header;

}

void CBlockchainManager::setHeaviestChainProofKeyLeader(std::shared_ptr<CBlockHeader> header)
{
	std::lock_guard<std::mutex> lock(mFieldsGuardian);

	mHeaviestChainProofLeaderKeyBlock = header;

}

void CBlockchainManager::setHeaviestChainProofLeadBlockID(const std::vector<uint8_t>& id)
{
	std::lock_guard<std::mutex> lock(mFieldsGuardian);

	mHeaviestChainProofLeadingBlockID = id;

}

std::vector<uint8_t>  CBlockchainManager::getHeaviestChainProofLeadBlockID()
{
	std::lock_guard<std::mutex> lock(mFieldsGuardian);

	return mHeaviestChainProofLeadingBlockID;

}

uint64_t CBlockchainManager::getVerifiedChainProofTotalDifficulty()
{
	std::lock_guard<std::mutex> lock(mVerifiedChainProofTotalDifficultyGuardian);

	return mVerifiedChainProofTotalDifficulty;
}

void CBlockchainManager::setHeaviestChainProofTotalDifficulty(uint64_t diff)
{
	std::lock_guard<std::mutex> lock(mHeaviestChainProofTotalDifficultyGuardian);

	mHeaviestChainProofTotalDifficulty = diff;
}

void CBlockchainManager::setVerifiedChainProofTotalDifficulty(uint64_t diff)
{
	std::lock_guard<std::mutex> lock(mVerifiedChainProofTotalDifficultyGuardian);

	mVerifiedChainProofTotalDifficulty = diff;
}

void CBlockchainManager::setKeyBlockFormationLimit(uint64_t limit)
{
	std::lock_guard<std::mutex> lock(mBlockLimitGuardian);
	mKeyBlockFormationLimit = limit;
}

uint64_t CBlockchainManager::getKeyBlockFormationLimit()
{
	std::lock_guard<std::mutex> lock(mBlockLimitGuardian);
	return mKeyBlockFormationLimit;
}
void CBlockchainManager::setDataBlockFormationLimit(uint64_t limit)
{
	std::lock_guard<std::mutex> lock(mBlockLimitGuardian);
	mDataBlockFormationLimit = limit;
}

uint64_t CBlockchainManager::getDataBlockFormationLimit()
{
	std::lock_guard<std::mutex> lock(mBlockLimitGuardian);
	return mDataBlockFormationLimit;
}


/// <summary>
/// Calculates the total/1stleader/2ndleader reward from the perspective of a given key-block.
/// </summary>
/// <param name="fromPerspectiveOf"></param>
/// <param name="mode"></param>
/// <returns></returns>
/// <summary>
/// Calculates the total/1stleader/2ndleader reward from the perspective of a given key-block.
/// </summary>
/// <param name="fromPerspectiveOf"></param>
/// <param name="mode"></param>
/// <returns></returns>
bool CBlockchainManager::getEpochReward(std::shared_ptr<CBlock> fromPerspectiveOf,
	BigInt& reward,
	BigInt& rewardVerifiedUpTilNow,// <- only for eEpochRewardCalculationMode::ALeader and modified for eEpochRewardCalculationMode::BLeader
	eEpochRewardCalculationMode::eEpochRewardCalculationMode mode)
{
	// pre-flight
	if (fromPerspectiveOf == nullptr || fromPerspectiveOf->getHeader() == nullptr)
		return false;

	// INIT
	reward = 0;// initialzize reward to 0; down below it would be only incremented (possibly twice if total reward requested).

	// Local Variables - BEGIN
	eBlockInstantiationResult::eBlockInstantiationResult bir;
	uint64_t epochLength = 0;
	BigInt rewardPool = 0;
	bool keyBlockFound = false;

	std::shared_ptr<CBlock> current = fromPerspectiveOf;
	// Local Variables - END

	// Operational Logic - BEGIN
	if (!current)
	{
		return false;
	}

		bool isGenesis = current->isGenesis();

	
		switch (mode)
		{
		case eEpochRewardCalculationMode::total:
			assertGN(false);
			break;

		case eEpochRewardCalculationMode::ALeader:
		{
			// [ SECURITY ] - BEGIN

			/*
			
				 Key Blocks  - Receive 40% from current coinbase reward.
				 Data Blocks - Receive 40% from current transaction fees - as soon as data block is processed.
							   The amount of transaction fees is compute proactively. 
			
			*/

			// [ SECURITY ] - END

			if (!current)
			{
				reward = 0;
				return true;
			}

			// Key Block - BEGIN
			if (current->getHeader()->isKeyBlock()) // same for Hard Fork blocks
			{
				rewardPool += getCoinbaseRewardForKeyHeight(current->getHeader()->getKeyHeight());
			}
			// Key Block - END
			else
			{
				// Data Block - BEGIN
				rewardPool += rewardVerifiedUpTilNow;

				// [ SECURITY ]: here we cannot trust Receipts (ERG Used and ERG Price).
				//				  Doing so would require complex receipts<-> transactions cross-validation checks.
				//				  Sample Dillema: "is there an excessive Receipt in a block?")
				// 
				//				  Thus, we choose to trust rewardVerifiedUpTilNow value which is computed locally during
				//				  processing a data block. This happens both during block formation and verification.
				//				  eEpochRewardCalculationMode::ALeader is always viable only in the context of the
				//				  currently processed block.

				/*
				 WARNING: the below is NOT secure. It would be secure during block formation but NOT during block verification
				 since Receipts CANNOT be assumed as trusted.

				std::vector<CReceipt> receipts = current->getReceipts();

				for (uint64_t i = 0; i < receipts.size(); i++)
				{
					rewardPool += receipts[0].getERGPrice() * receipts[0].getERGUsed();
				}
				*/
			} // Data Block - END

			// Revised approach: integer-based calculation using the ratio
			{
				double ratioD = CGlobalSecSettings::getEpochRewardRatio(eEpochRewardCalculationMode::ALeader);
				// e.g. ratioD = 0.4
				int ratioAsInt = (int)std::llround(ratioD * 100.0);
				// ratioAsInt = 40

				BigInt partialReward = (rewardPool * ratioAsInt) / 100;
				reward += partialReward;
			}

			// BREAK - BEGIN
			// if (mode != eEpochRewardCalculationMode::total)
			// {
			break;
			// }
			// BREAK - END
		}

		case eEpochRewardCalculationMode::BLeader:
		{

			// [ SECURITY ] - BEGIN
			// Rationale: no past epoch reward for data blocks.
			//			  Only key blocks receive 60% from prior coinbase reward and transaction fees.
			if (!current->getHeader()->isKeyBlock())
			{
				reward = 0;// just to ensure the reward is 0
				return true;
			}
			// [ SECURITY ] - END

			current = fromPerspectiveOf;

			while (current != nullptr && !keyBlockFound)
			{
				// this method is invoked with block proposal passed as 'fromPerspectiveOf'

				// we traverse towards nearest parent
				current = current->getParent(bir, true, true, true, shared_from_this());

				// Non-Genesis Block - BEGIN
				if (!isGenesis)
				{
					if (current->getHeader()->isKeyBlock())
					{
						keyBlockFound = true;
					}

					epochLength++;
					// Key Block - BEGIN
					if (current->getHeader()->isKeyBlock())
					{
						// we've just encountered a key-block, we append its coinbase reward to reward pool
						// as leader B we are entitled to 60% of that as well.
						rewardPool += getCoinbaseRewardForKeyHeight(current->getHeader()->getKeyHeight());
						//current->getHeader()->getTotalBlockReward(); // this field cannot be trusted - it needs to be validated during block verification.
						//					^-- Notice: this is sufficient under the premise that a key-block MAY contain ONLY: 
						//								- a single Miner's Reward
						//								- Genesis Rewards - only in case of the Genesis Key Block
						// 
						// For data blocks we need to TRUST block->getHeader()->getTotalBlockReward() but that is FINE since we cross validate
						// its value (found in block) by re-processing all the transactions and verifiables, in a data block before appending it to chain.

					}
					// Key Block - END
					else
					{
						// Data Block - BEGIN
						rewardPool += current->getHeader()->getTotalBlockReward(); // current = PARENT; by now

						/* BELOW CODE IS WRONG -  it would open the system up to an attack vector in which system trusts
						   contents of Receipts (ERG Price / ERG Used).
						   While protecting against such an attack vector is possible it would be overly complex.

						   There would be a need to cross-reference and cross validate all verifiables and transactions
						   present within any block.

						   It is way simpler and thus way more secure to rely on a single value present within Block Header (mTotalReward).

						   The mTotalReward value represents total cumulative reward eligible to Operator as part of a block.

						   [ SECURITY ]: the mTotalReward is verified locally by being recalculated when block is verified.
										This is when the locally computed value is compared against the value present within
										the block header. If a discrepancy is found - block is Rejected.
										Based on a premise that all former blocks have been verified before this line is executed,
										we can trust the value in block header.

						   [ OPTIMIZATION ]: the mTotalReward field is needed as otherwise we would need to re-process all
											 data blocks to arrive at a valid Epoch 2 reward.

						   The mPaidToMiner represents value paid to miner after tax.

						   std::vector<CReceipt> receipts = current->getReceipts();

						   for (uint64_t i = 0; i < receipts.size(); i++)
						   {
							   // we append to reward pool all fees from each and every data block
							   // up to the neatest parental key-block.
							   // Leader B is entitles to 60% of all these fees as well.
							   rewardPool += receipts[0].getERGPrice() * receipts[0].getERGUsed();
						   }
						*/
					} // Data Block - END
				}
				// Non-Genesis Block - END
				else
				{
					// Genesis Block - BEGIN
					// since there are no proceeding blocks - we assume prior reward is equal to coinbase reward (90GNC).
					rewardPool = getCoinbaseRewardForKeyHeight(0);
					// Genesis Block - END
				}
			}

			/* BEGIN: Integer-based Reward Calculation
			 *
			 * This approach converts floating-point ratios to integer arithmetic to ensure precision
			 * and avoid floating-point rounding errors in reward calculations:
			 *
			 * 1. Convert ratio to integer by multiplying by 100:
			 *    - 0.6 (60%) becomes 60
			 *    - This preserves 2 decimal places of precision
			 *
			 * 2. Use integer multiplication and division:
			 *    - Multiply reward pool by ratio first (rewardPool * 60)
			 *    - Divide by 100 last to minimize rounding errors
			 *    - Order of operations matters for precision
			 *
			 * 3. Benefits:
			 *    - Avoids floating-point arithmetic imprecision
			 *    - Maintains exact ratios for reward distribution
			 *    - Ensures deterministic results across different platforms
			 *    - Prevents potential rounding attacks in reward calculation
			 */
			{
				double ratioD = CGlobalSecSettings::getEpochRewardRatio(eEpochRewardCalculationMode::BLeader);
				// e.g. ratioD = 0.6
				int ratioAsInt = (int)std::llround(ratioD * 100.0);
				// ratioAsInt = 60

				BigInt partialReward = (rewardPool * ratioAsInt) / 100;
				reward += partialReward;
			}
			/* END: Integer-based Reward Calculation */
			break;
		}

		default:
			assertGN(false);
			break;
		}
		return true;
	
	// Operational Logic - END
}

BigInt CBlockchainManager::analyzeDomainBalances()
{
	std::shared_ptr<CTransactionManager> tm = getLiveTransactionsManager();
	std::vector <std::vector<uint8_t>> domainIDs = tm->getStateDomainManager()->getKnownDomainIDs();
	BigInt balance = 0;
	for (int i = 0; i < domainIDs.size(); i++)
	{
		CStateDomain* domain = tm->getStateDomainManager()->findByID(domainIDs[i]);
		if (domain != nullptr)
			balance = domain->getBalance();

	}
	return balance;
}
#define MAX_THREADS 8;
/*
bool CBlockchainManager::verifyChainProofSegment(const std::vector<std::vector<uint8_t>>& chainProof, std::atomic<uint64_t>& highestChainHeightAtomic,
	std::atomic<uint64_t>& highestKeyBlockHeightAtomic, std::atomic<uint64_t>& cumulativePoWAtomic,
	std::atomic<bool>& verificationFailed, size_t startIndex, size_t endIndex)
{
	CBlockHeader::eBlockHeaderInstantiationResult instRes;
	std::shared_ptr<CBlockHeader> currentHeader;
	std::string error;

	for (size_t i = startIndex; i < endIndex && !verificationFailed.load(); ++i) {
		std::shared_ptr<CBlockHeader> currentHeader = CBlockHeader::instantiateBlockHeader(chainProof[i], instRes, error, false, mMode);

		if (instRes != CBlockHeader::eBlockHeaderInstantiationResult::OK || currentHeader == nullptr) {
			verificationFailed = true;
			return false;
		}

		if (!verifyBlockHeader(currentHeader, highestChainHeightAtomic, highestKeyBlockHeightAtomic,
			cumulativePoWAtomic, verificationFailed, startIndex, i)) {
			verificationFailed = true;
			return false;
		}
	}

	return true;
}

bool CBlockchainManager::verifyBlockHeader(
	const std::shared_ptr<CBlockHeader>& currentHeader, std::atomic<uint64_t>& highestChainHeightAtomic,
	std::atomic<uint64_t>& highestKeyBlockHeightAtomic, std::atomic<uint64_t>& cumulativePoWAtomic,
	std::atomic<bool>& verificationFailed, size_t startIndex, size_t i)
{
	try {
	/**	// load current values
		uint64_t currentHighestChainHeight = highestChainHeightAtomic.load();
		uint64_t currentHighestKeyBlockHeight = highestKeyBlockHeightAtomic.load();
		uint64_t currentCumulativePoW = cumulativePoWAtomic.load();

		bool valid = false;


		//verification start

		if (currentHeader == nullptr)
		{

			return false;
		}

		if (i != 0)
		{
			//verify block-height
			if (currentHeader->getHeight() != (currentHeight + 1))
			{
				return false;
			}
		}
		else
		{
			if (currentHeader->getHeight() == 0)
			{
				const_cast<bool&>(containsGenesisBlock) = true;
			}
		}

		if (currentHeader->isKeyBlock())
		{
			//verify PoW
			if (!mCryptoFactory->verifyNonce(*currentHeader))
			{
				return false;;
			}
			//verify Signature
			if (!mCryptoFactory->verifyBlockSignature(currentHeader))
			{
				return false;
			}

			if (!firstKeyBlock)
			{
				//verify key-height
				if (currentHeader->getKeyHeight() != (currentKeyHeight + 1))
				{
					valid = false;
					break;
				}

				if (!getTools()->compareByteVectors(previousKeyBlockID, currentHeader->getParentKeyBlockID()))
				{
					valid = false;
					break;
				}

			}
			leaderPubKey = currentHeader->getPubKey();
			diff = static_cast<uint64_t>(currentHeader->getDifficulty());
			if (!(optimizing && i == startFromPosition))
				cumulativeDiff += diff;
			//WARNING: do NOT alter the mHeaviestChainProofCumulativePoWs over here.
			// the results are returned, including PoWs, and only if additional conditions are met (checked outside),
			// the cached sequence of PoWs is replaced with the one returned from this function, alongside with the heaviest chain
			// and heaviest path being replaced at the very same moment (so these always match).
			//  ----v
			//	if (isHeaviestChainProof)
			//{//assumes the mutex had been locked already!
			//	mHeaviestChainProofCumulativePoWs.push_back(cumulativeDiff);
			//}
			const_cast<std::vector<uint64_t>&>(PoWs).push_back(cumulativeDiff);
			firstKeyBlock = false;
			previousKeyBlockID = mCryptoFactory->getSHA2_256Vec(chainProof[i]);
			currentKeyHeight = currentHeader->getKeyHeight();
			const_cast<std::shared_ptr<CBlockHeader>&>(keyLeader) = currentHeader;
		}
		else
		{
			//valid chain-proof must begin with at least a single valid key-block's header
			if (leaderPubKey.size() == 0)
			{
				if (isHeaviestChainProof)
					mHeaviestPathGuardian.unlock();
				return false;
			}

			const_cast<std::vector<uint64_t>&>(PoWs).push_back(cumulativeDiff);//we need the length to match the length of the entire chain.

			//WARNING: do NOT alter the mHeaviestChainProofCumulativePoWs over here.
		// the results are returned, including PoWs, and only if additional conditions are met (checked outside),
		// the cached sequence of PoWs is replaced with the one returned from this function, alongside with the heaviest chain
		// and heaviest path being replaced at the very same moment (so these always match).
		//   ----v
			//if (isHeaviestChainProof)
			//{//assumes the mutex had been locked already!
			//	mHeaviestChainProofCumulativePoWs.push_back(cumulativeDiff);
			//}

			//regular block
			//verify Signature using prior KEY-BLOCK's pubKey
			if (!mCryptoFactory->verifyBlockSignature(currentHeader, leaderPubKey))
			{
				valid = false;
				break;
			}
		}

		//check if the current header contains a valid parent
		if (i > 0)
		{
			if (currentHeader->getParentID().size() != 32)
			{
				valid = false;
				break;
			}

			if (!getTools()->compareByteVectors(currentHeader->getParentID(), previousHeaderHash))
			{
				valid = false;
				break;
			}
		}


		previousHeaderHash = mCryptoFactory->getSHA2_256Vec(chainProof[i]);

		currentHeight = currentHeader->getHeight();


		// Calculate new values
		uint64_t newHighestChainHeight = std::max(currentHighestChainHeight, currentHeader->getHeight());
		uint64_t newHighestKeyBlockHeight = std::max(currentHighestKeyBlockHeight, currentHeader->getKeyHeight());
		uint64_t newCumulativePoW = std::max(currentCumulativePoW, currentPoW);

	}
	catch(...)
	{
		return false;
	}

}*/

/*
bool CBlockchainManager::verifyChainProofMultithreaded(const std::vector<std::vector<uint8_t>>& chainProof, uint64_t& cumulativeDiff, bool validateAgainsLocalData, bool flashCurrentCount,
	const  std::shared_ptr<CBlockHeader>& keyLeader, const bool& containsGenesisBlock, const std::vector<uint64_t>& PoWs,
	const  std::shared_ptr<CBlockHeader>& blockLeader, uint64_t startFromPosition, bool optimize)
{
	// The number of threads should be the minimum of the number of blocks and MAX_THREADS
	const size_t numBlocks = chainProof.size();
	const size_t numThreads = std::min(MAX_THREADS, numBlocks);

	// Determine the size of each segment to be processed by a thread
	size_t segmentSize = numBlocks / numThreads;
	if (numBlocks % numThreads != 0) ++segmentSize;

	std::vector<std::future<bool>> futures;
	std::atomic<bool> verificationFailed(false);
	std::atomic<uint64_t> highestChainHeightAtomic(0);
	std::atomic<uint64_t> highestKeyBlockHeightAtomic(0);
	std::atomic<uint64_t> cumulativePoWAtomic(0);

	for (size_t i = 0; i < numThreads; ++i) {
		futures.push_back(mThreadPool.push([this, &chainProof, &highestChainHeightAtomic, &highestKeyBlockHeightAtomic, &cumulativePoWAtomic,
			&verificationFailed, startFromPosition, segmentSize, i]() {
				size_t startIndex = startFromPosition + i * segmentSize;
		size_t endIndex = std::min(startIndex + segmentSize, chainProof.size());

		// Verify the chain in the segment
		if (!verifyChainProofSegment(chainProof, highestChainHeightAtomic, highestKeyBlockHeightAtomic, cumulativePoWAtomic, verificationFailed,
			startIndex, endIndex)) {
			verificationFailed = true;
		}
		return !verificationFailed.load();
			}));
	}

	// Wait for all futures to complete
	for (auto& f : futures) {
		if (f.get() == false) {
			return false;
		}
	}

	// All the verifications were successful, now we update the return by reference parameters
	cumulativeDiff = cumulativePoWAtomic.load();

	highestChainHeight = highestChainHeightAtomic.load();
	highestKeyBlockHeight = highestKeyBlockHeightAtomic.load();
	return true;
}*/

/// <summary>
/// Verifies a Chain-Proof.
/// Note: Each chain-proof requires at least one KEY-BLOCK header.
/// PoW validation requires hash of the parent-KEY-BLOCK header which MIGHT NOT be the same as the parentID (if parent is not a KEY-BLOCK).
/// Chain-proofs without KEY-BLOCK header would be too insecure.
/// 
/// The important 'side-effect' of this function is that it computes and inject ephemeral Total Work Done up-to-this-block values into headers.
/// That is CRYTICAL for when the block cache is populated, these values are taken right from the verifiedChainProof (including the value
/// for the current Leader). And that is used when accepting new blocks during a Flow.
/// 
/// </summary>
/// <param name="chainProof"></param>
/// <param name="cumulativeDiff"></param>
/// <param name="validateAgainsLocalData"></param>
/// <param name="flashCurrentCount"></param>
/// <returns></returns>
eChainProofValidationResult::eChainProofValidationResult CBlockchainManager::verifyChainProof(const std::vector<std::vector<uint8_t>>& chainProof, uint64_t& cumulativeDiff, bool validateAgainstLocalData, bool flashCurrentCount,
	const  std::shared_ptr<CBlockHeader>& keyLeader, const bool& containsGenesisBlock, const std::vector<uint64_t>& PoWs,
	const  std::shared_ptr<CBlockHeader>& blockLeader, uint64_t startFromPosition, bool optimize, bool requireCheckpoints, uint64_t barID, bool needToKnowWhereBroken, const uint64_t& validUpUntil)
{
	bool parentIsHardForkBlock = false;
	eChainProofValidationResult::eChainProofValidationResult vr = eChainProofValidationResult::valid;
	if (USE_MT_CHAINPROOF_VALIDATION)
	{
		// Multi-Threaded Attempt - BEGIN
		// [ Rationale ]: multi-threaded invocation employs chunked processing. It won't be able to tell up until when the chain-proof is valid. The moment any cirtical error is found
		//			(even if it is in midst of a chain-proof), multi-threaded execution returns immediatedly.
		// So, IF we need to know up until when chain-proof is valid (during initial bootstrap sequence so that we know at which point a fix it be attempted), THEN
		// we resume chain-proof evaluation through a single-threaded procedure which follows.

		// Get the number of available CPU cores and multiply by 2
		uint64_t cpuCoresTimesTwo = std::thread::hardware_concurrency() * 2;
	
		// Call verifyChainProofMT with the same arguments, plus the cpuCoresTimesTwo


		if ((vr = verifyChainProofMT(chainProof, cumulativeDiff, validateAgainstLocalData, flashCurrentCount, keyLeader, containsGenesisBlock,
			PoWs, blockLeader, startFromPosition, optimize, requireCheckpoints, barID, validUpUntil, cpuCoresTimesTwo)) == valid)
		{
			// If verifyChainProofMT returns true, return immediately
			return vr;
		}
		else
		{
			if (!needToKnowWhereBroken)
			{
				// [ Rationale ]: caller is not interested up until which spot the chain-proof is valid.
				//			In such a case we shall return gracefully. 
				// [ Use Case ]: everywhere but for the initial bootstrap sequence (where we may want to fix something so to save time on full resync).
				return vr;
			}
		}
	}

	// If verifyChainProofMT returns false, reset cumulativeDiff and validUpUntil
	cumulativeDiff = 0;
	const_cast<std::vector<uint64_t>&>(PoWs).clear();
	const_cast<uint64_t&>(validUpUntil) = 0;
	// Multi-Threaded Attempt - END


	std::shared_ptr<CStatusBarHub> barHub = CStatusBarHub::getInstance();
	eBlockchainMode::eBlockchainMode mode = getMode();
	/*
	* [IMPORTANT]: PoWs argument (reference) contains total PoW at each block in the resulting whole chain-proof i.e. it is NOT a partial sequence but a sequence beginning from the
	* very Genesis Block.
	*/
	const_cast<std::vector<uint64_t>&>(PoWs).clear();
	/*
	Note: need to make sure both block-height and KEY-BLOCK-height (KEY-BLOCK only var) are valid and present.
	+ need to verify parent-KEY-BLOCK id IF more than one KEY-BLOCK
	*/
	bool valid = true;
	std::shared_ptr<CTools> tools = getTools();
	if (chainProof.size() > 300)
	{
		flashCurrentCount = true;
		tools->logEvent(tools->getColoredString("about to verify a long chain-proof ", eColor::orange) + "(" + std::to_string(chainProof.size()) + " elements). Status will be reported.",
			eLogEntryCategory::localSystem, 10);
	}
	bool isHeaviestChainProof = false;
	bool heaviestChainLocked = false;
	bool isVerifiedChainProof = false;
	try {
		//Local Variables - BEGIN

		uint64_t nowProposal = 0;
		std::shared_ptr<CSettings>  settings = getSettings();
		CBlockHeader::eBlockHeaderInstantiationResult instRes;
		std::string error;
		uint64_t nowNative = std::time(0);
		uint64_t nowChain = nowNative;
		std::shared_ptr<CCryptoFactory> cf = CCryptoFactory::getInstance();
		std::vector<uint8_t> previousHeaderHash;
		uint64_t previousHeaderTimestamp = 0;
		std::shared_ptr<CBlockHeader> currentHeader = nullptr;
		std::shared_ptr<CBlockHeader> previousHeader = nullptr;
		std::vector<uint8_t> leaderPubKey;
		std::vector<uint8_t> previousKeyBlockID;
		bool firstKeyBlock = true;
		//std::unique_lock<std::recursive_mutex> heaviestPathLock;
		std::shared_ptr<CNetworkManager> nm = getNetworkManager();
		uint64_t diff = 0;
		std::vector<std::shared_ptr<CBCheckpoint>> checkpoints;//LOCAL *ephemeral* checkpoints. These MAY transition into system-wide checkpoints.
		uint64_t currentKeyHeight = 0;
		bool verifiedStartingPoint = false;
		uint64_t currentHeight = startFromPosition ? startFromPosition - 1 : 0;
		int progress = 0;


		//mVerifiedPathGuardian.lock();//no need to synchronize read-access to a pointer which never gets changed.
		if (&chainProof == &mVerifiedChainProof)
		{
			isVerifiedChainProof = true;
		}
		//mVerifiedPathGuardian.unlock();

		if (&chainProof == &mHeaviestChainProof)
		{
			//heaviestPathLock = std::unique_lock<std::recursive_mutex>(mHeaviestPathGuardian);
			heaviestChainLocked = true;
			mHeaviestPathGuardian.lock();
			isHeaviestChainProof = true;
		}

		bool optimizing = (optimize && startFromPosition >= 1);

		//IMPORTANT: we NEED to be able to optimize verification of arbitrary chain-proofs DERIVED from the heaviest chain-proof.
		// in such a case, the optimize parameter is set and it is assumed that there EXISTS a common point, between the provided
		//chain-proof, and the heaviest chain-proof, pointed at index 'startFromPosition'. We employ that very fact to associated pre-computed
		//cumulative proofs of work, so that these DO NOT need to be computer over here (that's the optimization).
		//YET STILL, chainProof does NOT need to point directly at the Heaviest Chain Proof - it may point to chain-proof which has been derived from it,
		//but it NEEDS to share a common point at the mentioned offset.

		////if (optimizing && !isHeaviestChainProof)
		//{
		//	optimizing = false;
		//}

		if (optimizing)
		{

			if (!heaviestChainLocked)//Caution:if NOT locked - lock it.
			{
				heaviestChainLocked = true;
				mHeaviestPathGuardian.lock();// we need it ANYWAY for accessing mHeaviestChainProofCumulativePoWs. ensure it's locked once.
			}

			//checks - BEGIN
			if (mHeaviestChainProofCumulativePoWs.size() && (startFromPosition > (mHeaviestChainProofCumulativePoWs.size() - 1)))
			{
				if (heaviestChainLocked)
				{
					heaviestChainLocked = false;
					mHeaviestPathGuardian.unlock();//wouldn't be able to optimize. Todo: just disable optimizations? start from 0?
				}
				valid = false;
				return eChainProofValidationResult::invalidStartPosition;
			}


			//Prepare PoW Cache - BEGIN
			if (mHeaviestChainProofCumulativePoWs.size() && startFromPosition <= (mHeaviestChainProofCumulativePoWs.size() - 1))//can prepare the PoW cache? We cannot if the starting position goes beyond the last element in mHeaviestChainProofCumulativePoWs LIVE data structure.
			{
				//checks - END
				//assertGN(startFromPosition < mHeaviestChainProofCumulativePoWs.size());//pre-generated PoWs need to be in place
				//todo: cumulativePoWUpToStartingPoint is thus redundant,- can infer solely based on startFromPosition.
				//reconstruct the initial sequence of PoWs, as when using optimizations, we won't have a chance to compute these ourselves over here,
				//we need to rely on precomputed values instead.
				const_cast<std::vector<uint64_t>&>(PoWs) =
					std::vector<uint64_t>(mHeaviestChainProofCumulativePoWs.begin(), mHeaviestChainProofCumulativePoWs.begin() + startFromPosition + 1);//*INCLUSIVE* (startFromPosition+1).IMPORTANT

				cumulativeDiff = PoWs[startFromPosition];// up to the common-point (INCLUDING IT).
				if (startFromPosition)
				{
					previousHeaderHash = mHeaviestPath[startFromPosition - 1];//fingerprint of a block pointed to by the common point's parent.
					previousHeader = CBlockHeader::instantiate(chainProof[startFromPosition - 1], instRes, error, false, mMode);
				}
			}
			else
			{
				tools->logEvent("Unable to use optimizations during chain-proof analysis. Falling back to full analysis.", eLogEntryCategory::localSystem, 10, eLogEntryType::warning, eColor::lightPink);
				optimizing = false;
				startFromPosition = 0;
			}
			//Prepare PoW Cache - END

		}

		//Local Variables - END
		if (chainProof.size() == 0)//1 length chainProof is valid
		{
			if (heaviestChainLocked)
			{
				mHeaviestPathGuardian.unlock();
				heaviestChainLocked = false;
			}
			valid = false;
			return  eChainProofValidationResult::emptyChainProof;
		}

		//Verification = BEGIN

		//Checkpoints - BEGIN

		//activate path-local checkpoints.

		eChainProof::eChainProof tcp = eChainProof::fullTemporary;
		if (isHeaviestChainProof)
		{
			tcp = eChainProof::heaviest;
		}
		else if (isVerifiedChainProof)
		{
			tcp = eChainProof::verified;
		}

		checkpoints = activateCheckpoints(tcp, chainProof);// these will be used down below but also later on during headers' verification.

		// Obligatory Checkpoints Support - BEGIN
		if (requireCheckpoints && settings->getRequireObligatoryCheckpoints())
		{
			//Rationale: the candidate heaviest chain-proof needs to account for all active obligatory checkpoints (blocks).
			uint64_t chainProofSize = chainProof.size();

			if (chainProofSize)
			{
				//std::lock_guard<std::mutex> lock(mCheckpointsGuardian);

				for (uint64_t i = 0; i < checkpoints.size(); i++)
				{
					if (!checkpoints[i]->getFlags().obligatory)
						continue;// we need to ascertain presence only of obligatory chain-proofs.

					if (checkpoints[i]->getHeight() > (chainProofSize - 1) && tcp != eChainProof::verified)//IMPORTANT [Condition 1]: if Verified Chain-Proof, then we DO NOT require presence (yet). 
					{//more rationalization in activateCheckpoints()
						tools->logEvent("Chain-proof does not contain obligatory checkpoints (length too low).", eLogEntryCategory::network, isHeaviestChainProof ? 10 : 0, eLogEntryType::warning, eColor::lightPink);
						//A chain-proof which is shorter than the height of any of the obligatory checkpoints CANNOT be accepted.

						if (!isVerifiedChainProof)
						{
							valid = false;//verified chain-proof is fine not to contain the checkpoints (YET).
							//all other full chain-proofs are REQUIRED.
							vr = eChainProofValidationResult::missingObligatoryCheckpoint;
						}
						break;// in any case abort checkpoint analysis
					}

					if (chainProof.size() >= (checkpoints[i]->getHeight() + 1))
					{//NOTICE: this would not be the case, and this point reached ONLY when dealing with an incomplete  Verified Chain-Proof (see [Condition 1] above)
						if (!tools->compareByteVectors(checkpoints[i]->getHash(), cf->getSHA2_256Vec(chainProof[checkpoints[i]->getHeight()])))
						{
							if (!getIsOperatorLeadingAHardFork())
							{
								tools->logEvent("Chain-proof does not contain obligatory checkpoints (not present).", eLogEntryCategory::network, isHeaviestChainProof ? 10 : 0, eLogEntryType::warning, eColor::lightPink);
								valid = false;
								vr = eChainProofValidationResult::missingObligatoryCheckpoint;
								break;
							}
						}
					}

				}

				if (!valid)
				{
					if (heaviestChainLocked)
					{
						mHeaviestPathGuardian.unlock();
						heaviestChainLocked = false;
					}

					return vr;
				}
			}

		}

		// Obligatory Checkpoints Support - END
		//Checkpoints - END


		//Fix Starting Position - BEGIN

		//we need to begin from finding of the first key-block so that a public key is known.
		//the starting point MIGHT not be pointing to a key-block.
		//let's verify and fix it.


		for (uint64_t i = startFromPosition; verifiedStartingPoint == false && i != static_cast<uint64_t>(-1); i--)
		{
			currentHeader = CBlockHeader::instantiate(chainProof[i], instRes, error, false, mMode);

			if (currentHeader == nullptr)
			{
				if (heaviestChainLocked)
				{
					mHeaviestPathGuardian.unlock();
					heaviestChainLocked = false;
				}
				valid = false;
				vr = eChainProofValidationResult::blockHeaderInstantiationFailed;
				return vr;
			}

			

			if (currentHeader->isKeyBlock() == false)
			{
				startFromPosition--;
			}
			else
			{
				if (currentHeader->getPubKey().size() != 32)
				{
					if (heaviestChainLocked)
					{
						mHeaviestPathGuardian.unlock();
						heaviestChainLocked = false;
					}
					valid = false;
					vr = eChainProofValidationResult::invalidKeyBlockPubKey;
					return vr;
				}
				verifiedStartingPoint = true;
				currentHeight = startFromPosition ? startFromPosition - 1 : 0;
				if (startFromPosition > 0)
				{
					previousHeaderHash = mCryptoFactory->getSHA2_256Vec(chainProof[startFromPosition - 1]);
					previousHeader = CBlockHeader::instantiate(chainProof[startFromPosition - 1], instRes, error, false, mMode);
				}



			}

		}

		if (optimizing)
		{
			cumulativeDiff = PoWs[startFromPosition];
			const_cast<std::vector<uint64_t>&>(PoWs) = std::vector<uint64_t>(mHeaviestChainProofCumulativePoWs.begin(), mHeaviestChainProofCumulativePoWs.begin() + startFromPosition + 1);
		}
		//Fix Starting Position - END

		//check previous header timestamp - BEGIN

		//check previous header timestamp - END
		if (startFromPosition >= 1)
		{
			std::shared_ptr<CBlockHeader> prevoiusBH = CBlockHeader::instantiate(chainProof[startFromPosition - 1], instRes, error, false, mMode);
			if (prevoiusBH)
			{
				previousHeaderTimestamp = prevoiusBH->getSolvedAtTime();
			}
		}
		//Chain-Proof Verification - BEGIN

		for (uint64_t i = startFromPosition; i < chainProof.size(); i++)
		{
			currentHeader = CBlockHeader::instantiate(chainProof[i], instRes, error, false, mMode);
			if (!currentHeader)
			{
				if (heaviestChainLocked)
				{
					mHeaviestPathGuardian.unlock();
					heaviestChainLocked = false;
				}
				valid = false;
				return eChainProofValidationResult::blockHeaderInstantiationFailed;
			}

			// Core Version - Check - BEGIN
			if (currentHeader->getCoreVersion() < CGlobalSecSettings::getRequiredVersionNumber(currentHeader->getHeight()))
			{
				if (heaviestChainLocked)
				{
					mHeaviestPathGuardian.unlock();
					heaviestChainLocked = false;
				}

				valid = false;
				return eChainProofValidationResult::invalidCoreVersion;

			}
			// Core Version - Check - END

			if (isVerifiedChainProof || isHeaviestChainProof)
			{
				if (i != currentHeader->getHeight())
				{
					if (heaviestChainLocked) {
						mHeaviestPathGuardian.unlock();
						heaviestChainLocked = false;
					}
					valid = false;
					vr = eChainProofValidationResult::invalidBlockHeight;
					return vr;//invalid block-height!
				}
			}

			if (currentHeader == nullptr)
			{
				if (heaviestChainLocked) {
					mHeaviestPathGuardian.unlock();
					heaviestChainLocked = false;
				}
				valid = false;

				vr = eChainProofValidationResult::blockHeaderInstantiationFailed;

				return vr;
			}

			// update variables - BEGIN
			nowProposal = currentHeader->getSolvedAtTime();
			nowChain = previousHeaderTimestamp;
			// update variables - END

			if (i != 0)
			{
				//verify block-height
				if (currentHeader->getHeight() != (currentHeight + 1))
				{

					valid = false;
					vr = eChainProofValidationResult::invalidBlockHeight;
					break;
				}
			}
			else
			{
				if (currentHeader->getHeight() == 0)
				{
					const_cast<bool&>(containsGenesisBlock) = true;
				}
			}

			if (previousHeader)
			{
				if (previousHeader->isKeyBlock() && previousHeader->getNonce() == 0)
				{
					parentIsHardForkBlock = true;
				}
			}

			if (currentHeader->isKeyBlock())
			{

				//Time-stamp Verification - BEGIN
				//[IMPORTANT:] the very same verification happens during chain-proof's validation.
				// 	As a general rule, consecutive blocks are expected to be in the future BUT not too far away to thwart excessive time-stamp manipulation attacks.
				//  Also, new blocks may seem to be slightly in the past yet again - due to the aforementioned time-skew.
				//  A limited amount of time-skew is always deemed to be legitimate (both into the future and into the past).
				//  Into-the-future time-skew allowed is much bigger than into-the-past time-skew.
				// 
				//1) [General Rule]: current block must be in the future
				//we need to accept a certain amount of time-drift though

				if (!nowProposal)
				{
					if (!isCheckpointed(currentHeader, checkpoints))//notice: local ephemeral checkpoints being used (not the system-wide checkpoints).
					{
						if (heaviestChainLocked) {
							mHeaviestPathGuardian.unlock();
							heaviestChainLocked = false;
						}
						valid = false;
						vr = eChainProofValidationResult::blockTimeOutOfRange;
						return vr;
					}
				}

				//0A) [Sub-Condition] the current on-chain-time must be known (if not dealing with Genesis Block) - BEGIN
				if (!nowChain && currentHeader->getHeight() != 0)//it's Genesis Block - the concept of time does not exist (yet).
				{
					if (!isCheckpointed(previousHeader, checkpoints))//notice: local ephemeral checkpoints being used (not the system-wide checkpoints).
					{//no checkpoint to override this
						if (heaviestChainLocked) {
							mHeaviestPathGuardian.unlock();
							heaviestChainLocked = false;
						}valid = false;
						vr = eChainProofValidationResult::blockTimeOutOfRange;
						return vr;
					}
					else
					{
						//tools->writeLine("Overriding the on-chain-time-known requirement, due to a Checkpoint being present.");
					}

				}
				//0A) [Sub-Condition] - END

				//1A) [Sub-Condition]: into-the-past time-skew check - BEGIN
				//IMPORTANT: when modifying, - update checks during chain-proof verification as well.
				// In regards to into-the-past fluctuations we do not need to compare against native OS time, we just make sure that the current block is newer than its parent.
				if (nowChain && (nowProposal < nowChain) && ((nowChain - nowProposal) > CGlobalSecSettings::getMaxIntoThePastBlockTimeSkewSec()))//ZERO TOLERANCE
				{//[Rationalization]: key-block proposal must be in the future
					//Still, we must accept for a certain time-skew. The block might seem to be in the past though
					//due to a time skew. If threshold exceeded, we reject.
					//[Notice]: if (currentTimeProposal < now) - the blocks seems to be in the past (relatively to the prior block).
					if (!(getIsOperatorLeadingAHardFork() && (heaviestChainLocked || isVerifiedChainProof)))
					{
						if (!isCheckpointed(currentHeader, checkpoints))//notice: local ephemeral checkpoints being used (not the system-wide checkpoints).
						{//no checkpoint to override this
							if (heaviestChainLocked) {
								mHeaviestPathGuardian.unlock();
								heaviestChainLocked = false;
							}
							valid = false;
							vr = eChainProofValidationResult::blockTimeOutOfRange;
							return vr;
						}
						else
						{
							//tools->writeLine("Overriding the into-the-past maximum time-skew requirement, due to a Checkpoint being present.");
						}
					}
				}
				//1A) [Sub-Condition] - END
				//1B) [Sub-Condition]: into-the-future time-skew check - BEGIN
				//IMPORTANT: when modifying,- update checks during chain-proof verification as well.
				if (
					// PARENT: compare against parent block --v
					(previousHeader &&
						!parentIsHardForkBlock && // excuse blocks which are overly into the future if parent block is a Hard Fork Block
						nowProposal > previousHeader->getSolvedAtTime() &&
						(nowProposal - previousHeader->getSolvedAtTime()) > CGlobalSecSettings::getMaxIntoTheFutureBlockParentTimeSkewSec())
					||
					// NATIVE OS TIME: compare against native OS timestamp --v 
					(nowNative &&
						nowProposal > nowNative &&
						(nowProposal - nowNative) > CGlobalSecSettings::getMaxIntoTheFutureBlockNativeTimeSkewSec()) //15 seconds time skew (into the future).
					)
				{   //[Notice]: if (currentTimeProposal > now) - it implies the current proposal is in the future.
				   //it MUST NOT be excessively far away into the future to prevent time-stamp manipulation and thus difficulty manipulation
				   //attacks.

					if (!(getIsOperatorLeadingAHardFork() && (heaviestChainLocked || isVerifiedChainProof)))
					{

						if (!isCheckpointed(currentHeader, checkpoints))
						{//no checkpoint to override this
							if (heaviestChainLocked) {
								mHeaviestPathGuardian.unlock();
								heaviestChainLocked = false;
							}
							valid = false;
							vr = eChainProofValidationResult::blockTimeOutOfRange;
							return vr;
						}
						else
						{
							//tools->writeLine("Overriding the into-the-future maximum time-skew requirement, due to a Checkpoint being present.");
						}
					}

				}
				//1B) [Sub-Condition] - END


			//Time-stamp Verification - END

			// Verify PoW for the current block header
				if (!mCryptoFactory->verifyNonce(*currentHeader))
				{
					// PoW verification failed.
					if (currentHeader->getNonce() == 0)
					{
						// This block has a nonce of zero: a potential hard fork block.
						// For hard fork blocks, we require that the block is checkpointed.
						// If it is not checkpointed, then the block is misplaced.
						if (!isCheckpointed(currentHeader, checkpoints))
						{
							if (heaviestChainLocked)
							{
								mHeaviestPathGuardian.unlock();
								heaviestChainLocked = false;
							}
							valid = false;
							vr = eChainProofValidationResult::misplacedHardForkBlock;
							return vr;
						}
						// Else: The block is checkpointed.
						// Accept the block without logging any message (per instructions).
					}
					else
					{
						// For blocks with a non-zero nonce (Hard Foek Blocks), a PoW failure is fatal unless the block is checkpointed.
						if (!isCheckpointed(currentHeader, checkpoints))
						{
							if (heaviestChainLocked)
							{
								mHeaviestPathGuardian.unlock();
								heaviestChainLocked = false;
							}
							valid = false;
							vr = eChainProofValidationResult::invalidPoW;
							return vr;
						}
						// Else: The block is checkpointed.
						// Accept the block silently.
					}
				}



				// EXCESSIVE POW CHECK  - BEGIN
				if (!firstKeyBlock && currentHeader->isKeyBlock())
				{
					// -----------------------------------------
					// Existing PoW checks for nonce == 0, etc.
					// -----------------------------------------

					// >>> EXCESSIVE POW CHECK <<<
					if (previousHeader && previousHeader->isKeyBlock())
					{
						double parentDiff = static_cast<double>(previousHeader->getDifficulty());
						double childDiff = static_cast<double>(currentHeader->getDifficulty());

						double ratio = (parentDiff > 0.0) ? (childDiff / parentDiff) : 0.0;

						if (ratio > 1.3 && !isCheckpointed(currentHeader, checkpoints))
						{
							if (heaviestChainLocked)
							{
								mHeaviestPathGuardian.unlock();
								heaviestChainLocked = false;
							}
							barHub->invalidateCustomStatusBar(mode, barID);
							return eChainProofValidationResult::excessivePoW;
						}
					}
				}
					// EXCESSIVE POW CHECK  - END
					
				//verify Signature
				if (!mCryptoFactory->verifyBlockSignature(currentHeader))
				{
					valid = false;
					vr = eChainProofValidationResult::invalidSignature;
					break;
				}

				if (!firstKeyBlock)
				{
					//verify key-height
					if (currentHeader->getKeyHeight() != (currentKeyHeight + 1))
					{
						valid = false;
						vr = eChainProofValidationResult::invalidKeyHeight;
						break;
					}

					if (!getTools()->compareByteVectors(previousKeyBlockID, currentHeader->getParentKeyBlockID()))
					{
						valid = false;
						vr = eChainProofValidationResult::invalidParentReference;
						break;
					}
				}

				leaderPubKey = currentHeader->getPubKey();
				diff = static_cast<uint64_t>(currentHeader->getDifficulty());
				if (!(optimizing && i == startFromPosition))
				{
					cumulativeDiff += diff;
					const_cast<std::vector<uint64_t>&>(PoWs).push_back(cumulativeDiff);
				}
				//WARNING: do NOT alter the mHeaviestChainProofCumulativePoWs over here.
				// the results are returned, including PoWs, and only if additional conditions are met (checked outside), 
				// the cached sequence of PoWs is replaced with the one returned from this function, alongside with the heaviest chain
				// and heaviest path being replaced at the very same moment (so these always match).
				//  ----v
				//	if (isHeaviestChainProof)
				//{//assumes the mutex had been locked already!
				//	mHeaviestChainProofCumulativePoWs.push_back(cumulativeDiff);
				//}

				firstKeyBlock = false;
				previousKeyBlockID = mCryptoFactory->getSHA2_256Vec(chainProof[i]);
				currentKeyHeight = currentHeader->getKeyHeight();
				const_cast<std::shared_ptr<CBlockHeader>&>(keyLeader) = currentHeader;

				if (isVerifiedChainProof)
				{
					// Safe to call here as we're checking already committed data
					setBlockIDAtKeyHeight(currentKeyHeight, previousKeyBlockID);
				}
				else if (isHeaviestChainProof)
				{
					// Safe to call here as we're checking already committed data
					setBlockIDAtKeyHeight(currentKeyHeight, previousKeyBlockID, eChainProof::heaviest);
				}
			}
			else
			{
				//valid chain-proof must begin with at least a single valid key-block's header
				if (leaderPubKey.size() == 0)
				{
					if (heaviestChainLocked)
					{
						mHeaviestPathGuardian.unlock();
						heaviestChainLocked = false;
					}
					valid = false;
					vr = eChainProofValidationResult::invalidKeyBlockPubKey;
					return vr;
				}

				const_cast<std::vector<uint64_t>&>(PoWs).push_back(cumulativeDiff);//we need the length to match the length of the entire chain.

				//WARNING: do NOT alter the mHeaviestChainProofCumulativePoWs over here.
				// the results are returned, including PoWs, and only if additional conditions are met (checked outside), 
				// the cached sequence of PoWs is replaced with the one returned from this function, alongside with the heaviest chain
				// and heaviest path being replaced at the very same moment (so these always match).
				//   ----v
				//if (isHeaviestChainProof)
				//{//assumes the mutex had been locked already!
				//	mHeaviestChainProofCumulativePoWs.push_back(cumulativeDiff);
				//}

				//regular block
				//verify Signature using prior KEY-BLOCK's pubKey
				if (!mCryptoFactory->verifyBlockSignature(currentHeader, leaderPubKey))
				{
					valid = false;
					vr = eChainProofValidationResult::invalidSignature;
					break;
				}
			}

			//check if the current header contains a valid parent
			if (i > 0)
			{
				if (currentHeader->getParentID().size() != 32)
				{
					valid = false;
					vr = eChainProofValidationResult::invalidParentReference;
					break;
				}

				if (!getTools()->compareByteVectors(currentHeader->getParentID(), previousHeaderHash))
				{
					valid = false;
					vr = eChainProofValidationResult::invalidParentReference;
					break;
				}
			}


			if (flashCurrentCount)
			{
				progress = (int)(((double)i / (double)chainProof.size()) * 100);
				barHub->setCustomStatusBarText(mode, barID, "Verified " + std::to_string(i) + " Block Headers already ( " + std::to_string(progress) + " % ) - " 
					+ tools->getColoredString("sequentional", eColor::orange));
				//getTools()->flashLine();
			}
			//Previous Header Info - BEGIN
			previousHeaderHash = mCryptoFactory->getSHA2_256Vec(chainProof[i]);
			previousHeaderTimestamp = currentHeader->getSolvedAtTime();
			previousHeader = currentHeader;
			//Previous Header Info - END

			if (isBlacklisted(previousHeaderHash))
			{
				tools->logEvent("Received chain-proof contains a black-listed block.", eLogEntryCategory::network, 10, eLogEntryType::warning, eColor::lightPink);

				if (heaviestChainLocked)
				{
					mHeaviestPathGuardian.unlock();
					heaviestChainLocked = false;
				}
				barHub->invalidateCustomStatusBar(mode, barID);
				valid = false;
				vr = eChainProofValidationResult::blackListedBlockFound;
				return vr;
			}

			currentHeight = currentHeader->getHeight();
			const_cast<uint64_t&>(validUpUntil) = currentHeight;
		}

		if (leaderPubKey.size() != 32)
		{
			if (heaviestChainLocked)
			{
				mHeaviestPathGuardian.unlock();
				heaviestChainLocked = false;
			}
			barHub->invalidateCustomStatusBar(mode, barID);
			valid = false;
			vr = eChainProofValidationResult::noKeyBlockFound;
			return vr;//no KEY-BLOCK encountered
		}
		//Chain-Proof Verification - END

		//VALIDATION AGAINST LOCAL DATA - BEGIN ( DEPRECATED )
		//
		//IMPORTANT: this is mostly DEPRECATED. The reason is - we always use 'optimization' mode if common point found and if not verifying chain-proofs starting from the Genesis Block.
		//the 'validateAgainstLocalData' might be of use when verifying arbitrary external and partial chain-proofs which DO NOT have a common point with the current mHeaviestChainProof
		// OR if optimizations disabled. The function would then attempt to retrieve any proceeding blocks and compute the total proceeding proof-of-work based on blocks present in Cold Storage.
		// Yet again - we now in 99.99% of cases do not need this as when optimizations enabled we set 'cumulativeDiff' to be equal to cumulative PoW present at the height of the common blokck
		// in mHeaviestChainProof( through the use of mHeaviestChainProofCumulativePoWs).
		//validate against local data (additional cumulative PoW might be added based on locally known data)

		if (PoWs.size() == 0 && !optimizing && validateAgainstLocalData && valid && chainProof[0].size() > 0)
		{	//the provided chainProof might not run up to the Genesis block (it might be partial)
			//let's check whether the chain extends a locally known block if so => compute the total difficulty
			currentHeader = CBlockHeader::instantiate(chainProof[0], instRes, error, false, mMode);

			if (currentHeader->getParentID().size() == 32)
			{
				eBlockInstantiationResult::eBlockInstantiationResult ress; CBlockVerificationResult vr;

				std::shared_ptr<CBlock> p = currentHeader->getParent(ress, true, false, false, shared_from_this());
				unsigned long long additionalPoW = p->getTotalWorkDone(vr);//this would compute total work of the proceeding sub-chain as needed, possibly retrieving blocks recursively one by one
				//back to the Genesis Block as needed. Thus, possibly computationally intensive.
				if (additionalPoW > 0)
					cumulativeDiff += additionalPoW;
			}

		}
		//VALIDATION AGAINST LOCAL DATA - END ( DEPRECATED )

		if (chainProof.size() > 0 && valid)
		{//WARNING: do NOT update cached PoWs within THIS function (do so outside according to specific higher-level logic).
				//if (!optimizing)
				//{
				//	mHeaviestChainProofCumulativePoWs = PoWs;
				//}
			//if (isHeaviestChainProof)
			//{
			//	mHeaviestChainProofCumulativePoWs = cumulativePoWs;
			//}
			//mark that the chain-proof for this leading block was already processed
			if (nm) {
				nm->markChainProofForLeadBlockProcessed(chainProof[chainProof.size() - 1]);
			}
			if (heaviestChainLocked)
			{

				//WARNING: do NOT update cached PoWs within THIS function (do so outside according to specific higher-level logic).
				//if (!optimizing)
				//{
				//	mHeaviestChainProofCumulativePoWs = PoWs;
				//}
				mHeaviestPathGuardian.unlock();
				heaviestChainLocked = false;
			}
			barHub->invalidateCustomStatusBar(mode, barID);
		
			return eChainProofValidationResult::valid;
		}
		else if (chainProof.empty())
		{
			return eChainProofValidationResult::emptyChainProof;
		}
		else
		{
			if (heaviestChainLocked)
			{
				mHeaviestPathGuardian.unlock();
				heaviestChainLocked = false;
			}
			barHub->invalidateCustomStatusBar(mode, barID);
			valid = false;

			if (vr != eChainProofValidationResult::valid)
			{
				return vr;
			}
			else
			{
				return eChainProofValidationResult::invalidGeneral;
			}
		}
	}
	catch (...)
	{
		if (heaviestChainLocked)
		{
			mHeaviestPathGuardian.unlock();
			heaviestChainLocked = false;
		}
		barHub->invalidateCustomStatusBar(mode, barID);
		valid = false;
		return eChainProofValidationResult::internalException;
	}

	if (heaviestChainLocked)
	{
		mHeaviestPathGuardian.unlock();
		heaviestChainLocked = false;
	}
	barHub->invalidateCustomStatusBar(mode, barID);
	valid = false;
	return eChainProofValidationResult::invalidGeneral;
}


#include <atomic>
#include <future>
#include <mutex>

#include <atomic>
#include <future>
#include <mutex>

#include <atomic>
#include <future>
#include <mutex>
#include <atomic>
#include <future>
#include <mutex>
#include <atomic>
#include <future>
#include <mutex>

#include <atomic>
#include <future>
#include <mutex>
#include <thread>

#include <atomic>
#include <future>
#include <mutex>
#include <thread>

// Assuming CCryptoFactory and underlying cryptographic libraries are thread-safe or can be made thread-safe

#include <atomic>
#include <future>
#include <mutex>
#include <thread>

// Assuming CCryptoFactory and underlying cryptographic libraries are thread-safe or can be made thread-safe

#include <atomic>
#include <future>
#include <mutex>
#include <thread>

// Assuming CCryptoFactory and underlying cryptographic libraries are thread-safe or can be made thread-safe

#include <atomic>
#include <future>
#include <mutex>
#include <thread>
#include <vector>
#include <algorithm>

// Assuming CCryptoFactory, CBlockHeader, and other dependencies are defined elsewhere

#include <atomic>
#include <future>
#include <mutex>
#include <thread>
#include <vector>
#include <algorithm>

// Assuming CCryptoFactory, CBlockHeader, and other dependencies are defined elsewhere

#include <atomic>
#include <future>
#include <mutex>
#include <thread>
#include <vector>
#include <algorithm>

// Assuming CCryptoFactory, CBlockHeader, and other dependencies are defined elsewhere

#include <atomic>
#include <future>
#include <mutex>
#include <thread>
#include <vector>
#include <algorithm>

// Assuming CCryptoFactory, CBlockHeader, and other dependencies are defined elsewhere

eChainProofValidationResult::eChainProofValidationResult CBlockchainManager::verifyChainProofMT(
	const std::vector<std::vector<uint8_t>>& chainProof,
	uint64_t& cumulativeDiff,
	bool validateAgainsLocalData /* = true */,
	bool flashCurrentCount /* = false */,
	const std::shared_ptr<CBlockHeader>& keyLeader /* = nullptr */,
	const bool& containsGenesisBlock /* = false */,
	const std::vector<uint64_t>& PoWs /* = std::vector<uint64_t>() */,
	const std::shared_ptr<CBlockHeader>& blockLeader /* = nullptr */,
	uint64_t startFromPosition /* = 0 */,
	bool optimize /* = false */,
	bool requireCheckpoints /* = false */,
	uint64_t barID /* = 100 */,
	const uint64_t& validUpUntil /* = 0 */,
	uint32_t numThreads /* = 8 */ // Default to 8 threads
)
{
	std::shared_ptr<CStatusBarHub> barHub = CStatusBarHub::getInstance();
	eBlockchainMode::eBlockchainMode mode = getMode();
	std::mutex threadBlockResultsMutex;
	// Since PoWs, validUpUntil, and containsGenesisBlock are const references, but we need to modify them,
	// we use const_cast to remove constness (as per the original method).
	std::vector<uint64_t>& mutablePoWs = const_cast<std::vector<uint64_t>&>(PoWs);
	mutablePoWs.clear();

	bool& mutableContainsGenesisBlock = const_cast<bool&>(containsGenesisBlock);
	uint64_t& mutableValidUpUntil = const_cast<uint64_t&>(validUpUntil);
	std::shared_ptr<CBlockHeader>& mutableKeyLeader = const_cast<std::shared_ptr<CBlockHeader>&>(keyLeader);

	std::atomic<bool> valid(true);
	std::atomic< eChainProofValidationResult::eChainProofValidationResult> vr;
	std::shared_ptr<CTools> tools = getTools();

	if (chainProof.size() > 300)
	{
		flashCurrentCount = true;
		tools->logEvent(
			tools->getColoredString("About to verify a long chain-proof ", eColor::orange) + " (" + std::to_string(chainProof.size()) + " elements). Status will be reported.",
			eLogEntryCategory::localSystem, 10);
	}

	bool isHeaviestChainProof = false;
	bool heaviestChainLocked = false;
	bool isVerifiedChainProof = false;
	try
	{
		// Local Variables - BEGIN

		uint64_t nowProposal = 0;
		std::shared_ptr<CSettings> settings = getSettings();
		CBlockHeader::eBlockHeaderInstantiationResult instRes;
		std::string error;
		uint64_t nowNative = std::time(0);
		uint64_t nowChain = nowNative;
		std::vector<uint8_t> previousHeaderHash;
		uint64_t previousHeaderTimestamp = 0;
		std::mutex progressMutex;
		std::shared_ptr<CBlockHeader> currentHeader = nullptr;
		std::shared_ptr<CBlockHeader> previousHeader = nullptr;
		std::vector<uint8_t> leaderPubKey;
		std::vector<uint8_t> previousKeyBlockID;
		bool firstKeyBlock = true;
		std::shared_ptr<CNetworkManager> nm = getNetworkManager();
		uint64_t diff = 0;
		std::vector<std::shared_ptr<CBCheckpoint>> checkpoints; // LOCAL *ephemeral* checkpoints.
		uint64_t currentKeyHeight = 0;
		bool verifiedStartingPoint = false;
		uint64_t currentHeight = startFromPosition ? startFromPosition - 1 : 0;
		mutableValidUpUntil = 0; // Initialize validUpUntil

		// Check if the chainProof is the verified or heaviest chain-proof
		if (&chainProof == &mVerifiedChainProof)
		{
			isVerifiedChainProof = true;
		}

		if (&chainProof == &mHeaviestChainProof)
		{
			heaviestChainLocked = true;
			mHeaviestPathGuardian.lock();
			isHeaviestChainProof = true;
		}

		bool optimizing = (optimize && startFromPosition >= 1);

		if (optimizing)
		{
			if (!heaviestChainLocked) // Caution: if NOT locked - lock it.
			{
				heaviestChainLocked = true;
				mHeaviestPathGuardian.lock(); // Ensure it's locked once.
			}

			if (mHeaviestChainProofCumulativePoWs.size() && (startFromPosition > (mHeaviestChainProofCumulativePoWs.size() - 1)))
			{
				if (heaviestChainLocked)
				{
					mHeaviestPathGuardian.unlock();
					heaviestChainLocked = false;
				}
				return eChainProofValidationResult::invalidStartPosition;
			}

			// Prepare PoW Cache - BEGIN
			if (mHeaviestChainProofCumulativePoWs.size() && startFromPosition <= (mHeaviestChainProofCumulativePoWs.size() - 1))
			{
				// Reconstruct the initial sequence of PoWs
				mutablePoWs = std::vector<uint64_t>(mHeaviestChainProofCumulativePoWs.begin(), mHeaviestChainProofCumulativePoWs.begin() + startFromPosition + 1);
				cumulativeDiff = mutablePoWs[startFromPosition]; // Up to the common-point (INCLUDING IT).
				if (startFromPosition)
				{
					previousHeaderHash = mHeaviestPath[startFromPosition - 1]; // Fingerprint of the block pointed to by the common point's parent.
					previousHeader = CBlockHeader::instantiate(chainProof[startFromPosition - 1], instRes, error, false, mMode);
				}
			}
			else
			{
				tools->logEvent("Unable to use optimizations during chain-proof analysis. Falling back to full analysis.", eLogEntryCategory::localSystem, 10, eLogEntryType::warning, eColor::lightPink);
				optimizing = false;
				startFromPosition = 0;
			}
			// Prepare PoW Cache - END
		}
		else
		{
			cumulativeDiff = 0;
		}

		if (chainProof.size() == 0) // Chain-proof must have at least one element
		{
			if (heaviestChainLocked)
			{
				mHeaviestPathGuardian.unlock();
				heaviestChainLocked = false;
			}
			return eChainProofValidationResult::emptyChainProof;
		}

		// Activate path-local checkpoints.
		eChainProof::eChainProof tcp = eChainProof::fullTemporary;
		if (isHeaviestChainProof)
		{
			tcp = eChainProof::heaviest;
		}
		else if (isVerifiedChainProof)
		{
			tcp = eChainProof::verified;
		}


		

		// Fix Starting Position - BEGIN
		// Need to begin from finding the first key-block so that a public key is known.
		// The starting point MIGHT not be pointing to a key-block.
		for (int64_t i = static_cast<int64_t>(startFromPosition); verifiedStartingPoint == false && i >= 0; i--)
		{
			currentHeader = CBlockHeader::instantiate(chainProof[i], instRes, error, false, mMode);



			if (currentHeader == nullptr)
			{
				if (heaviestChainLocked)
				{
					mHeaviestPathGuardian.unlock();
					heaviestChainLocked = false;
				}
				return eChainProofValidationResult::blockHeaderInstantiationFailed;
			}

		

			if (currentHeader->isKeyBlock() == false)
			{
				startFromPosition--;
			}
			else
			{
				if (currentHeader->getPubKey().size() != 32)
				{
					if (heaviestChainLocked)
					{
						mHeaviestPathGuardian.unlock();
						heaviestChainLocked = false;
					}
					return eChainProofValidationResult::invalidKeyBlockPubKey;
				}
				verifiedStartingPoint = true;
				currentHeight = startFromPosition ? startFromPosition - 1 : 0;
				if (startFromPosition > 0)
				{
					previousHeaderHash = CCryptoFactory::getInstance()->getSHA2_256Vec(chainProof[startFromPosition - 1]);
					previousHeader = CBlockHeader::instantiate(chainProof[startFromPosition - 1], instRes, error, false, mMode);
				}
				else
				{
					// For startFromPosition == 0, initialize previousHeaderHash to an empty vector
					previousHeaderHash.clear();
				}

				mutableKeyLeader = currentHeader; // Update keyLeader
			}
		}

		if (!verifiedStartingPoint)
		{
			if (heaviestChainLocked)
			{
				mHeaviestPathGuardian.unlock();
				heaviestChainLocked = false;
			}
			return eChainProofValidationResult::noKeyBlockFound; // No starting key block found
		}

		if (optimizing)
		{
			cumulativeDiff = mutablePoWs[startFromPosition];
			mutablePoWs = std::vector<uint64_t>(mHeaviestChainProofCumulativePoWs.begin(), mHeaviestChainProofCumulativePoWs.begin() + startFromPosition + 1);
		}
		else
		{
			cumulativeDiff = 0; // Reset cumulativeDiff if not optimizing
		}
		// Fix Starting Position - END

		// Initialize previousHeaderHash if startFromPosition >= 1
		if (startFromPosition >= 1)
		{
			std::shared_ptr<CBlockHeader> previousBH = CBlockHeader::instantiate(chainProof[startFromPosition - 1], instRes, error, false, mMode);
			if (previousBH)
			{
				previousHeaderTimestamp = previousBH->getSolvedAtTime();
				previousHeaderHash = CCryptoFactory::getInstance()->getSHA2_256Vec(chainProof[startFromPosition - 1]);
			}
			else
			{
				// Unable to instantiate previous block header
				if (heaviestChainLocked)
				{
					mHeaviestPathGuardian.unlock();
					heaviestChainLocked = false;
				}
				return eChainProofValidationResult::blockHeaderInstantiationFailed;
			}
		}
		else
		{
			// For startFromPosition == 0, initialize previousHeaderHash to an empty vector
			previousHeaderHash.clear();
		}

		// Phase 1: Identify key block indices
		std::vector<uint64_t> keyBlockIndices;

		// Always include the starting position
		keyBlockIndices.push_back(startFromPosition);

		// Identify key block indices with progress reporting
		{
			std::vector<std::future<void>> keyBlockTasks;
			std::mutex keyBlockIndicesMutex;
			uint64_t chainSize = chainProof.size();
			uint64_t segmentSize = (chainSize - startFromPosition) / numThreads;
			if (segmentSize == 0)
				segmentSize = 1; // Ensure at least one element per segment

			std::atomic<uint64_t> totalBlocksToIdentify(0);
			std::atomic<uint64_t> totalBlocksIdentified(0);
			std::atomic<int> lastProgressValue(-1); // For tracking progress percentage changes

			// Calculate total blocks to identify
			totalBlocksToIdentify = chainSize - startFromPosition;

			for (uint32_t t = 0; t < numThreads; ++t)
			{
				uint64_t segmentStart = startFromPosition + t * segmentSize;
				uint64_t segmentEnd = (t == numThreads - 1) ? chainSize : segmentStart + segmentSize;
				if (segmentStart >= chainSize)
					break;

				keyBlockTasks.emplace_back(std::async(std::launch::async, [&, segmentStart, segmentEnd]() {
					try
					{
						CBlockHeader::eBlockHeaderInstantiationResult localInstRes;
						std::string localError;
						for (uint64_t i = segmentStart; i < segmentEnd; ++i)
						{
							std::shared_ptr<CBlockHeader> header = CBlockHeader::instantiate(chainProof[i], localInstRes, localError, false, mMode);
							if (header == nullptr)
							{
								valid.store(false);
								vr.store(eChainProofValidationResult::blockHeaderInstantiationFailed);
								return;
							}
							if (header->isKeyBlock())
							{
								std::lock_guard<std::mutex> lock(keyBlockIndicesMutex);
								keyBlockIndices.push_back(i);
							}

							// Update progress
							if (flashCurrentCount)
							{
								totalBlocksIdentified.fetch_add(1);
								uint64_t identified = totalBlocksIdentified.load();
								uint64_t total = totalBlocksToIdentify.load();
								int progress = static_cast<int>((static_cast<double>(identified) / total) * 25); // Phase 1 allocated 25%
								std::lock_guard<std::mutex> lock(progressMutex);
								if (progress != lastProgressValue)
								{
									lastProgressValue = progress;
									barHub->setCustomStatusBarText(mode, barID, "Phase 1 - Identifying key blocks: " + std::to_string(progress) + "%");
								}
							}
						}
					}
					catch (...)
					{
						valid.store(false);
						vr.store(eChainProofValidationResult::internalException);
						return;
					}
					}));
			}

			// Wait for all tasks to complete
			for (auto& task : keyBlockTasks)
			{
				task.get();
			}

			// Check if any errors occurred during key block identification
			if (!valid.load())
			{
				if (heaviestChainLocked)
				{
					mHeaviestPathGuardian.unlock();
					heaviestChainLocked = false;
				}
				if (vr.load() != eChainProofValidationResult::valid)
				{
					return vr;
				}
				else
				{
					return eChainProofValidationResult::internalException;
				}
			}

			// Sort keyBlockIndices to maintain order
			std::sort(keyBlockIndices.begin(), keyBlockIndices.end());
		}

		// Ensure the starting key block is included
		if (std::find(keyBlockIndices.begin(), keyBlockIndices.end(), startFromPosition) == keyBlockIndices.end())
		{
			keyBlockIndices.insert(keyBlockIndices.begin(), startFromPosition);
		}

		// Prepare Chunks - BEGIN
		std::vector<std::pair<uint64_t, uint64_t>> chunks;
		const uint64_t totalBlocks = chainProof.size() - startFromPosition;
		const uint64_t minChunkSize = 100; // Minimum chunk size to avoid too small chunks

		// Adjust number of threads if there are too few blocks
		uint32_t effectiveThreads = min(numThreads, static_cast<uint32_t>((totalBlocks + minChunkSize - 1) / minChunkSize));

		if (effectiveThreads == 1 || keyBlockIndices.size() <= 2)
		{
			// Single chunk case
			chunks.push_back(std::make_pair(startFromPosition, chainProof.size()));
		}
		else
		{
			// Multi-chunk case
			uint64_t idealChunkSize = (totalBlocks + effectiveThreads - 1) / effectiveThreads; // Ceiling division

			uint64_t currentStart = startFromPosition;
			size_t keyBlockIndex = 0;

			while (currentStart < chainProof.size())
			{
				uint64_t chunkEnd = currentStart + idealChunkSize;

				// Find the next key block after the ideal chunk end
				while (keyBlockIndex < keyBlockIndices.size() && keyBlockIndices[keyBlockIndex] <= chunkEnd)
				{
					keyBlockIndex++;
				}

				// Adjust chunk end to the nearest key block, unless it's the last chunk
				if (keyBlockIndex < keyBlockIndices.size())
				{
					chunkEnd = keyBlockIndices[keyBlockIndex - 1];
				}
				else
				{
					chunkEnd = chainProof.size();
				}

				// Ensure the chunk is not empty
				if (chunkEnd > currentStart)
				{
					chunks.push_back(std::make_pair(currentStart, chunkEnd));
				}

				currentStart = chunkEnd;
			}

			// Balance the last two chunks if the last one is too small
			if (chunks.size() >= 2)
			{
				auto& secondLastChunk = chunks[chunks.size() - 2];
				auto& lastChunk = chunks.back();
				uint64_t secondLastSize = secondLastChunk.second - secondLastChunk.first;
				uint64_t lastSize = lastChunk.second - lastChunk.first;

				if (lastSize < secondLastSize / 2)
				{
					uint64_t newBoundary = secondLastChunk.first + (secondLastSize + lastSize) / 2;

					// Find the nearest key block to the new boundary
					auto it = std::lower_bound(keyBlockIndices.begin(), keyBlockIndices.end(), newBoundary);
					if (it != keyBlockIndices.begin() && (it == keyBlockIndices.end() || *it > newBoundary))
					{
						--it;
					}
					newBoundary = *it;

					secondLastChunk.second = newBoundary;
					lastChunk.first = newBoundary;
				}
			}
		}

#if LOG_CP_CHUNKS == 1
		// Log chunk information
		for (size_t i = 0; i < chunks.size(); ++i)
		{
			tools->logEvent("Chunk " + std::to_string(i) + ": Start=" + std::to_string(chunks[i].first) +
				", End=" + std::to_string(chunks[i].second) +
				", Size=" + std::to_string(chunks[i].second - chunks[i].first),
				eLogEntryCategory::localSystem, 10, eLogEntryType::notification, eColor::lightWhite);
		}
#endif
		// Prepare Chunks - END

		// Define the struct BlockProcessingResult
		struct BlockProcessingResult
		{
			std::shared_ptr<CBlockHeader> header;
			std::string error;
			CBlockHeader::eBlockHeaderInstantiationResult instRes;
			uint64_t index;
			std::vector<uint8_t> headerHash;
			std::vector<uint8_t> parentID;
			uint64_t solvedAtTime;
			uint64_t height;
			bool isKeyBlock;
			std::vector<uint8_t> pubKey;
			uint64_t keyHeight;
			std::vector<uint8_t> parentKeyBlockID;
			uint64_t difficulty;
			bool powVerified = false;
			bool signatureVerified = false;
		};

		// Each thread will have its own blockResults vector
		std::vector<std::vector<BlockProcessingResult>> threadBlockResults(chunks.size());
		std::mutex threadBlockResultsGuardian;
		std::vector<std::future<void>> verificationTasks;
		std::atomic<uint64_t> totalBlocksToProcess(0);
		std::atomic<uint64_t> totalBlocksProcessed(0);
		std::atomic<int> lastProgressValue(-1); // For tracking progress percentage changes

		// Calculate total blocks to process
		for (const auto& chunk : chunks)
		{
			totalBlocksToProcess += (chunk.second - chunk.first);
		}

		// Phase 2: Verification tasks
		for (size_t chunkIndex = 0; chunkIndex < chunks.size(); ++chunkIndex)
		{
			uint64_t chunkStart = chunks[chunkIndex].first;
			uint64_t chunkEnd = chunks[chunkIndex].second;

			verificationTasks.emplace_back(std::async(std::launch::async, [&, chunkIndex, chunkStart, chunkEnd]() {
				try
				{
					// Each thread creates its own instance of CCryptoFactory
					std::shared_ptr<CCryptoFactory> cf = std::make_shared<CCryptoFactory>();

					// Initialize currentLeaderPubKey


					threadBlockResultsGuardian.lock();
					std::vector<BlockProcessingResult>& localBlockResults = threadBlockResults[chunkIndex];

					uint64_t localChunkSize = chunkEnd - chunkStart;
					localBlockResults.resize(localChunkSize);

					BlockProcessingResult& firstResult = localBlockResults[0];
					firstResult.index = chunkStart;
					threadBlockResultsGuardian.unlock();

					firstResult.instRes = CBlockHeader::eBlockHeaderInstantiationResult::failure;
					firstResult.header = CBlockHeader::instantiate(chainProof[chunkStart], firstResult.instRes, firstResult.error, false, mMode);
					if (firstResult.header == nullptr)
					{
						valid.store(false);
						vr.store(eChainProofValidationResult::blockHeaderInstantiationFailed);
						return;
					}

					// Core Version - Check - BEGIN
					if (currentHeader->getCoreVersion() < CGlobalSecSettings::getRequiredVersionNumber(currentHeader->getHeight()))
					{
						valid.store(false);

						vr.store(eChainProofValidationResult::invalidCoreVersion);
						return;
					}
					// Core Version - Check - END

					firstResult.headerHash = cf->getSHA2_256Vec(chainProof[chunkStart]);
					firstResult.parentID = firstResult.header->getParentID();
					firstResult.solvedAtTime = firstResult.header->getSolvedAtTime();
					firstResult.height = firstResult.header->getHeight();
					firstResult.isKeyBlock = firstResult.header->isKeyBlock();
					firstResult.pubKey = firstResult.header->getPubKey();
					firstResult.keyHeight = firstResult.header->getKeyHeight();
					firstResult.parentKeyBlockID = firstResult.header->getParentKeyBlockID();
					firstResult.difficulty = firstResult.header->getDifficulty();

					if (!firstResult.isKeyBlock)
					{
						// Should not happen, since we ensured that chunk starts with a key block
						valid.store(false);
						vr.store(eChainProofValidationResult::noKeyBlockFound);
						return;
					}

					std::vector<uint8_t> currentLeaderPubKey = firstResult.pubKey;

					// Process the starting key block
					firstResult.powVerified = cf->verifyNonce(*firstResult.header);
					firstResult.signatureVerified = cf->verifyBlockSignature(firstResult.header);

					if (!firstResult.signatureVerified)
					{
						valid.store(false);
						vr.store(eChainProofValidationResult::invalidSignature);
						return;
					}

					// Proceed regardless of powVerified status

					// Process remaining blocks in the chunk
					for (uint64_t i = 1; i < localChunkSize; ++i)
					{
						uint64_t globalIndex = chunkStart + i;
						BlockProcessingResult& result = localBlockResults[i];
						result.index = globalIndex;

						result.instRes = CBlockHeader::eBlockHeaderInstantiationResult::failure;
						result.header = CBlockHeader::instantiate(chainProof[globalIndex], result.instRes, result.error, false, mMode);

					

						if (result.header == nullptr)
						{
							valid.store(false);
							vr.store(eChainProofValidationResult::blockHeaderInstantiationFailed);
							return;
						}

						// Core Version - Check - BEGIN
						if (currentHeader->getCoreVersion() < CGlobalSecSettings::getRequiredVersionNumber(currentHeader->getHeight()))
						{
							valid.store(false);

							vr.store(eChainProofValidationResult::invalidCoreVersion);
							return;
						}
						// Core Version - Check - END

						result.headerHash = cf->getSHA2_256Vec(chainProof[globalIndex]);
						result.parentID = result.header->getParentID();
						result.solvedAtTime = result.header->getSolvedAtTime();
						result.height = result.header->getHeight();
						result.isKeyBlock = result.header->isKeyBlock();
						result.pubKey = result.header->getPubKey();
						result.keyHeight = result.header->getKeyHeight();
						result.parentKeyBlockID = result.header->getParentKeyBlockID();
						result.difficulty = result.header->getDifficulty();

						if (result.isKeyBlock)
						{
							// Key block: perform PoW verification and signature verification
							result.powVerified = cf->verifyNonce(*result.header);
							result.signatureVerified = cf->verifyBlockSignature(result.header);

							if (!result.signatureVerified)
							{
								valid.store(false);
								vr.store(eChainProofValidationResult::invalidSignature);
								return;
							}

							// Proceed regardless of powVerified status
							currentLeaderPubKey = result.pubKey;
						}
						else
						{
							// Data block: use the current leader's public key for signature verification
							result.powVerified = true; // PoW is not applicable for data blocks
							result.signatureVerified = cf->verifyBlockSignature(result.header, currentLeaderPubKey);
							if (!result.signatureVerified)
							{
								valid.store(false);
								vr.store(eChainProofValidationResult::invalidSignature);
								return;
							}
						}

						// Update progress
						if (flashCurrentCount)
						{
							totalBlocksProcessed.fetch_add(1);
							uint64_t processed = totalBlocksProcessed.load();
							uint64_t total = totalBlocksToProcess.load();
							int progress = 25 + static_cast<int>((static_cast<double>(processed) / total) * 50); // Phase 2 allocated 50%
							std::lock_guard<std::mutex> lock(progressMutex);
							if (progress != lastProgressValue)
							{
								lastProgressValue = progress;
								barHub->setCustomStatusBarText(mode, barID, "Phase 2 - Verifying blocks: " + std::to_string(progress) + "% - " + 
								tools->getColoredString("multi-threaded", eColor::orange));
							}
						}
					}
				}
				catch (...)
				{
					valid.store(false);
					vr.store(eChainProofValidationResult::internalException);
					return;
				}
				}));
		}

		// Wait for all verification tasks to complete
		for (auto& task : verificationTasks)
		{
			task.get();
		}

		// Check if any errors occurred during verification
		if (!valid.load())
		{
			if (heaviestChainLocked)
			{
				mHeaviestPathGuardian.unlock();
				heaviestChainLocked = false;
			}
			if (vr.load() !=  eChainProofValidationResult::valid)
			{
				return vr.load();
			}
			else
			{
				return eChainProofValidationResult::internalException;
			}
		}

		// Combine blockResults from all threads
		std::vector<BlockProcessingResult> blockResults(chainProof.size());
		{
			std::lock_guard<std::mutex> lock(threadBlockResultsGuardian);
			for (const auto& localBlockResults : threadBlockResults)
			{
				for (const auto& result : localBlockResults)
				{
					blockResults[result.index] = result;
				}
			}
		}

		// Phase 3: Final sequential validation
		if (flashCurrentCount)
		{
			barHub->setCustomStatusBarText(mode, barID, "Phase 3 - Final sequential validation...");
		}

		// Obligatory Checkpoints Support - BEGIN

		checkpoints = activateCheckpoints(tcp, chainProof); // These will be used later during headers' verification.
		if (requireCheckpoints && settings->getRequireObligatoryCheckpoints())
		{
			// Rationalization: the candidate heaviest chain-proof needs to account for all active obligatory checkpoints (blocks).
			uint64_t chainProofSize = chainProof.size();

			if (chainProofSize)
			{
				std::shared_ptr<CCryptoFactory> cf = CCryptoFactory::getInstance();

				for (uint64_t i = 0; i < checkpoints.size(); i++)
				{
					if (!checkpoints[i]->getFlags().obligatory)
						continue; // We need to ascertain presence only of obligatory chain-proofs.

					if (checkpoints[i]->getHeight() > (chainProofSize - 1) && tcp != eChainProof::verified && tcp != eChainProof::fullTemporary)
					{
						tools->logEvent("Chain-proof does not contain obligatory checkpoints (length too low).", eLogEntryCategory::network, isHeaviestChainProof ? 10 : 0, eLogEntryType::warning, eColor::lightPink);
						if (!isVerifiedChainProof)
						{
							valid.store(false); // Verified chain-proof is fine not to contain the checkpoints (YET).
							vr.store(eChainProofValidationResult::missingObligatoryCheckpoint);
						}
						break; // In any case abort checkpoint analysis
					}

					if (chainProofSize >= (checkpoints[i]->getHeight() + 1) && tcp != eChainProof::fullTemporary)
					{
						if (!tools->compareByteVectors(checkpoints[i]->getHash(), blockResults[checkpoints[i]->getHeight()].headerHash))
						{
							if (!getIsOperatorLeadingAHardFork())
							{
								tools->logEvent("Chain-proof does not contain obligatory checkpoints (not present).", eLogEntryCategory::network, isHeaviestChainProof ? 10 : 0, eLogEntryType::warning, eColor::lightPink);
								valid.store(false);
								vr.store(eChainProofValidationResult::missingObligatoryCheckpoint);
								break;
							}
						}
					}
				}

				if (!valid.load())
				{
					if (heaviestChainLocked)
					{
						mHeaviestPathGuardian.unlock();
						heaviestChainLocked = false;
					}
					return vr;
				}
			}
		}
		// Obligatory Checkpoints Support - END

		std::atomic<int> lastFinalProgressValue(-1);

		for (uint64_t i = startFromPosition; i < blockResults.size(); i++)
		{
			BlockProcessingResult& result = blockResults[i];

			if (result.header == nullptr)
			{
				if (heaviestChainLocked)
				{
					mHeaviestPathGuardian.unlock();
					heaviestChainLocked = false;
				}
				return eChainProofValidationResult::blockHeaderInstantiationFailed;
			}

			currentHeader = result.header;
		
			if (currentHeader->getCoreVersion() > getLastSpottedCoreVersion())
			{
				setLastSpottedCoreVersion(currentHeader->getCoreVersion());
			}

			if (isVerifiedChainProof || isHeaviestChainProof)
			{
				if (i != result.height)
				{
					if (heaviestChainLocked)
					{
						mHeaviestPathGuardian.unlock();
						heaviestChainLocked = false;
					}
					return  eChainProofValidationResult::invalidBlockHeight; // Invalid block-height!
				}
			}

			// Core Version - Check - BEGIN
			if (currentHeader->getCoreVersion() < CGlobalSecSettings::getRequiredVersionNumber(currentHeader->getHeight()))
			{
				if (heaviestChainLocked)
				{
					mHeaviestPathGuardian.unlock();
					heaviestChainLocked = false;
				}
				return eChainProofValidationResult::invalidCoreVersion;
		
			}
			// Core Version - Check - END

			// Update variables - BEGIN
			nowProposal = result.solvedAtTime;
			nowChain = previousHeaderTimestamp;
			// Update variables - END

			if (i != 0)
			{
				// Verify block-height
				if (result.height != (currentHeight + 1))
				{
					if (heaviestChainLocked)
					{
						mHeaviestPathGuardian.unlock();
						heaviestChainLocked = false;
					}
					return eChainProofValidationResult::invalidBlockHeight;
				}
			}
			else
			{
				if (result.height == 0)
				{
					mutableContainsGenesisBlock = true; // Update containsGenesisBlock
				}
			}


	

			if (result.isKeyBlock)
			{
				// Handle PoW verification failure
				if (!result.powVerified)
				{
					// If the block is checkpointed, accept it even if the PoW is invalid.
					if (isCheckpointed(currentHeader, checkpoints))
					{
						// silently accept
						// Do not return an error; simply continue processing.
					}
					else
					{
						// Block is not checkpointed; proceed with error handling.
						if (result.header->getNonce() == 0)
						{
							if (heaviestChainLocked)
							{
								mHeaviestPathGuardian.unlock();
								heaviestChainLocked = false;
							}

							// Operator (Wizard) Hard-Fork Mistake detection - BEGIN
							if (currentHeader->isKeyBlock() && currentHeader->getNonce() == 0)
							{
								std::string blockHashStr = tools->base58CheckEncode(result.headerHash);
								tools->writeLine("Operator, " +
									tools->getColoredString("you forgot to inject Hard Fork Block checkpoint ",
										eColor::cyborgBlood) +
									tools->getColoredString(blockHashStr, eColor::lightCyan) +
									" at height " + std::to_string(result.header->getHeight()) + ".");
								// assertGN(false); // Uncomment if you want to force a debug break.
							}
							// Operator (Wizard) Hard-Fork Mistake detection - END

							barHub->invalidateCustomStatusBar(mode, barID);
							return eChainProofValidationResult::misplacedHardForkBlock;
						}
						else
						{
							if (heaviestChainLocked)
							{
								mHeaviestPathGuardian.unlock();
								heaviestChainLocked = false;
							}
							barHub->invalidateCustomStatusBar(mode, barID);
							return eChainProofValidationResult::invalidPoW;
						}
					}
				}

				bool parentIsHardForkBlock = false;

				if (previousHeader)
				{
					if (previousHeader->isKeyBlock() && previousHeader->getNonce() == 0)
					{
						parentIsHardForkBlock = true;
					}
				}


				// Time-stamp Verification - BEGIN
				if (!nowProposal)
				{
					if (!isCheckpointed(currentHeader, checkpoints)) // Notice: local ephemeral checkpoints being used
					{
						if (heaviestChainLocked)
						{
							mHeaviestPathGuardian.unlock();
							heaviestChainLocked = false;
						}
						return eChainProofValidationResult::blockTimeOutOfRange;
					}
				}

				if (!nowChain && result.height != 0)
				{
					if (previousHeader && !isCheckpointed(previousHeader, checkpoints))
					{
						if (heaviestChainLocked)
						{
							mHeaviestPathGuardian.unlock();
							heaviestChainLocked = false;
						}
						return eChainProofValidationResult::blockTimeOutOfRange;
					}
				}

				// Into-the-past time-skew check
				if (nowChain && (nowProposal < nowChain) && ((nowChain - nowProposal) > CGlobalSecSettings::getMaxIntoThePastBlockTimeSkewSec()))
				{
					if (!(getIsOperatorLeadingAHardFork() && (heaviestChainLocked || isVerifiedChainProof)))
					{
						if (!isCheckpointed(currentHeader, checkpoints))
						{
							if (heaviestChainLocked)
							{
								mHeaviestPathGuardian.unlock();
								heaviestChainLocked = false;
							}
							return eChainProofValidationResult::blockTimeOutOfRange;
						}
					}
				}

				// Into-the-future time-skew check - BEGIN
				// [IMPORTANT]: Two conditions are checked:
				// 1. Parent timestamp check - Current block must not be too far ahead of its parent
				// 2. Native time check - Current block must not be too far ahead of system time
				if (
					// PARENT: Check for excessive time gap between block and its parent
					(previousHeader &&
						nowProposal > previousHeader->getSolvedAtTime() &&
						!parentIsHardForkBlock && // Excuse block if immediately following a Hard Fork block
						(nowProposal - previousHeader->getSolvedAtTime()) > CGlobalSecSettings::getMaxIntoTheFutureBlockParentTimeSkewSec())
					||
					// NATIVE: Check for excessive time gap between block and system time
					(nowNative &&
						nowProposal > nowNative &&
						(nowProposal - nowNative) > CGlobalSecSettings::getMaxIntoTheFutureBlockNativeTimeSkewSec())
					)
				{
					// Skip time checks for hard fork operations on main chains
					if (!(getIsOperatorLeadingAHardFork() && (heaviestChainLocked || isVerifiedChainProof)))
					{
						// Allow checkpointed blocks to bypass time constraints
						if (!isCheckpointed(currentHeader, checkpoints))
						{
							if (heaviestChainLocked)
							{
								mHeaviestPathGuardian.unlock();
								heaviestChainLocked = false;
							}
							return eChainProofValidationResult::blockTimeOutOfRange;
						}
					}
				}
				// Into-the-future time-skew check - END
				// Time-stamp Verification - END


				/*
				* PENDING; more work needed here; as of now this is verified only during block processing; due to as of now insufficient knowledge during chain proof validation.
				* we need global optimized difficulty requirements available in similar way as  getMinDIfficultyForBlock() provides.
				// EXCESSIVE POW CHECK  - BEGIN
				if (!firstKeyBlock && result.isKeyBlock)
				{
					// -----------------------------------------
					// Existing PoW checks for nonce == 0, etc.
					// -----------------------------------------

					// >>> EXCESSIVE POW CHECK <<<
					if (previousHeader && previousHeader->isKeyBlock())
					{
						double parentDiff = static_cast<double>(previousHeader->getDifficulty());
						double childDiff = static_cast<double>(result.difficulty);

						double ratio = (parentDiff > 0.0) ? (childDiff / parentDiff) : 0.0;

						// if (ratio > 1.3 && !isCheckpointed(currentHeader, checkpoints)) <- wrong we should compare against required difficulty not parent difficulty.
						{
							if (heaviestChainLocked)
							{
								mHeaviestPathGuardian.unlock();
								heaviestChainLocked = false;
							}
							barHub->invalidateCustomStatusBar(mode, barID);
							return eChainProofValidationResult::excessivePoW;
						}
					}
				}
				// EXCESSIVE POW CHECK  - END
				*/
				if (!firstKeyBlock)
				{
					// Verify key-height
					if (result.keyHeight != (currentKeyHeight + 1))
					{
						return eChainProofValidationResult::invalidKeyHeight;
					}

					if (!getTools()->compareByteVectors(previousKeyBlockID, result.parentKeyBlockID))
					{
						return eChainProofValidationResult::invalidParentReference;
					}
				}

				leaderPubKey = result.pubKey;
				diff = result.difficulty;
				if (!(optimizing && i == startFromPosition))
				{
					cumulativeDiff += diff;
					mutablePoWs.push_back(cumulativeDiff);
				}
				else
				{
					// In optimization mode, cumulativeDiff is already set, ensure PoWs vector matches
					if (mutablePoWs.size() < i + 1)
					{
						mutablePoWs.resize(i + 1, cumulativeDiff);
					}
				}

				firstKeyBlock = false;
				previousKeyBlockID = result.headerHash; // Use precomputed hash
				currentKeyHeight = result.keyHeight;
				mutableKeyLeader = currentHeader;

				if (isVerifiedChainProof)
				{
					setBlockIDAtKeyHeight(currentKeyHeight, result.headerHash);
				}
				else if (isHeaviestChainProof)
				{
					setBlockIDAtKeyHeight(currentKeyHeight, result.headerHash, eChainProof::heaviest);
				}
			}
			else
			{
				// Valid chain-proof must begin with at least a single valid key-block's header
				if (leaderPubKey.size() == 0)
				{
					if (heaviestChainLocked)
					{
						mHeaviestPathGuardian.unlock();
						heaviestChainLocked = false;
					}
					return eChainProofValidationResult::invalidKeyBlockPubKey;
				}

				// Signature verification already done in parallel phase
				// Update PoWs
				mutablePoWs.push_back(cumulativeDiff); // Need the length to match the length of the entire chain.
			}

			// Check if the current header contains a valid parent
			if (i > 0)
			{
				if (result.parentID.size() != 32)
				{
					return eChainProofValidationResult::invalidParentReference;
				}

				if (!getTools()->compareByteVectors(result.parentID, previousHeaderHash))
				{
					return eChainProofValidationResult::invalidParentReference;
				}
			}
			else
			{
				// For i == 0, no parent to compare, so we can skip or handle genesis block parent ID if necessary
			}

			// Update progress (only if percentage value has changed)
			if (flashCurrentCount)
			{
				int total = static_cast<int>(chainProof.size() - startFromPosition);
				int completed = static_cast<int>(i - startFromPosition + 1);
				int progress = 75 + static_cast<int>((static_cast<double>(completed) / total) * 25); // Phase 3 allocated 25%
				if (progress != lastFinalProgressValue)
				{
					lastFinalProgressValue = progress;
					barHub->setCustomStatusBarText(mode, barID, "Phase 3 - Final validation: " + std::to_string(progress) + "%");
				}
			}

			// Previous Header Info - BEGIN
			previousHeaderHash = result.headerHash;
			previousHeaderTimestamp = result.solvedAtTime;
			previousHeader = currentHeader;
			// Previous Header Info - END

			if (isBlacklisted(previousHeaderHash))
			{
				tools->logEvent("Received chain-proof contains a black-listed block.", eLogEntryCategory::network, 10, eLogEntryType::warning, eColor::lightPink);

				if (heaviestChainLocked)
				{
					mHeaviestPathGuardian.unlock();
					heaviestChainLocked = false;
				}
				barHub->invalidateCustomStatusBar(mode, barID);
				return eChainProofValidationResult::blackListedBlockFound;
			}

			currentHeight = result.height;
			mutableValidUpUntil = currentHeight;
		}



		if (leaderPubKey.size() != 32)
		{
			if (heaviestChainLocked)
			{
				mHeaviestPathGuardian.unlock();
				heaviestChainLocked = false;
			}
			barHub->invalidateCustomStatusBar(mode, barID);
			return eChainProofValidationResult::noKeyBlockFound;// No KEY-BLOCK encountered
		}

		if (chainProof.size() > 0 && valid.load())
		{
			if (nm)
			{
				nm->markChainProofForLeadBlockProcessed(chainProof[chainProof.size() - 1]);
			}
			if (heaviestChainLocked)
			{
				mHeaviestPathGuardian.unlock();
				heaviestChainLocked = false;
			}
			barHub->invalidateCustomStatusBar(mode, barID);
			return eChainProofValidationResult::valid;
		}
		else if (chainProof.empty())
		{
			return eChainProofValidationResult::emptyChainProof;
		}
		else
		{
			if (heaviestChainLocked)
			{
				mHeaviestPathGuardian.unlock();
				heaviestChainLocked = false;
			}
			barHub->invalidateCustomStatusBar(mode, barID);
			return eChainProofValidationResult::invalidGeneral;
		}
	}
	catch (...)
	{
		if (heaviestChainLocked)
		{
			mHeaviestPathGuardian.unlock();
			heaviestChainLocked = false;
		}
		barHub->invalidateCustomStatusBar(mode, barID);
		return eChainProofValidationResult::internalException;
	}

	if (heaviestChainLocked)
	{
		mHeaviestPathGuardian.unlock();
		heaviestChainLocked = false;
	}
	barHub->invalidateCustomStatusBar(mode, barID);
	return eChainProofValidationResult::invalidGeneral;
}


/*
/// <summary>
/// WARNING: this function CANNOT be used for partial PoWs. use verifyChainProof() instead.
/// This function can be used for full PACKED chain-proofs SOLELY.
/// Designed to be as fast as possible.
/// </summary>
/// <param name="chainProof"></param>
/// <param name="cumulativeDiff"></param>
/// <param name="PoWs"></param>
/// <returns></returns>
bool CBlockchainManager::getChainProofCumulativePoW(const std::vector<std::vector<uint8_t>>& chainProof, uint64_t& cumulativeDiff,
	const std::vector<uint64_t>& PoWs)
{
	const_cast<std::vector<uint64_t>&>(PoWs).clear();
	bool flashCurrentCount = true;
	std::shared_ptr<CTools> tools = getTools();
	if (chainProof.size() > 300)
	{
		flashCurrentCount = true;
		tools->logEvent(tools->getColoredString("about to compute PoW of a long chain-proof ", eColor::orange) + " (" + std::to_string(chainProof.size()) + " elements). Status will be reported.",
			eLogEntryCategory::localSystem, 10);
	}

	try {
		//Local Variables - BEGIN
		bool valid = true;
		uint64_t startFromPosition = 0;
		CBlockHeader::eBlockHeaderInstantiationResult instRes;
		std::string error;
		std::vector<uint8_t> previousHeaderHash;
		std::shared_ptr<CBlockHeader> currentHeader = nullptr;
		std::vector<uint8_t> leaderPubKey;
		std::vector<uint8_t> previousKeyBlockID;
		bool firstKeyBlock = true;
		uint64_t diff = 0;
		uint64_t currentKeyHeight = 0;
		uint64_t currentHeight = 0;
		int progress = 0;


		if (chainProof.size() == 0)//1 length chainProof is valid
		{

			return false;
		}


			//we need to begin from finding of the first key-block so that a public key is known.
			//the starting point MIGHT not be pointing to a key-block.
			//let's verify and fix it.
		bool verifiedStartingPoint = false;
		for (uint64_t i = startFromPosition; verifiedStartingPoint == false && i > 0; i--)
		{
			currentHeader = CBlockHeader::instantiateBlockHeader(chainProof[i], instRes, error, false, mMode);
			if (currentHeader == nullptr)
				return false;
			if (currentHeader->isKeyBlock() == false)
			{
				startFromPosition--;
			}
			else
			{
				if (currentHeader->getPubKey().size() != 32)
				{
					return false;
				}
				verifiedStartingPoint = true;
				currentHeight = startFromPosition ? startFromPosition - 1 : 0;
				previousHeaderHash = mHeaviestPath[startFromPosition - 1];
				cumulativeDiff = mHeaviestChainProofCumulativePoWs[startFromPosition];
				const_cast<std::vector<uint64_t>&>(PoWs) = std::vector<uint64_t>(mHeaviestChainProofCumulativePoWs.begin(), mHeaviestChainProofCumulativePoWs.begin() + startFromPosition);

			}

		}
		for (uint64_t i = startFromPosition; i < chainProof.size(); i++)
		{

			//verification start
			currentHeader = CBlockHeader::instantiateBlockHeader(chainProof[i], instRes, error, false, mMode);

				if (i != currentHeader->getHeight())
				{
					return false;//invalid block-height!
				}

			if (currentHeader == nullptr)
			{
				return false;
			}

			if (i != 0)
			{
				//verify block-height
				if (currentHeader->getHeight() != (currentHeight + 1))
				{
					valid = false;
					break;
				}
			}

			if (currentHeader->isKeyBlock())
			{

				diff = static_cast<uint64_t>(currentHeader->getDifficulty());
					cumulativeDiff += diff;

			}
			else
			{
				//valid chain-proof must begin with at least a single valid key-block's header
				if (leaderPubKey.size() == 0)
				{
					return false;
				}

				const_cast<std::vector<uint64_t>&>(PoWs).push_back(cumulativeDiff);//we need the length to match the longth of the entire chain.

			}

			if (flashCurrentCount)
			{
				progress = (int)(((double)i / (double)chainProof.size()) * 100);

				getTools()->flashLine("Verified " + std::to_string(i) + " Block Headers already ( " + std::to_string(progress) + " % )");
			}
			previousHeaderHash = mCryptoFactory->getSHA2_256Vec(chainProof[i]);

		}

		//Verification = END

		if (PoWs.size())
			return true;
		else
			return false;
	}
	catch (...)
	{

		return false;
	}
}
*/
/// <summary>
/// Constructs a Path between any two blocks IF available.
/// Attempts to use the chain-proof of choice.
/// If any block ID is not procided, edge blocks would be used.
/// i.e. when blockIDA is not provided - the Geneis Block would be assumed.
/// </summary>
/// <param name="pathR"></param>
/// <param name="blockIDA"></param>
/// <param name="blockIDB"></param>
/// <returns></returns>
bool CBlockchainManager::getPathForBlock(eChainProof::eChainProof whichChainProof, std::vector<std::vector<uint8_t>>& pathR, std::vector<uint8_t> blockIDA, std::vector<uint8_t> blockIDB)
{
	bool useVerifiedChainProof = (whichChainProof == eChainProof::verified ? true : false);
	std::shared_ptr<CTools> tools = getTools();
	if (useVerifiedChainProof)
		mVerifiedPathGuardian.lock();
	else
		mHeaviestPathGuardian.lock();

	std::vector<std::vector<uint8_t>>* chosenPath = useVerifiedChainProof ? &mVerifiedPath : &mHeaviestPath;
	std::vector<std::vector<uint8_t>>* chosenChainProof = useVerifiedChainProof ? &mVerifiedChainProof : &mHeaviestChainProof;

	int64_t blockAPosition = -1;
	int64_t blockBPosition = -1;

	if (blockIDA.size() != 32)
		blockAPosition = 0;

	if (blockIDB.size() != 32)
	{
		if ((*chosenPath).size() > 0)
			blockBPosition = (*chosenPath).size() - 1;
		else
			blockBPosition = 0;
	}

	if (blockAPosition == 0 && blockBPosition == 0)
	{
		pathR = (*chosenPath);
		if (useVerifiedChainProof)
			mVerifiedPathGuardian.unlock();
		else
			mHeaviestPathGuardian.unlock();
		return true;
	}

	std::vector <std::vector<uint8_t>> path;
	if (blockAPosition == -1 || blockBPosition == -1)
	{

		for (int64_t i = (*chosenPath).size() - 1; i > 0; i--)
		{
			if (blockAPosition == -1)
			{
				if (tools->compareByteVectors(blockIDA, (*chosenPath)[i]))
					blockAPosition = i;
			}
			else
				if (blockBPosition == -1)
				{
					if (tools->compareByteVectors(blockIDB, (*chosenPath)[i]))

					{
						blockBPosition = i;
						break;
					}
				}

		}
	}

	if (blockAPosition >= 0 && blockBPosition >= 1 && blockAPosition <= (*chosenChainProof).size() - 1)
	{
		path = std::vector < std::vector<uint8_t>>((*chosenPath).begin() + blockBPosition, (*chosenPath).begin() + blockAPosition);
	}
	else
	{
		if (useVerifiedChainProof)
			mVerifiedPathGuardian.unlock();
		else
			mHeaviestPathGuardian.unlock();
		return false;
	}
	pathR = path;

	if (useVerifiedChainProof)
		mVerifiedPathGuardian.unlock();
	else
		mHeaviestPathGuardian.unlock();
	return true;
}

CBlockVerificationResult CBlockchainManager::validateBlock(std::vector<uint8_t> packedBERBlock)
{
	std::lock_guard<std::recursive_mutex> lock(mBlockProcessingGuardian);

	if (packedBERBlock.size() > CGlobalSecSettings::getMaxDataBlockSize())
		return CBlockVerificationResult(eBlockVerificationResult::eBlockVerificationResult::invalid,
			mCryptoFactory->getSHA2_256Vec(packedBERBlock));

	eBlockInstantiationResult::eBlockInstantiationResult iResult;
	std::string errorInfo;
	std::shared_ptr<CBlock> block = CBlock::instantiateBlock(true, packedBERBlock, iResult, errorInfo, mMode);
	return validateBlock(block);

}
bool CBlockchainManager::isNrOfStateDomainsFresh()
{
	return mIsNumberOfStateDomainsFresh;
}
bool CBlockchainManager::isTestNet()
{
	return mIsTestNet;
}

/**
 * @brief Checks if a given block header is part of the current blockchain fork based on the specified chain proof.
 *
 * This method serves a critical role in validating block inclusion within different perspectives of the blockchain's
 * current state, represented by various chain proofs. Chain proofs are categorized into live and cached types, each
 * serving distinct purposes and presenting unique trade-offs. Live chain proofs (`verified` and `heaviest`) provide
 * the most up-to-date view of the blockchain but may introduce significant overhead and processing delays due to the
 * need for real-time data retrieval and verification. Conversely, cached chain proofs (`verifiedCached` and
 * `heaviestCached`) rely on previously stored data that can expedite block and transaction processing by avoiding
 * the live data retrieval overhead. However, this efficiency comes at the cost of potentially including stale data,
 * which might not reflect the most current state of the blockchain.
 *
 * The `isBlockInChainProof` method navigates these trade-offs by offering a mechanism to verify block inclusion across
 * different chain proofs. By accepting a block header and a chain proof type as input, it enables a flexible
 * approach to block verification. This versatility ensures that the system can balance between the immediacy of live
 * data and the efficiency of cached data, adapting to different operational requirements and constraints.
 *
 * @param header A shared pointer to a `CBlockHeader` object representing the block header to be verified.
 * @param chain An enumeration value of type `eChainProof` indicating the chain proof against which the block
 *              inclusion should be checked.
 * @return `true` if the block header is part of the blockchain fork as per the specified chain proof; otherwise, `false`.
 */

bool CBlockchainManager::isBlockInChainProof(std::shared_ptr<CBlockHeader> header, eChainProof::eChainProof chain)
{
	// Local Variables - BEGIN
	std::shared_ptr<CTools> tools = getTools();
	ExclusiveWorkerMutex* mtx = nullptr;
	uint64_t height = 0;
	// Local Variables - END

	// Pre-Flight - BEGIN
	if (!header)
		return false;
	height = header->getHeight();
	// Pre-Flight - END

	// Operational Logic - BEGIN
	switch (chain)
	{
	case eChainProof::verified:
		mtx = &mVerifiedPathGuardian;
		break;
	case eChainProof::verifiedCached:
		mtx = &mVerifiedPathDoubleGuardian;
		break;
	case eChainProof::heaviest:
		mtx = &mHeaviestPathGuardian;
		break;
	case eChainProof::heaviestCached:
		mtx = &mHeaviestPathDoubleGuardian;
		break;
	case eChainProof::fullTemporary:
		// Optional handling for 'other' if needed
		return false;
	default:
		return false;
	}

	// Lock the appropriate mutex for the duration of the scope.
	std::lock_guard<ExclusiveWorkerMutex> guard(*mtx);

	// Select the appropriate path container based on the chain proof.
	const auto& pathContainer = (chain == eChainProof::verified || chain == eChainProof::verifiedCached) ?
		(chain == eChainProof::verified ? mVerifiedPath : mVerifiedPathDouble) :
		(chain == eChainProof::heaviest ? mHeaviestPath : mHeaviestPathDouble);

	// Perform the verification check using the selected path container.
	if (!pathContainer.empty() && // Ensure the chain is not empty
		(pathContainer.size() > height) && // Ensure the chain is long enough
		tools->compareByteVectors(pathContainer[height], header->getHash())) // Check hash match
	{
		return true; // Block is on the chain
	}

	return false; // Block is not on the chain or default case
	// Operational Logic - END
}

/**
 * @brief Checks if a given block identifier is part of the current blockchain fork based on the specified chain proof.
 *
 * This version of the `isBlockInChainProof` method enhances efficiency by directly accepting a block's identifier and height,
 * circumventing the computational overhead involved in header deserialization and hash computation. The method assesses
 * block inclusion within different chain proofs, catering to both live and cached perspectives of the blockchain's
 * current state. It addresses the trade-offs between the immediacy of live data and the efficiency of cached data,
 * allowing for a balanced approach in blockchain operations.
 *
 * Live chain proofs (`verified` and `heaviest`) ensure up-to-date verification at the cost of higher processing
 * overhead. Cached chain proofs (`verifiedCached` and `heaviestCached`), although faster by utilizing precomputed
 * data, might reflect stale information. This function provides a crucial mechanism for verifying block inclusion
 * with reduced computational demand, fostering efficient blockchain management.
 *
 * @param blockIdentifier A constant reference to a vector of uint8_t representing the block's identifier (hash).
 * @param height The height of the block within the blockchain.
 * @param chain An enumeration value of type `eChainProof` indicating the chain proof against which the block
 *              inclusion should be checked.
 * @return `true` if the block identifier corresponds to a block part of the blockchain fork as per the specified
 *         chain proof; otherwise, `false`.
 */
bool CBlockchainManager::isBlockInChainProof(const std::vector<uint8_t>& blockIdentifier, uint64_t height, eChainProof::eChainProof chain)
{
	if (blockIdentifier.empty())
	{
		return false;
	}

	ExclusiveWorkerMutex* mtx = nullptr;
	switch (chain)
	{
	case eChainProof::verified:
		mtx = &mVerifiedPathGuardian;
		break;
	case eChainProof::verifiedCached:
		mtx = &mVerifiedPathDoubleGuardian;
		break;
	case eChainProof::heaviest:
		mtx = &mHeaviestPathGuardian;
		break;
	case eChainProof::heaviestCached:
		mtx = &mHeaviestPathDoubleGuardian;
		break;
	case eChainProof::fullTemporary:
		// Optional handling for 'other' if needed
		return false;
	default:
		return false;
	}

	std::lock_guard<ExclusiveWorkerMutex> guard(*mtx);

	// Select the appropriate path container based on the chain proof.
	const auto& pathContainer = (chain == eChainProof::verified || chain == eChainProof::verifiedCached) ?
		(chain == eChainProof::verified ? mVerifiedPath : mVerifiedPathDouble) :
		(chain == eChainProof::heaviest ? mHeaviestPath : mHeaviestPathDouble);

	// Perform the verification check using the selected path container.
	if (!pathContainer.empty() && // Ensure the chain is not empty
		(pathContainer.size() > height) && // Ensure the chain is long enough
		std::equal(pathContainer[height].begin(), pathContainer[height].end(), blockIdentifier.begin())) // Check hash match
	{
		return true; // Block identifier matches a block on the chain
	}

	return false; // Block identifier does not match any block on the chain or default case
}



/// <summary>
/// Attempts to find a receipt.
/// On success returns pointer to a block in which the receipt was found and copy of the receipt within param.
/// IMPORTANT: if checkifOnChain is set to TRUE, the retrieved CReceipt may have an ephemeral Forked Out state.
///			   A receipt in such a state CANNOT be saved on the DSM or processed further.
/// </summary>
/// 
/// <param name="ID"></param>
/// <returns></returns>
std::shared_ptr<CReceipt> CBlockchainManager::findReceipt(std::vector<uint8_t> GUID, bool checkIfOnChain, bool blockNeeded, std::shared_ptr<CBlock>& block, std::vector<uint8_t> blockID)
{
	//Decision: get block from solid storage. takes too long to unlock the cache.
	//std::lock_guard<std::recursive_mutex> lock(mChainGuardian);//
	//locking the above mutex is needed since the function wants to use the block-cache.
	//under heavy load of receipt queries we might want to 
	//1)do double-buffering - two caches
	//2) eliminate the use of block-cache and just retrieve wanted block from ColdStorage(relies on RocksDB for performance)

	// Hot-Storage Cache - BEGIN
	std::shared_ptr<CReceipt> receipt = getReceiptFromHotCache(GUID);
	if (receipt && !checkIfOnChain && !blockNeeded)// IMPORTANT: on-chain check is PARAMOUNT for security (forks)
		// OTHERWISE: eTransactionValidationResult::forkedOut state is not supported!
	{
		return receipt;
	}
	// Hot-Storage Cache - END

	// Local Variables - BEGIN
	bool blockOnChain = false;
	// Local Variables - END

	// Operational Logic - BEGIN


	try {

		if (GUID.size() != 33)
			return nullptr;
		eBlockInstantiationResult::eBlockInstantiationResult bir;


		if (blockID.size() == 0)
		{//if no BlockID is known then attempt to find the receipt within the receipts cache
			std::lock_guard<std::recursive_mutex> lock1(mReceiptsGuardian);
			robin_hood::unordered_map<std::vector<uint8_t>, std::vector<uint8_t>>::iterator it;
			it = mReceiptsBlocksIndex.find(GUID);
			if (it != mReceiptsBlocksIndex.end())
				blockID = it->second;

		}

		std::vector<uint8_t> receiptHash;
		//try to find a receipt by its Link; note: a Link might not exist already; it might had been pruned.
		if (mSolidStorage->loadLink(GUID, receiptHash, eLinkType::eLinkType::receiptsGUIDtoReceiptsHash))
		{
			if (blockID.size() != 32)
			{
				mSolidStorage->loadLink(receiptHash, blockID, eLinkType::eLinkType::receiptHashToBlockID);
			}
		}

		if (blockID.size() > 0)
		{	//a specific block ID is known
			std::shared_ptr<CBlock> container;
			//first try to find the block within RAM cache
			eBlockInstantiationResult::eBlockInstantiationResult bir;
			container = getBlockByHash(blockID, bir, true);
			//not present within mem-cache; load it from Solid Storage.
			if (container == nullptr)// notice: retrieval of a block in itself does not confirm that it's part of current chain.
				container = mSolidStorage->getBlockByHash(blockID, bir, receipt ? false : true); // Tries are not needed IF receipt already found on Cold Storage. Presence of block in chain is enough to confirm as we already know in which block the receipt is located.

			if (container != nullptr)// notice; if caller had not requested on-chain presence verificaiton and was the receipt available we would have returned already.
			{						 // if we are here, it means that for whatever the reason - block is needed. If block not available we either return the receipt
									 // BUT with a forked-out status or we return nullptr if receipt not available in hot storage cache.


				CReceipt rec;

				// Receipt not available in Hot Storage - BEGIN
				if (!receipt)
				{
					if (!container->getReceipt(receiptHash, rec))
					{
						// receipt not found in block. Actually we should never arrrive at this branch since the receipt should not be in any cache to begin with.
						return nullptr;
					}
					else
					{
						receipt = std::make_shared <CReceipt>(rec);
					}
				}
				// Receipt not available in Hot Storage - END

				if (receipt) // so, is the receipt known at all?
				{
					// fill-in missing data
					if (container)// blockNeeded &&
					{
						receipt->setBlockInfo(container);// rationale: on-chain 'receipts' do not contain block-height into to avoid data redundancy.
					}

					// Is On-Chain Validation - BEGIN (to support deep forks). We need to know whether a transaction is still on-chain.
					if (checkIfOnChain)
					{
						if (!isBlockInChainProof(blockID, container->getHeader()->getHeight(), eChainProof::verifiedCached))// confirm whether given block is actually part of the current histort of events.
						{
							// the block which contains the transaction is NO LONGER part of the current fork.
							// we thus mark the transaction as 'Forked Out.
							// IMPORTANT: it's an EPHEMERAL state. A receipt with such a state CANNOT be processed any further, for any purpose. 
							//			  Even the identifier of such a Receipt is ephemeral and invalid.
							receipt->setResult(eTransactionValidationResult::forkedOut);
						}
					}
					// Is On-Chain Validation - END

					if (blockNeeded)
					{
						block = container;
					}
				}
				else
				{// the receipt is not known. Not by Hot Storage caches nor by Cold Storage Receipt-Block ID mechanics.
					return nullptr;
				}
			}
			else
			{
				if (receipt)
				{
					// receipt is here (in cache) but the block is no longer available ( we've checked both Hot and Cold storage).
					// we thus override prior tx processing result.
					receipt->setResult(eTransactionValidationResult::forkedOut);
					return receipt;
				}
				else
				{
					return nullptr;
				}
			}

		}
		else return nullptr;

		return receipt;
	}
	catch (...)
	{
		getTools()->writeLine("an error during receipt retrieval has occurred.");
		return nullptr;
	}
	// Operational Logic - END

}

/// <summary>
/// Attempts to find a receipt.
/// On success returns pointer to a CTransaction in which the transaction was found and copy of the receipt within param.
/// </summary>
/// <param name="ID"></param>
/// <returns></returns>
/// 
/// IMPORTANT: if checkifOnChain is set to TRUE, the retrieved CReceipt may have an ephemeral Forked Out state.
///			   A receipt in such a state CANNOT be saved on the DSM or processed further.
std::shared_ptr<CTransaction> CBlockchainManager::findTransaction(std::vector<uint8_t> receiptID, CReceipt& receipt, const uint64_t& confirmedtTimestamp, const uint64_t& timestamp, bool checkIfOnChain, const  std::vector<uint8_t>& blockID)
{

	//Decision: get block from solid storage. takes too long to unlock the cache.
	//std::lock_guard<std::recursive_mutex> lock(mChainGuardian);//
	//locking the above mutex is needed since the function wants to use the block-cache.
	//under heavy load of receipt queries we might want to 
	//1)do double-buffering - two caches
	//2) eliminate the use of block-cache and just retrieve wanted block from ColdStorage(relies on RocksDB for performance)
	std::lock_guard<std::recursive_mutex> lock1(mReceiptsGuardian);
	CSolidStorage* ss = getSolidStorage();
	try {

		if (receiptID.size() != 33)
			return nullptr;
		eBlockInstantiationResult::eBlockInstantiationResult bir;

		if (blockID.size() == 0)
		{//if no BlockID is known then attempt to find the receipt within the receipts cache
			robin_hood::unordered_map<std::vector<uint8_t>, std::vector<uint8_t>>::iterator it;
			it = mReceiptsBlocksIndex.find(receiptID);
			if (it != mReceiptsBlocksIndex.end())
				const_cast<std::vector<uint8_t>&>(blockID) = it->second;

		}

		std::vector<uint8_t> receiptHash;
		//try to find a receipt by its Link; note: a Link might not exist already; it might had been pruned.
		if (ss->loadLink(receiptID, receiptHash, eLinkType::eLinkType::receiptsGUIDtoReceiptsHash))
		{
			ss->loadLink(receiptHash, const_cast<std::vector<uint8_t> &>(blockID), eLinkType::eLinkType::receiptHashToBlockID);
		}

		if (blockID.size() > 0)
		{	//a specific block ID is known
			std::shared_ptr<CBlock> container;
			//first try to find the block within RAM cache
			container = getBlockByHash(blockID, bir, true); //  under the hood employs a 3-level cache

			if (container != nullptr)
			{
				const_cast<uint64_t&>(confirmedtTimestamp) = container->getHeader()->getSolvedAtTime();

				if (container->getReceipt(receiptHash, receipt))
				{
					// Is On-Chain Validation - BEGIN
					if (checkIfOnChain)
					{
						if (!isBlockInChainProof(blockID, container->getHeader()->getHeight(), eChainProof::heaviestCached))
						{
							// the block which contains the transaction is NO LONGER part of the current fork.
							// we thus mark the transaction as 'Forked Out.
							// IMPORTANT: it's an EPHEMERAL state. A receipt with such a state CANNOT be processed any further, for any purpose. 
							//			  Even the identifier of such a Receipt is ephemeral and invalid.
							receipt.setResult(eTransactionValidationResult::forkedOut);
						}
					}
					// Is On-Chain Validation - END
					receipt.setBlockInfo(container);//todo: ALSO relevant for getTransaction() method! Remove this line and make sure proper data is stored within of the chain. (as part of a Hard Fork).
					CTransaction tempTX;
					container->getTransaction(receipt.getVerifiableID(), tempTX);
					std::shared_ptr<CTransaction> tx = std::make_shared<CTransaction>();
					(*tx) = tempTX;

					const_cast<uint64_t&>(timestamp) = tx->getTime();

					return tx;
				}
				else
					return nullptr;
			}
			else return nullptr;
		}
		else return nullptr;
	}
	catch (...)
	{
		getTools()->writeLine("an error during transaction retrieval has occurred.");
		return nullptr;
	}

}
bool CBlockchainManager::reportCryticalError(std::string description)
{
	std::lock_guard<std::mutex> lock(mFieldsGuardian);
	mNrOfCryticalErrors++;
	return true;
}
uint64_t CBlockchainManager::getNrOfErrors()
{
	std::lock_guard<std::mutex> lock(mFieldsGuardian);
	return mNrOfCryticalErrors;
}

void CBlockchainManager::pingLastLivenessCheck() {
	std::unique_lock lock(mLivenessGuardian);
	mLastLivenessCheck = std::time(0);
}

uint64_t CBlockchainManager::getLastLivenessCheck() const {
	std::shared_lock lock(mLivenessGuardian);
	return mLastLivenessCheck;
}

eLivenessState::eLivenessState CBlockchainManager::getLiveness(bool allowCached)
{
	// Local Variables - BEGIN
	eLivenessState::eLivenessState currentLiveness;
	uint64_t now;
	std::shared_ptr<CBlock> leader;
	uint64_t leaderTime;
	// Local Variables - END

	// Cache Support - BEGIN
	if (allowCached) {
		now = std::time(0);
		uint64_t lastCheck = getLastLivenessCheck();
		if (now - lastCheck < LIVENESS_CACHE_TIMEOUT) {
			std::shared_lock lock(mLivenessGuardian);
			return mCachedLiveness;
		}
	}
	// Cache Support - END

	// Operational Logic - BEGIN
	// Liveness Calculation - BEGIN
	now = std::time(0);
	// Retrieve the cached leader block (the most recent solved block)
	leader = getCachedLeader();
	// If there's no cached leader, we cannot determine the state of the blockchain
	if (!leader)
	{
		// No leader indicates a critical issue in the network
		currentLiveness = eLivenessState::noLiveness;
	}
	else
	{
		// Get the time when the leader's block was solved
		leaderTime = leader->getHeader()->getSolvedAtTime();
		// Check for high liveness: the leader block was solved within the last 10 minutes
		if (leaderTime > now || ((now - leaderTime) < 600))  // 600 seconds = 10 minutes
		{
			// The blockchain is live and functioning well, blocks are being solved promptly
			currentLiveness = eLivenessState::highLiveness;
		}
		// Check for medium liveness: the leader block was solved between 10 and 30 minutes ago
		else if ((now - leaderTime) < 1800)  // 1800 seconds = 30 minutes
		{
			// The blockchain is still active, but block solving is slightly delayed
			currentLiveness = eLivenessState::mediumLiveness;
		}
		// Check for low liveness: the leader block was solved between 30 minutes and 3 hours ago
		else if ((now - leaderTime) < (3600 * 3))  // 3600 seconds = 1 hour
		{
			// The blockchain is becoming slow, and there may be potential issues
			currentLiveness = eLivenessState::lowLiveness;
		}
		else
		{
			// No blocks solved for more than 3 hours, indicating severe issues
			currentLiveness = eLivenessState::noLiveness;
		}
	}
	// Liveness Calculation - END

	// Cache Update - BEGIN
	{
		std::unique_lock lock(mLivenessGuardian);
		mCachedLiveness = currentLiveness;
		mLastLivenessCheck = now;
	}
	// Cache Update - END
	// Operational Logic - END

	return currentLiveness;
}


void CBlockchainManager::resetDailyPrice() {
	mDailyOpenAttoPerUSD = mCachedAttoPerUSD;
	mLastDailyReset = std::time(0);
}
// If GNC is worth 5 USD, then 1 Atto should be worth 5/10^18 USD
// And 1 USD should be worth 10^18/5 Atto
// So for example:
// At 5 USD per GNC: 1 USD = 200000000000000000 Atto (2*10^17)
// At 10 USD per GNC: 1 USD = 100000000000000000 Atto (10^17)

BigInt CBlockchainManager::generateNewAttoPerUSD(double floorUSDPrice, double ceilingUSDPrice) const {
	const BigInt ATTO_PER_GNC("1000000000000000000"); // 1e18
	const double MAX_DAILY_FLUCTUATION = 0.05; // Example fluctuation limit

	// Convert BigInt ATTO_PER_GNC to BigFloat
	BigFloat attoPerGNC(ATTO_PER_GNC);

	BigFloat minUSDPrice, maxUSDPrice;

	// Validate floor and ceiling prices
	if (floorUSDPrice <= 0 || ceilingUSDPrice <= 0) {
		throw std::runtime_error("Floor and ceiling prices must be positive numbers.");
	}

	if (floorUSDPrice > ceilingUSDPrice) {
		throw std::runtime_error("Invalid floor and ceiling prices: floorUSDPrice > ceilingUSDPrice");
	}

	// Get current USD price from stored Atto per USD rate
	BigFloat dailyOpenAttoPerUSD(mDailyOpenAttoPerUSD);

	if (dailyOpenAttoPerUSD == 0) {
		// If dailyOpenAttoPerUSD is zero, use floor and ceiling prices directly
		minUSDPrice = BigFloat(floorUSDPrice);
		maxUSDPrice = BigFloat(ceilingUSDPrice);
	}
	else {
		// Calculate daily open USD price
		BigFloat dailyOpenUSDPrice = attoPerGNC / dailyOpenAttoPerUSD;
		BigFloat fluctuationFactor = BigFloat(MAX_DAILY_FLUCTUATION);

		// Calculate allowable price range based on daily fluctuation
		minUSDPrice = (boost::multiprecision::max)(
			BigFloat(floorUSDPrice),
			dailyOpenUSDPrice * (1 - fluctuationFactor)
			);

		maxUSDPrice = (boost::multiprecision::min)(
			BigFloat(ceilingUSDPrice),
			dailyOpenUSDPrice * (1 + fluctuationFactor)
			);
	}

	// Validate min and max prices
	if (minUSDPrice > maxUSDPrice) {
		throw std::runtime_error("Invalid price range: minUSDPrice > maxUSDPrice");
	}

	// Generate random price within allowed range
	std::random_device rd;
	std::mt19937 gen(rd());

	// Convert BigFloat to double for random number generation
	double minPrice = minUSDPrice.convert_to<double>();
	double maxPrice = maxUSDPrice.convert_to<double>();

	// Check for conversion errors
	if (!std::isfinite(minPrice) || !std::isfinite(maxPrice) || minPrice <= 0 || maxPrice <= 0) {
		throw std::runtime_error("Price conversion to double failed due to overflow or invalid value.");
	}

	std::uniform_real_distribution<double> dis(minPrice, maxPrice);
	double newUSDPrice_dbl = dis(gen);

	// Ensure newUSDPrice is not zero
	if (newUSDPrice_dbl <= 0) {
		throw std::runtime_error("Generated newUSDPrice is zero or negative.");
	}

	BigFloat newUSDPrice(newUSDPrice_dbl);

	// Calculate new Atto per USD rate
	BigFloat newAttoPerUSD = attoPerGNC / newUSDPrice;

	// Convert to BigInt (truncates towards zero)
	BigInt newAttoPerUSD_BI = newAttoPerUSD.convert_to<BigInt>();

	// Ensure newAttoPerUSD_BI is not zero
	if (newAttoPerUSD_BI == 0) {
		throw std::runtime_error("Calculated newAttoPerUSD is zero.");
	}

	return newAttoPerUSD_BI;
}

/**
   * @brief Get the current number of Atto GNC units purchasable for 1 USD (stub implementation).
   *
   * This method provides a simulated GNC/USDT price in terms of Atto GNC units per USD for
   * testing and development purposes. It is a stub implementation that will be replaced
   * with real-time data from live exchanges in the future.
   *
   * Functionality:
   * 1. Caching: The price is cached and refreshed at most once per minute (configurable) to
   *    reduce computation overhead.
   * 2. Daily Reset: The daily open price is reset every 24 hours to simulate a new trading day.
   * 3. Price Fluctuation: The price fluctuates randomly but is constrained to a maximum of
   *    10% change from the daily open price, simulating realistic market behavior.
   * 4. Thread Safety: The method is thread-safe, allowing multiple readers with efficient
   *    locking mechanisms.
   *
   * Price Generation Rules:
   * - The price is always between the specified floor and ceiling values (in USD per GNC).
   * - Intraday price changes are limited to ±10% from the daily open price.
   * - A new random price is generated only when the cache expires.
   * - 1 GNC = 1,000,000,000,000,000,000 (1e18) Atto GNC units.
   *
   * @param floorUSDPrice The minimum possible price in USD per GNC (default: 5.0 USD).
   * @param ceilingUSDPrice The maximum possible price in USD per GNC (default: 10.0 USD).
   *
   * @return The current simulated number of Atto GNC units purchasable for 1 USD as a BigInt.
   *
   * @note This is a stub implementation. In the production version, this method will be
   *       replaced with one that fetches real-time price data from live cryptocurrency exchanges.
   *
   * @warning Do not use this method for actual trading or financial decisions. The prices
   *          generated are simulated and do not reflect real market conditions.
   */
BigInt CBlockchainManager::getGNCUSDTprice(double floorUSDPrice, double ceilingUSDPrice) {
	uint64_t now = std::time(0);

	// Check if we need to reset the daily open price
	{
		std::shared_lock readLock(mPriceGuardian);
		if (now - mLastDailyReset >= SECONDS_IN_DAY) {
			readLock.unlock();
			std::unique_lock writeLock(mPriceGuardian);
			if (now - mLastDailyReset >= SECONDS_IN_DAY) {
				resetDailyPrice();
			}
		}
	}

	// Check if we can return the cached price
	{
		std::shared_lock readLock(mPriceGuardian);
		if (now - mLastPriceCheck < PRICE_CACHE_TIMEOUT) {
			return mCachedAttoPerUSD;
		}
	}

	// Generate a new price
	BigInt newAttoPerUSD;
	{
		std::unique_lock writeLock(mPriceGuardian);
		if (now - mLastPriceCheck < PRICE_CACHE_TIMEOUT) {
			return mCachedAttoPerUSD;
		}
		newAttoPerUSD = generateNewAttoPerUSD(floorUSDPrice, ceilingUSDPrice);
		mCachedAttoPerUSD = newAttoPerUSD;
		mLastPriceCheck = now;
	}

	return newAttoPerUSD;
}
double CBlockchainManager::getCurrentGNCPriceInUSD() const {
	std::shared_lock readLock(mPriceGuardian);
	BigFloat attoPerUSD = static_cast<BigFloat>(mCachedAttoPerUSD);
	BigFloat gncPriceInUSD = static_cast<BigFloat>(ATTO_PER_GNC) / attoPerUSD;
	return static_cast<double>(gncPriceInUSD);
}
std::shared_ptr<CSearchResults> CBlockchainManager::searchBlocks(const std::string& query, uint64_t size, uint64_t page, const CSearchFilter& filter) {
	// Local Variables - BEGIN
	std::vector<CSearchResults::ResultData> results;
	uint64_t totalCount = 0;
	uint64_t startIndex = (page - 1) * size;
	uint64_t endIndex = startIndex + size;
	std::shared_ptr<CTools> tools = CTools::getInstance();
	uint64_t currentHeight = getHeight();
	uint64_t blockHeight = currentHeight;
	uint64_t hotStorageLength = getHotStorageCacheLength();
	uint64_t minBlockHeight = (currentHeight > hotStorageLength) ? (currentHeight - hotStorageLength + 1) : 0;
	// Local Variables - END

	// Operational Logic - BEGIN
	try {
		// Exact Search - BEGIN
		std::vector<uint8_t> blockID = tools->stringToBytes(query);
		if (tools->isBlockIDValid(blockID)) {
			eBlockInstantiationResult::eBlockInstantiationResult result;
			std::shared_ptr<CBlock> block = getBlockByHash(blockID, result);
			if (block) {

				// Block Meta Data - BEGIN
				auto blockDesc = block->getDescription();  // attempt to re-use existing block meta-data
				if (!blockDesc)  // only if not available generate block meta-data
				{
					std::string errorMessage;
					blockDesc = createBlockDescription(block, true, true, errorMessage);

					if (!blockDesc) {
						mTools->logEvent(
							"Failed to create block description for block: " +
							mTools->base58CheckEncode(block->getID()) +
							" [Reason]: " + (errorMessage.empty() ? "Unknown error" : errorMessage),
							"GetBlockDetails",
							eLogEntryCategory::localSystem,
							5,
							eLogEntryType::failure
						);
					}
					else {
						block->setDescription(blockDesc);
					}
				}
				// Block Meta Data - END

				if (matchesBlockFilter(blockDesc, query, filter)) {
					if (page == 1) {
						results.emplace_back(blockDesc);
					}
					return std::make_shared<CSearchResults>(results, 1, page, size);
				}
			}
		}
		// Exact Search - END

		// Fuzzy Search - BEGIN
		while (blockHeight >= minBlockHeight) {
			std::shared_ptr<CBlock> block = getBlockAtHeight(blockHeight, false, eChainProof::verifiedCached);
			if (!block) {
				// End of cache/data reached
				break;
			}

			// Block Meta Data - BEGIN
			auto blockDesc = block->getDescription();  // attempt to re-use existing block meta-data
			if (!blockDesc)  // only if not available generate block meta-data
			{
				std::string errorMessage;
				blockDesc = createBlockDescription(block, true, true, errorMessage);

				if (!blockDesc) {
					mTools->logEvent(
						"Failed to create block description for block: " +
						mTools->base58CheckEncode(block->getID()) +
						" [Reason]: " + (errorMessage.empty() ? "Unknown error" : errorMessage),
						"GetBlockDetails",
						eLogEntryCategory::localSystem,
						5,
						eLogEntryType::failure
					);
				}
				else {
					block->setDescription(blockDesc);
				}
			}
			// Block Meta Data - END

			if (matchesBlockFilter(blockDesc, query, filter)) {
				totalCount++;
				if (totalCount > startIndex && totalCount <= endIndex) {
					results.emplace_back(blockDesc);
					if (results.size() >= size) {
						// We have enough results for this page
						break;
					}
				}
			}
			blockHeight--;
		}
		// Fuzzy Search - END
	}
	catch (const std::exception& e) {
		// Log the error
		CTools::getInstance()->logEvent("Error in searchBlocks: " + std::string(e.what()), "CBlockchainManager::searchBlocks", eLogEntryCategory::localSystem, 5, eLogEntryType::failure, eColor::cyborgBlood);
	}
	// Operational Logic - END

	// Handle case where there are fewer results than requested
	return std::make_shared<CSearchResults>(results, totalCount, page, size);
}

std::shared_ptr<CBlockDesc> CBlockchainManager::createBlockDescription(
	const std::shared_ptr<CBlock>& block,
	bool includeTXdetails,
	bool updateGlobalTXcache,
	const std::string& errorMessage,
	bool doSecAssessment

)
{
	try {
		// Preliminaries - BEGIN
		if (!block) {
			const_cast<std::string&>(errorMessage) = "Input block pointer is null";
			return nullptr;
		}
		// Preliminaries - END

		// Local Variables - BEGIN
		uint64_t totalWorkDone;
		auto header = block->getHeader();
		BigInt blockReward;
		blockReward = header->getTotalBlockReward(true);
		std::vector<std::shared_ptr<CTransactionDesc>> txData;
		std::vector<uint8_t> operatorID = header->getMinersID();
		// Local Variables - END

		// Operator ID - BEGIN
		if (operatorID.empty() && header->isKeyBlock() == false)
		{
			std::shared_ptr<CBlock> parentKeyBlock = getKeyBlockForBlock(block, false, eChainProof::verifiedCached, true);

			if (parentKeyBlock)
			{
				operatorID = parentKeyBlock->getHeader()->getMinersID();
			}
		}
		// Operator ID - END

		// Total Difficulty - BEGIN
		CBlockVerificationResult verRes;
		totalWorkDone = block->getTotalWorkDone(verRes);
		// Total Difficulty - END

		// Generate TX Meta Data - BEGIN
		if (includeTXdetails && header->isKeyBlock() == false)
		{
			// Populate transactions - BEGIN
			auto transactions = block->getTransactions();

			for (auto& tx : transactions)
			{
				CReceipt receipt;
				uint64_t confirmedTimestamp = header->getSolvedAtTime();
				uint64_t unconfirmedTimestamp = tx.getTime();
				bool receiptFound = header->getReceiptForTransaction(tx.getHash(), receipt, false);

				// Prepare Meta-Data - BEGIN

				// Pre-Computed Meta-Data Available - BEGIN
				// Rationale: Transaction metadata (CTransactionDesc) is cached in mRecentTransactionsByReceiptID
				// for performance. The cache maintains a specific ordering (by transaction time) that must be
				// preserved. If cached metadata exists, we use it directly without re-validation here.
				//
				// Note: Block ID validation for fork scenarios (stale block references) is handled at query time
				// in handleGetTransactionDetails() via isBlockInChainProof() check, not during cache population.
				// This design preserves cache ordering integrity while still detecting forked-out transactions.
				std::shared_ptr<CTXInfo> txInfo = getTransactionInfoByReceiptID(mTools->getReceiptIDForTransaction(eBlockchainMode::TestNet, tx.getHash()));

				if (txInfo && txInfo->getDescription())
				{
					txData.push_back(txInfo->getDescription());
				}
				// Pre-Computed Meta-Data Available - END

				// Pre-Computed Meta-Data Not Available - BEGIN
				// Only generate new metadata if not already cached. This ensures each transaction
				// is added to the cache exactly once, preserving the time-based ordering.
				else {
					std::shared_ptr<CTransaction> txS = std::make_shared<CTransaction>(tx);
					std::shared_ptr<CReceipt> recS = std::make_shared<CReceipt>(receipt);
					std::string txError;
					CSearchResults::ResultData desc = createTransactionDescription(
						txS,
						recS,
						header->getSolvedAtTime(),
						true,// <- generate advanced TX meta-data based on decompiled source-code etc.
						header,
						txError// should anything go wrong with TX meta-data generation - report to Operator
					);

					if (std::holds_alternative<std::shared_ptr<CTransactionDesc>>(desc)) {
						auto transDesc = std::get<std::shared_ptr<CTransactionDesc>>(desc);
						if (transDesc) {
							txData.push_back(transDesc);
							// Global TX Meta-Data Cache - BEGIN
							if (updateGlobalTXcache)
							{
								// TX Info object to be cached by CBlockchainManager
								txInfo = std::make_shared<CTXInfo>(txS, recS, transDesc);  // Use transDesc instead of desc

								registerReceiptWithinCache(receipt, block->getID()); // update the hot-storage receipt->block ID cache; notice there's also a cold storage cache based on mSolidStorage->saveLink() method invocations (after each block is processed).

								updateTransactionCache(txInfo);
							}
							// Global TX Meta-Data Cache - END
						}
						else {
							mTools->logEvent("Created transaction description is null for transaction: " + mTools->base58CheckEncode(tx.getHash()),
								"GetBlockDetails", eLogEntryCategory::localSystem, 5, eLogEntryType::failure);
						}
					}
					else {
						mTools->logEvent("Failed to create transaction description for transaction:"
							+ mTools->base58CheckEncode(tx.getHash())
							+ "[ Reason]: " + txError,
							"GetBlockDetails", eLogEntryCategory::localSystem, 5, eLogEntryType::failure);
					}
				}
				// Pre-Computed Meta-Data Not Available - END
				// Prepare Meta-Data - END

				// Decompile and retrieve meta-data - END
			}
			// Populate transactions - END
		}
		// Generate TX Meta Data - END

		// Create Block Description - BEGIN
		std::shared_ptr<CBlockDesc> blockDesc = std::make_shared<CBlockDesc>(
			header->getCoreVersion(),
			mTools->base58CheckEncode(block->getID()),
			header->isKeyBlock() ? eBlockType::keyBlock : eBlockType::dataBlock,
			header->getKeyHeight(),
			header->getHeight(),
			header->getSolvedAtTime(),
			mTools->bytesToString(operatorID),
			header->getDifficulty(),
			totalWorkDone,
			mTools->base58CheckEncode(header->getParentID()),
			header->getErgUsed(),
			header->getErgLimit(),
			header->getNonce(),
			blockReward,
			header->getTotalBlockReward(false),
			header->getTotalBlockReward(true),
			header->getPaidToMiner(false),
			header->getPaidToMiner(true),
			header->getNrOfReceipts(),
			header->getNrOfTransactions(),
			header->getNrOfVerifiables(),
			txData, // Transactions
			block->getSize()
		);
	
		// Create Block Description - END

		// Security Assessment - BEGIN
		if (doSecAssessment && header->isKeyBlock() == false)
		{
			// Variables to collect data
			int totalTransactions = txData.size();
			std::unordered_set<std::string> uniqueSenders;
			std::unordered_set<std::string> suspiciousSenders;
			std::unordered_map<std::string, std::vector<int64_t>> senderTimeDiffs;
			std::unordered_map<std::string, double> senderAvgTimeDiff;
			std::vector<std::shared_ptr<CTransactionDesc>> suspiciousTxs; // Suspicious transactions

			uint64_t blockConfirmationTime = header->getSolvedAtTime();

			for (const auto& txDesc : txData)
			{
				uint64_t confirmedTimestamp = txDesc->getConfirmedTimestamp();
				uint64_t unconfirmedTimestamp = txDesc->getUnconfirmedTimestamp();

				int64_t timeDiff = static_cast<int64_t>(confirmedTimestamp) - static_cast<int64_t>(unconfirmedTimestamp);

				// Record the sender
				std::string sender = txDesc->getSender();
				uniqueSenders.insert(sender);

				// Collect time differences per sender
				senderTimeDiffs[sender].push_back(timeDiff);

				if (std::abs(timeDiff) > 10800) // 3 hours in seconds
				{
					// Transaction is suspicious
					suspiciousTxs.push_back(txDesc);

					// Mark sender as suspicious
					suspiciousSenders.insert(sender);
				}
			}

			// Compute average time differences per sender
			for (const auto& [sender, diffs] : senderTimeDiffs)
			{
				double sum = 0;
				for (auto diff : diffs)
				{
					sum += diff;
				}
				double avg = sum / diffs.size();
				senderAvgTimeDiff[sender] = avg;
			}

			int totalUniqueSenders = uniqueSenders.size();
			int totalSuspiciousSenders = suspiciousSenders.size();

			if (totalSuspiciousSenders > 0)
			{
				// Compute mean and standard deviation of suspicious senders' average time differences
				std::vector<double> suspiciousSenderAvgTimeDiffs;

				for (const auto& sender : suspiciousSenders)
				{
					suspiciousSenderAvgTimeDiffs.push_back(senderAvgTimeDiff[sender]);
				}

				// Compute mean
				double sum = 0;
				for (auto avgDiff : suspiciousSenderAvgTimeDiffs)
				{
					sum += avgDiff;
				}
				double mean = sum / suspiciousSenderAvgTimeDiffs.size();

				// Compute standard deviation
				double variance = 0;
				for (auto avgDiff : suspiciousSenderAvgTimeDiffs)
				{
					variance += (avgDiff - mean) * (avgDiff - mean);
				}
				double stdDev = sqrt(variance / suspiciousSenderAvgTimeDiffs.size());

				double proportionSuspiciousSenders = static_cast<double>(totalSuspiciousSenders) / totalUniqueSenders;

				// Generate analysis hints
				std::stringstream hint;
				hint << "Suspicious time differences detected in " << totalSuspiciousSenders << " out of " << totalUniqueSenders << " unique senders.";
				blockDesc->addAdditionalAnalysisHint(hint.str());

				// Decide whether node operator is likely at fault
				if (proportionSuspiciousSenders > 0.5 && stdDev < (0.1 * std::abs(mean)))
				{
					// Node operator might be manipulating timestamps
					std::stringstream nodeHint;
					nodeHint << "High proportion of senders (" <<
						(proportionSuspiciousSenders * 100) << "%) have similar average time differences (mean: "
						<< mean << "s, std dev: " << stdDev
						<< "s). Node operator may be manipulating the block timestamp.";
					blockDesc->addAdditionalAnalysisHint(nodeHint.str());
				}
				else
				{
					// Transaction issuers might be at fault
					std::stringstream txIssuerHint;
					txIssuerHint << "Transactions from the following senders have suspicious time differences:";
					blockDesc->addAdditionalAnalysisHint(txIssuerHint.str());

					// List the suspicious senders and their average time differences
					for (const auto& sender : suspiciousSenders)
					{
						std::stringstream senderHint;
						senderHint << "Sender: " << sender << ", Average Time Difference: " << senderAvgTimeDiff[sender] << " seconds.";
						blockDesc->addAdditionalAnalysisHint(senderHint.str());
					}
				}

				// For each suspicious transaction, add analysis hints
				for (const auto& txDesc : suspiciousTxs)
				{
					int64_t timeDiff = static_cast<int64_t>(txDesc->getConfirmedTimestamp()) - static_cast<int64_t>(txDesc->getUnconfirmedTimestamp());
					std::string sender = txDesc->getSender();
					std::stringstream txHint;
					txHint << "Transaction from sender " << sender << " has suspicious time difference of " << timeDiff << " seconds.";
					txDesc->addAdditionalAnalysisHint(txHint.str());
				}
			}
		}
		// Security Assessment - END


		return blockDesc;
	}
	catch (const std::exception& e) {
		const_cast<std::string&>(errorMessage) = "Exception while creating block description: " + std::string(e.what());
		return nullptr;
	}
	catch (...) {
		const_cast<std::string&>(errorMessage) = "Unknown error occurred while creating block description";
		return nullptr;
	}
}


bool CBlockchainManager::matchesBlockFilter(const std::shared_ptr<CBlockDesc>& blockDesc, const std::string& query, const CSearchFilter& filter) {
	// Check if block description is valid
	if (!blockDesc) {
		return false;
	}

	// Check if blocks are included in the search
	if (!filter.hasStandardFlag(CSearchFilter::StandardFlags::BLOCKS)) {
		return false;
	}

	// Local variables
	std::shared_ptr<CTools> tools = CTools::getInstance();
	std::string trimmedQuery = tools->trim(query);

	// Check custom filters
	auto checkProperty = [&](const std::string& propertyName, const std::string& value) {
		std::string key = "block_" + propertyName;
		bool flagPresent = filter.hasArbitraryFlag(key);

		if (flagPresent) {
			std::string requestedValue = tools->trim(filter.getArbitraryFlagValue(key));

			if (requestedValue.empty()) {
				// If flag is present but value is empty, we're just checking
				// for the existence of the property with non-empty content
				return !tools->trim(value).empty();
			}
			else {
				// Compare the trimmed requested value with the property value
				return tools->findStringIC(value, requestedValue);
			}
		}
		return false;
		};

	// Check all properties of CBlockDesc
	if (checkProperty("blockID", blockDesc->getBlockID()))
		return true;
	if (checkProperty("type", blockDesc->getType() == eBlockType::keyBlock ? "Key Block" : "Data Block"))
		return true;
	if (checkProperty("keyHeight", std::to_string(blockDesc->getKeyHeight())))
		return true;
	if (checkProperty("height", std::to_string(blockDesc->getHeight())))
		return true;
	if (checkProperty("solvedAt", tools->timeToString(blockDesc->getSolvedAt())))
		return true;
	if (checkProperty("minerID", blockDesc->getMinerID()))
		return true; // already base58check encoded
	if (checkProperty("parentID", blockDesc->getParentID()))
		return true; // already base58check encoded
	if (checkProperty("ergUsed", blockDesc->getErgUsed().str()))
		return true;
	if (checkProperty("ergLimit", blockDesc->getErgLimit().str()))
		return true;
	if (checkProperty("nonce", std::to_string(blockDesc->getNonce())))
		return true;
	if (checkProperty("blockReward", blockDesc->getTotalRewardTxt(true)))
		return true;
	if (checkProperty("receiptsCount", std::to_string(blockDesc->getReceiptsCount())))
		return true;
	if (checkProperty("transactionsCount", std::to_string(blockDesc->getTransactionsCount())))
		return true;

	// If no custom filters are set, perform a general search
	if (filter.getArbitraryFlagCount() == 0) {
		// Skip empty query searches
		if (trimmedQuery.empty()) {
			return false;
		}

		return tools->findStringIC(blockDesc->getBlockID(), trimmedQuery) ||
			tools->findStringIC(blockDesc->getMinerID(), trimmedQuery) ||
			tools->findStringIC(std::to_string(blockDesc->getHeight()), trimmedQuery);
	}

	return false;
}


// Block Search - END

/*
  Performs a partial, multi-parameter search on the domain of transactions.
  Important: it is paramount we perform such a search on in-memory cached blocks only (performance).

  Only when the search query looks like a valid transaction identifier do we perform an index-backed exact search across
  the entire search domain.

  [ ORDER OF RETURNED DATA ]
  Latest to oldest, as exemplified below:
  {INDEX 0} Mem-Pool Objects , On-Chain Objects { Genesis Block }
*/
std::shared_ptr<CSearchResults> CBlockchainManager::searchTransactions(const std::string& query, uint64_t size, uint64_t page, const CSearchFilter& filter) {
	// Local Variables - BEGIN
	std::vector<CSearchResults::ResultData> results;
	uint64_t totalCount = 0;
	uint64_t startIndex = (page - 1) * size;
	uint64_t endIndex = startIndex + size;
	std::shared_ptr<CTools> tools = CTools::getInstance();
	uint64_t currentHeight = getCachedHeight();
	uint64_t blockHeight = currentHeight;
	std::shared_ptr<CTransactionManager> tm = getLiveTransactionsManager();
	uint64_t blockCacheLength = getHotStorageCacheLength();
	uint64_t minBlockHeight = (currentHeight > blockCacheLength) ? (currentHeight - blockCacheLength) : 0;
	const_cast<std::string&>(query) = mTools->trim(query);
	// Local Variables - END

	// Operational Logic - BEGIN

	// Exact Search - BEGIN
	std::vector<uint8_t> receiptID;


	if (mTools->base58CheckDecode(query, receiptID) && tools->isReceiptIDValid(receiptID)) {// decode and validate decoded
		// Pre-Computed Meta-Data Available - BEGIN
		std::shared_ptr<CTXInfo> txInfo = getTransactionInfoByReceiptID(receiptID);
		if (txInfo && txInfo->getDescription()) {
			auto desc = txInfo->getDescription();
			CSearchResults::ResultData resultData(desc);
			if (matchesTransactionFilter(resultData, query, filter)) {
				if (page == 1) {
					results.emplace_back(std::move(resultData));
				}
				return std::make_shared<CSearchResults>(std::move(results), 1, page, size);
			}
		}
		// Pre-Computed Meta-Data Available - END

		// Pre-Computed Meta-Data Not Available - BEGIN
		CReceipt receipt;
		uint64_t confirmedTimestamp = 0;
		uint64_t unconfirmedTimestamp = 0;
		std::vector<uint8_t> blockID;
		auto tx = findTransaction(receiptID, receipt, confirmedTimestamp, unconfirmedTimestamp, false, blockID);
		if (tx) {
			CSearchResults::ResultData desc = createTransactionDescription(
				tx,
				std::make_shared<CReceipt>(receipt),
				confirmedTimestamp,
				false,
				nullptr  // We're not including block header details here
			);
			if (matchesTransactionFilter(desc, query, filter)) {
				if (page == 1) {
					results.emplace_back(std::move(desc));
				}
				return std::make_shared<CSearchResults>(std::move(results), 1, page, size);
			}
			else {
				tools->logEvent("Failed to match transaction filter for transaction:" + tools->base58CheckEncode(tools->getReceiptIDForTransaction(mMode, tx->getHash())),
					"ExactSearch", eLogEntryCategory::localSystem, 5, eLogEntryType::failure);
			}
		}
		// Pre-Computed Meta-Data Not Available - END
	}
	// Exact Search - END

	// Partial Fuzzy Search
	// Handle memory pool transactions - BEGIN
	std::vector<std::shared_ptr<CTransaction>> memPoolTransactions = tm->getUnprocessedTransactions(eTransactionSortingAlgorithm::recentFirst);
	for (auto& tx : memPoolTransactions) {
		auto resultData = createTransactionDescription(tx, nullptr, 0, false);
		if (matchesTransactionFilter(resultData, query, filter)) {
			totalCount++;
			if (totalCount > startIndex && totalCount <= endIndex) {
				results.emplace_back(resultData);
			}
			if (totalCount >= endIndex) {
				return std::make_shared<CSearchResults>(std::move(results), totalCount, page, size);
			}
		}
	}
	// Handle memory pool transactions - END

	// Handle on-chain transactions - BEGIN
	while (blockHeight > minBlockHeight) {
		std::shared_ptr<CBlock> block = getBlockAtHeight(blockHeight, false, eChainProof::verifiedCached);
		if (!block) {
			blockHeight--;
			continue;
		}
		for (auto& tx : block->getTransactions()) {
			auto txS = std::make_shared<CTransaction>(tx);
			// Retrieve Receipt - BEGIN
			CReceipt rec;
			block->getHeader()->getReceiptForTransaction(txS->getHash(), rec, false);
			std::shared_ptr<CReceipt> receipt = std::make_shared<CReceipt>(rec);
			// Retrieve Receipt - END
			auto resultData = createTransactionDescription(txS, receipt, block->getHeader()->getSolvedAtTime(), false);
			if (matchesTransactionFilter(resultData, query, filter)) {
				totalCount++;
				if (totalCount > startIndex && totalCount <= endIndex) {
					results.emplace_back(resultData);
				}
				if (totalCount >= endIndex) {
					return std::make_shared<CSearchResults>(std::move(results), totalCount, page, size);
				}
			}
		}
		blockHeight--;
	}
	// Handle on-chain transactions - END
	// Operational Logic - END

	// Handle case where there are fewer results than requested
	return std::make_shared<CSearchResults>(std::move(results), totalCount, page, size);
}

bool CBlockchainManager::matchesTransactionFilter(CSearchResults::ResultData& resultData, const std::string& query, const CSearchFilter& filter) {
	
	
	// Preliminaries - BEGIN
	if (resultData.isNull()) {
		return false;
	}

	if (!filter.hasStandardFlag(CSearchFilter::StandardFlags::TRANSACTIONS)) {
		return false;
	}

	auto txDescPtr = std::get_if<std::shared_ptr<CTransactionDesc>>(&resultData);
	if (!txDescPtr || !*txDescPtr) {
		return false;
	}
	auto& txDesc = **txDescPtr;
	// Preliminaries - END

	// Local Variables - BEGIN
	std::shared_ptr<CTools> tools = CTools::getInstance();
	std::string trimmedQuery = tools->trim(query);
	// Local Variables - END

	// Operational Logic - BEGIN
	// Check custom filters
	auto checkProperty = [&](const std::string& propertyName, const std::string& value) {
		std::string key = "tx_" + propertyName;
		bool flagPresent = filter.hasArbitraryFlag(key);

		if (flagPresent) {
			std::string requestedValue = tools->trim(filter.getArbitraryFlagValue(key));

			if (requestedValue.empty()) {
				// If flag is present but value is empty, we're just checking
				// for the existence of the property with non-empty content
				return !tools->trim(value).empty();
			}
			else {
				// Compare the trimmed requested value with the property value
				return tools->findStringIC(value, requestedValue);
			}
		}
		return false;
		};

	// Check all properties of CTransactionDesc
	if (checkProperty("type", std::to_string(static_cast<int>(txDesc.getType()))))
		return true;
	if (checkProperty("result", std::to_string(txDesc.getResult())))
		return true;
	if (checkProperty("value", txDesc.getValueTxt()))
		return true;
	if (checkProperty("sender", txDesc.getSender()))
		return true; // already base58check encoded
	if (checkProperty("receiver", txDesc.getReceiver()))
		return true; // already base58check encoded
	if (checkProperty("ERGUsed", txDesc.getERGUsed().str()))
		return true;
	if (checkProperty("verifiableID", txDesc.getVerifiableID()))
		return true; // already base58check encoded
	if (checkProperty("sacrificedValue", txDesc.getSacrificedValue().str()))
		return true;
	if (checkProperty("sourceCode", txDesc.getSourceCode()))
		return true;
	if (checkProperty("ERGLimit", txDesc.getERGLimit().str()))
		return true;
	if (checkProperty("nonce", std::to_string(txDesc.getNonce())))
		return true;

	// Timestamps - BEGIN
	// Numerical Timestamp Matching - BEGIN
	if (checkProperty("confirmedTimestamp", std::to_string(txDesc.getConfirmedTimestamp())))
		return true;
	if (checkProperty("unconfirmedTimestamp", std::to_string(txDesc.getUnconfirmedTimestamp())))
		return true;
	// Numerical Timestamp Matching - END

	// Textual Timestamp Matching - BEGIN
	if (checkProperty("confirmedTimestampTxt", txDesc.getConfirmedTimestampTxt()))
		return true;
	if (checkProperty("unconfirmedTimestampTxt", txDesc.getUnconfirmedTimestampTxt()))
		return true;
	// Textual Timestamp Matching - END
	// Timestamps - END

	// Dynamic API Compatible Getters
	if (checkProperty("resultTxt", txDesc.getResultTxt(true)))
		return true;
	if (checkProperty("taxTxt", txDesc.getTaxTxt()))
		return true;
	if (checkProperty("tax", txDesc.getTax().str()))
		return true;

	// If no custom filters are set, perform a general search
	if (filter.getArbitraryFlagCount() == 0) {
		// Skip empty query searches
		if (trimmedQuery.empty()) {
			return false;
		}

		return tools->findStringIC(txDesc.getVerifiableID(), trimmedQuery) ||
			tools->findStringIC(txDesc.getSender(), trimmedQuery) ||
			tools->findStringIC(txDesc.getReceiver(), trimmedQuery) ||
			tools->findStringIC(txDesc.getValue().str(), trimmedQuery) ||
			tools->findStringIC(txDesc.getResultTxt(true), trimmedQuery);
	}
	// Operational Logic - END

	return false;
}
// Mem-Pool Transactions' Meta-Data Cache - BEGIN
/**
 * @brief Memory pool transaction metadata cache related methods
 * These methods handle the caching of transaction metadata for transactions
 * that are still in the memory pool. The cache is implemented using a
 * robin_hood unordered map with a configurable maximum size.
 */


	/**
	 * @brief Get transaction metadata from memory pool cache
	 * @param receiptID The 32-byte receipt identifier
	 * @return ResultData containing the transaction description or nullptr if not found
	 * @throws std::invalid_argument If receipt ID is invalid
	 */
	CSearchResults::ResultData CBlockchainManager::getMemPoolTXMeta(const std::vector<uint8_t>& receiptIDP) {
		// Pre-flight Validation - BEGIN

		if (receiptIDP.empty())
			return false;

		const std::vector<uint8_t> receiptIDHash = mCryptoFactory->getSHA2_256Vec(receiptIDP);

		if (receiptIDHash.size() != 32) {
			return nullptr;
			//throw std::invalid_argument("Invalid receipt ID size");
		}
		// Pre-flight Validation - END

		// Operational Logic - BEGIN
		std::shared_lock<std::shared_mutex> lock(mMemPoolCacheMutex);
		auto it = mMemPoolTXMetaCache.find(receiptIDHash);
		if (it != mMemPoolTXMetaCache.end()) {
			return CSearchResults::ResultData(it->second);
		}
		// Operational Logic - END

		return CSearchResults::ResultData(nullptr);
	}

	/**
		 * @brief Add transaction metadata to memory pool cache
		 * @param receiptID The 32-byte receipt identifier
		 * @param txDesc Transaction description to cache
		 * @return bool True if added successfully, false if cache is full
		 * @throws std::invalid_argument If parameters are invalid
		 */
	bool CBlockchainManager::addMemPoolTXMeta(const std::vector<uint8_t>& receiptIDP, std::shared_ptr<CTransactionDesc> txDesc) {

		if (receiptIDP.empty())
		{
			return false;
		}

		const std::vector<uint8_t> receiptIDHash = mCryptoFactory->getSHA2_256Vec(receiptIDP);
		// Pre-flight Validation - BEGIN
		if (receiptIDHash.size() != 32) {
			return false;
			//throw std::invalid_argument("Invalid receipt ID size");
		}
		if (!txDesc) {
			return false;
			//throw std::invalid_argument("Invalid transaction description");
		}
		// Pre-flight Validation - END

		// Operational Logic - BEGIN
		std::unique_lock<std::shared_mutex> lock(mMemPoolCacheMutex);

		// If entry already exists, just update it
		auto existingEntry = mMemPoolTXMetaCache.find(receiptIDHash);
		if (existingEntry != mMemPoolTXMetaCache.end()) {
			existingEntry->second = txDesc;
			return true;
		}

		// For new entries, handle capacity limits
		if (mMemPoolTXMetaCache.size() >= mMaxMemPoolCacheSize) {
			// Find oldest transaction based on timestamp
			auto oldestEntry = std::min_element(
				mMemPoolTXMetaCache.begin(),
				mMemPoolTXMetaCache.end(),
				[](const auto& a, const auto& b) {
					return a.second->getUnconfirmedTimestamp() < b.second->getUnconfirmedTimestamp();
				}
			);

			if (oldestEntry != mMemPoolTXMetaCache.end()) {
				mMemPoolTXMetaCache.erase(oldestEntry);
			}
		}

		mMemPoolTXMetaCache[receiptIDHash] = txDesc;
		// Operational Logic - END

		return true;
	}
	/**
	 * @brief Add transaction metadata to memory pool cache from ResultData variant
	 * @param receiptID The 32-byte receipt identifier
	 * @param resultData ResultData variant potentially containing CTransactionDesc
	 * @return bool True if added successfully, false if invalid data or cache is full
	 * @throws std::invalid_argument If receipt ID is invalid
	 */
	bool CBlockchainManager::addMemPoolTXMeta(const std::vector<uint8_t>& receiptIDP, const CSearchResults::ResultData& resultData) {
		// Pre-flight Validation - BEGIN

		if (receiptIDP.empty()) // is to be hashed by main method below; we do not hash in wrapper to prevent double hashing
			return false;


		// Pre-flight Validation - END

		// Operational Logic - BEGIN
		if (!std::holds_alternative<std::shared_ptr<CTransactionDesc>>(resultData)) {
			return false;
		}

		auto txDesc = std::get<std::shared_ptr<CTransactionDesc>>(resultData);
		if (!txDesc) {
			return false;
		}

		return addMemPoolTXMeta(receiptIDP, txDesc);
		// Operational Logic - END
	}

	/**
	 * @brief Remove transaction metadata from memory pool cache
	 * @param receiptID The 32-byte receipt identifier
	 * @return bool True if removed, false if not found
	 * @throws std::invalid_argument If receipt ID is invalid
	 */
	bool CBlockchainManager::removeMemPoolTXMeta(const std::vector<uint8_t>& receiptIDP) {
		// Pre-flight Validation - BEGIN

		if (receiptIDP.empty())
			return false;

		const std::vector<uint8_t> receiptIDHash = mCryptoFactory->getSHA2_256Vec(receiptIDP);

		if (receiptIDHash.size() != 32) {
			return false;
			//throw std::invalid_argument("Invalid receipt ID size");
		}
		// Pre-flight Validation - END

		// Operational Logic - BEGIN
		std::unique_lock<std::shared_mutex> lock(mMemPoolCacheMutex);
		return mMemPoolTXMetaCache.erase(receiptIDHash) > 0;
		// Operational Logic - END
	}

	/**
	 * @brief Set maximum size of memory pool cache
	 * @param size New maximum cache size
	 * @throws std::invalid_argument If size is 0
	 */
	void CBlockchainManager::setMaxMemPoolCacheSize(uint64_t size) {
		// Pre-flight Validation - BEGIN
		if (size == 0) {
			return;
			//throw std::invalid_argument("Cache size cannot be 0");
		}
		// Pre-flight Validation - END

		// Operational Logic - BEGIN
		std::unique_lock<std::shared_mutex> lock(mMemPoolCacheMutex);
		mMaxMemPoolCacheSize = size;

		// If new size is smaller than current cache size, remove oldest entries
		while (mMemPoolTXMetaCache.size() > mMaxMemPoolCacheSize) {
			mMemPoolTXMetaCache.erase(mMemPoolTXMetaCache.begin());
		}
		// Operational Logic - END
	}

	/**
	 * @brief Get current maximum size of memory pool cache
	 * @return uint64_t Current maximum cache size
	 */
	uint64_t CBlockchainManager::getMaxMemPoolCacheSize() const {
		// Operational Logic - BEGIN
		std::shared_lock<std::shared_mutex> lock(mMemPoolCacheMutex);
		return mMaxMemPoolCacheSize;
		// Operational Logic - END
	}

	/**
	 * @brief Get current size of memory pool cache
	 * @return uint64_t Current number of entries in cache
	 */
	uint64_t CBlockchainManager::getCurrentMemPoolCacheSize() const {
		// Operational Logic - BEGIN
		std::shared_lock<std::shared_mutex> lock(mMemPoolCacheMutex);
		return mMemPoolTXMetaCache.size();
		// Operational Logic - END
	}

	// Mem-Pool Transactions' Meta-Data Cache - END

CSearchResults::ResultData CBlockchainManager::createTransactionDescription(
	std::shared_ptr<CTransaction> tx,
	std::shared_ptr<CReceipt> receiptA,
	uint64_t confirmedTimestamp,
	bool includeDetails,
	std::shared_ptr<CBlockHeader> blockHeader,
	const std::string& errorMessage) {
	try {
		// Local Variables - BEGIN
		uint64_t blockHeight = 0;
		uint64_t blockKeyHeight = 0;
		std::vector<uint8_t> blockID;
		std::shared_ptr<CSendCommandParsingResult> parsingResult;
		std::string sourceCode = tx->getSourceCode();
		BigInt txValue = 0;
		std::string recipient;
		uint64_t bytecodeVersion = 0;
		// Local Variables - END
		// Operational Logic - BEGIN
		if (blockHeader)
		{
			blockHeight = blockHeader->getHeight();
			blockKeyHeight = blockHeader->getKeyHeight();
			blockID = blockHeader->getHash();
		}
		else
		{
			// Mempool Transaction: No block header available yet.
			// Use current chain's keyHeight for GridScript parser version selection.
			// This ensures mempool metadata uses the same parser version that will likely
			// be used when the transaction is confirmed, preventing inconsistent metadata
			// between mempool and confirmed states (e.g., for multi-send transactions).
			blockKeyHeight = getKeyHeight();
		}
		if (includeDetails)
		{
			// Source Code Retrieval - BEGIN
			// Rationale: if cached source code not yet available.
			std::shared_ptr<CGridScriptCompiler> compiler = getCompiler();
			assertGN(mCompiler, "Compiler not available.");
			if (sourceCode.empty()) {
				// Transaction Source Rewrite System - BEGIN
				// Check if this transaction has a source code rewrite entry before decompilation
				bool sourceRewritten = false;

				if (blockHeader && receiptA)
				{
					std::vector<uint8_t> receiptID = receiptA->getGUID();
					if (receiptID.size() > 0)
					{
						std::string receiptIDBase58 = mTools->base58CheckEncode(receiptID);
						std::string replacementSource;

						if (CGlobalSecSettings::getTransactionSourceRewrite(receiptIDBase58, blockHeight, replacementSource))
						{
							// Rewrite found - use replacement source instead of decompiling
							sourceCode = replacementSource;
							sourceRewritten = true;
							tx->setSourceCode(sourceCode); // cache it

							// Log the rewrite event for audit trail
							mTools->logEvent(
								"Transaction source rewrite applied (display): receipt=" + receiptIDBase58 +
								", height=" + std::to_string(blockHeight) +
								", replacement_length=" + std::to_string(replacementSource.length()),
								eLogEntryCategory::VM,
								0
							);
						}
					}
				}

				// If no rewrite was applied, perform standard bytecode decompilation
				if (!sourceRewritten)
				{
					if (!compiler->decompile(tx->getCode(), sourceCode)) {
						sourceCode = "invalid byte-code present";
					}
					else
					{
						tx->setSourceCode(sourceCode);
					}
				}
				// Transaction Source Rewrite System - END
			}
			// Capture bytecode version after decompilation
			bytecodeVersion = compiler->getBytecodeVersion();
			parsingResult = parseSendCommand(sourceCode, blockKeyHeight);
			if (parsingResult && parsingResult->isSuccess())
			{
				txValue = parsingResult->getAmount();
				recipient = parsingResult->getRecipient();
			}
			// Source Code Retrieval - END
		}
		// Operational Logic - END
		// return data
		auto txDesc = std::make_shared<CTransactionDesc>(
			static_cast<uint64_t>(receiptA ? receiptA->getResult() : 100),// 100 = Scheduled
			txValue, // already an absolute value
			mTools->bytesToString(getTransactionAddress(tx)),
			recipient,
			receiptA ? receiptA->getERGUsed() : 0,
			receiptA ? receiptA->getERGPrice() : 0,
			mTools->base58CheckEncode(mTools->getReceiptIDForTransaction(mMode, tx->getHash())),
			receiptA ? receiptA->getSacrificedValue() : 0,
			sourceCode,
			tx->getErgLimit(),
			tx->getNonce(),
			confirmedTimestamp,
			tx->getTime(),
			eTxType::transfer,
			static_cast<BigInt>((static_cast<BigFloat>(txValue) * CGlobalSecSettings::getMiningTax())),
			receiptA ? receiptA->getLog() : std::vector<std::string>(),
			blockHeight,
			blockKeyHeight,
			parsingResult ? parsingResult->isSuccess() : false,
			mTools->stringToBytes(mTools->base58CheckEncode(blockID)),
			tx->getMainRAWDataSize()
		);
		// Set bytecode version if source code was decompiled
		if (includeDetails) {
			txDesc->setBytecodeVersion(bytecodeVersion);
		}
		return CSearchResults::ResultData(txDesc);
	}
	catch (const std::exception& e) {
		const_cast<std::string&>(errorMessage) = e.what();
		return nullptr;
	}
	catch (...) {
		const_cast<std::string&>(errorMessage) = "Unknown error occurred while creating transaction description";
		return nullptr;
	}
}

std::vector<uint8_t> CBlockchainManager::getTransactionAddress(std::shared_ptr<CTransaction> trans, bool requireVerification) {
	std::vector<uint8_t> address;
	std::vector<uint8_t> pubKey;

	// Check if public key is included and matches the issuer
	if (trans->getPubKey().size() != 0 && trans->getIssuer().size() != 0) {
		mCryptoFactory->genAddress(trans->getPubKey(), address);
		if (std::memcmp(address.data(), trans->getIssuer().data(), address.size()) != 0) {
			// Public key doesn't match issuer
			return std::vector<uint8_t>();
		}
		return address;
	}

	// Check for an explicit public key
	if (trans->getPubKey().size() == 32) {
		pubKey = trans->getPubKey();
	}
	else {
		// Check for a StateDomain ID
		if (trans->getIssuer().size() > 0) {
			CStateDomain* issuerSD;
			if (requireVerification) {
				std::shared_ptr<CStateDomainManager> sdm = getStateDomainManager();

				if (!sdm)
				{
					return std::vector<uint8_t>();
				}
				issuerSD = sdm->findByID(trans->getIssuer());
				if (issuerSD == nullptr) {
					// Unknown issuer
					return std::vector<uint8_t>();
				}
			}

			std::shared_ptr<CIdentityToken> ID;
			if (issuerSD != nullptr) {
				ID = issuerSD->getIDToken();
			}

			if (ID == nullptr) {
				// No IDToken
				return std::vector<uint8_t>();
			}
			else if (ID->getPubKey().size() != 32) {
				// Invalid public key in IDToken
				return std::vector<uint8_t>();
			}
			else {
				// Valid public key is present
				pubKey = ID->getPubKey();
			}
		}
		else {
			// Unknown issuer (issuer is empty)
			return std::vector<uint8_t>();
		}
	}

	// Finally, do we have a valid public key?
	if (pubKey.size() != 32) {
		// No valid public key
		return std::vector<uint8_t>();
	}

	// Generate and return the address
	mCryptoFactory->genAddress(pubKey, address);
	return address;
}
// Flat 

std::shared_ptr<CBlock> CBlockchainManager::getDeepestBlockInCache() const
{
	std::lock_guard<std::mutex> lock(mFieldsGuardian);

	return mDeepestBlockInCache.lock();
}

void CBlockchainManager::setDeepestBlockInCache(std::shared_ptr<CBlock> block)
{
	std::lock_guard<std::mutex> lock(mFieldsGuardian);

	mDeepestBlockInCache = block;
}



// Recent Transactions Mechanics - BEGIN
/**
 * \file CBlockchainManager.cpp
 * \brief Implementation of the CBlockchainManager class methods.
 *
 * This file contains the implementation of methods for managing the blockchain,
 * including caching mechanisms for recent transactions and transaction counts.
 */

 // Recent Transactions Methods - BEGIN


/**
 * @brief Retrieves transaction information by receipt ID.
 *
 * This method allows fast retrieval of transaction metadata using the receipt ID.
 * It uses the `mRecentTransactionsByReceiptID` hash map for O(1) look-ups.
 * Thread safety is ensured using a shared lock since this is a read-only operation.
 *
 * @param receiptID The receipt ID of the transaction.
 * @return A shared pointer to `CRecentTXInfo` if found, or `nullptr` if not found.
 */
std::shared_ptr<CTXInfo> CBlockchainManager::getTransactionInfoByReceiptID(const std::vector<uint8_t>& receiptID) {
	std::shared_lock<std::shared_mutex> lock(mRecentTransactionsGuardian);

	auto it = mRecentTransactionsByReceiptID.find(receiptID);
	if (it != mRecentTransactionsByReceiptID.end()) {
		return it->second;
	}
	else {
		return nullptr;
	}
}


void CBlockchainManager::updateTransactionCache(const std::shared_ptr<CTXInfo>& txInfo, bool unsafe) {
	// Pre-flight - BEGIN
	if (!txInfo || !txInfo->getTransaction()) {
		mTools->logEvent("Attempt to add null transaction info to recent transactions cache",
			"CBlockchainManager",
			eLogEntryCategory::debug,
			5,
			eLogEntryType::failure,
			eColor::cyborgBlood);
		return;
	}
	// Pre-flight - END

	// Operational Logic - BEGIN
	auto updateCache = [&]() {
		const std::vector<uint8_t>& txHash = txInfo->getTransaction()->getHash();
		std::vector<uint8_t> receiptID = mTools->getReceiptIDForTransaction(eBlockchainMode::TestNet, txHash);
		uint64_t txTime = txInfo->getTransaction()->getTime();

		bool exists = false;
		std::shared_ptr<CTXInfo> existingInfo;

		// First check existence with shared lock
		if (!unsafe) {
			std::shared_lock readLock(mRecentTransactionsGuardian);
			auto mapIt = mRecentTransactionsMap.find(txHash);
			if (mapIt != mRecentTransactionsMap.end()) {
				exists = true;
				existingInfo = mapIt->second;
			}
		}
		else {
			auto mapIt = mRecentTransactionsMap.find(txHash);
			if (mapIt != mRecentTransactionsMap.end()) {
				exists = true;
				existingInfo = mapIt->second;
			}
		}

		if (exists) {
			// Update existing entry
			existingInfo->setTransaction(txInfo->getTransaction());
			existingInfo->setReceipt(txInfo->getReceipt());
			existingInfo->setDescription(txInfo->getDescription());

			// Need unique lock for modifying collections
			if (!unsafe) {
				std::unique_lock writeLock(mRecentTransactionsGuardian);

				std::vector<uint8_t> oldReceiptID = mTools->getReceiptIDForTransaction(
					eBlockchainMode::TestNet, existingInfo->getTransaction()->getHash());
				if (receiptID != oldReceiptID) {
					mRecentTransactionsByReceiptID.erase(oldReceiptID);
					mRecentTransactionsByReceiptID[receiptID] = existingInfo;
				}

				// Remove and reinsert to maintain time order
				auto dequeIt = std::find(mRecentTransactions.begin(), mRecentTransactions.end(), existingInfo);
				if (dequeIt != mRecentTransactions.end()) {
					mRecentTransactions.erase(dequeIt);

					// Use binary search to find correct insert position
					auto insertPos = std::lower_bound(
						mRecentTransactions.begin(),
						mRecentTransactions.end(),
						txTime,
						[](const std::shared_ptr<CTXInfo>& info, uint64_t time) {
							return info->getTransaction()->getTime() > time;
						}
					);

					mRecentTransactions.insert(insertPos, existingInfo);
				}
			}
			else {
				// For unsafe mode, perform updates without locks
				auto dequeIt = std::find(mRecentTransactions.begin(), mRecentTransactions.end(), existingInfo);
				if (dequeIt != mRecentTransactions.end()) {
					mRecentTransactions.erase(dequeIt);
					auto insertPos = std::lower_bound(
						mRecentTransactions.begin(),
						mRecentTransactions.end(),
						txTime,
						[](const std::shared_ptr<CTXInfo>& info, uint64_t time) {
							return info->getTransaction()->getTime() > time;
						}
					);
					mRecentTransactions.insert(insertPos, existingInfo);
				}
			}

			mTools->logEvent("Updated existing transaction in recent transactions cache",
				"CBlockchainManager",
				eLogEntryCategory::localSystem,
				0,
				eLogEntryType::notification,
				eColor::lightGreen);
		}
		else {


			// Add new entry - needs unique lock for the entire operation if not unsafe
			if (!unsafe) {
				std::unique_lock writeLock(mRecentTransactionsGuardian);

				// Use binary search to find correct insert position
				auto insertPos = std::lower_bound(
					mRecentTransactions.begin(),
					mRecentTransactions.end(),
					txTime,
					[](const std::shared_ptr<CTXInfo>& info, uint64_t time) {
						return info->getTransaction()->getTime() < time;  // Changed to 
					}
				);

				mRecentTransactions.insert(insertPos, txInfo);
				mRecentTransactionsMap[txHash] = txInfo;
				mRecentTransactionsByReceiptID[receiptID] = txInfo;

				if (mRecentTransactions.size() > mMaxRecentTransactions) {
					auto oldestInfo = mRecentTransactions.back();
					mRecentTransactions.pop_back();

					const std::vector<uint8_t>& oldestTxHash = oldestInfo->getTransaction()->getHash();
					mRecentTransactionsMap.erase(oldestTxHash);

					std::vector<uint8_t> oldestReceiptID = mTools->getReceiptIDForTransaction(
						eBlockchainMode::TestNet, oldestTxHash);
					mRecentTransactionsByReceiptID.erase(oldestReceiptID);

					mTools->logEvent("Removed oldest transaction from recent transactions cache due to size limit",
						"CBlockchainManager",
						eLogEntryCategory::localSystem,
						0,
						eLogEntryType::notification,
						eColor::orange);
				}
			}
			else {
				// Unsafe mode - no locks
				auto insertPos = std::lower_bound(
					mRecentTransactions.begin(),
					mRecentTransactions.end(),
					txTime,
					[](const std::shared_ptr<CTXInfo>& info, uint64_t time) {
						return info->getTransaction()->getTime() < time;  // Changed to 
					}
				);

				mRecentTransactions.insert(insertPos, txInfo);
				mRecentTransactionsMap[txHash] = txInfo;
				mRecentTransactionsByReceiptID[receiptID] = txInfo;
			}

			mTools->logEvent("Added new transaction to recent transactions cache",
				"CBlockchainManager",
				eLogEntryCategory::localSystem,
				0,
				eLogEntryType::notification,
				eColor::lightGreen);
		}
		};

	updateCache();

	// Sanity checks - BEGIN
	// Perform sanity checks with shared lock when needed
	if (!unsafe) {
		std::shared_lock readLock(mRecentTransactionsGuardian);
		performTransactionsCacheSanityChecks();
	}
	else {
		performTransactionsCacheSanityChecks();
	}
	// Sanity checks - END
	// Operational Logic - END
}
void CBlockchainManager::performTransactionsCacheSanityChecks()
{
	if (mRecentTransactions.empty()) {
		mTools->logEvent("Recent transactions cache is unexpectedly empty after addition",
			"CBlockchainManager",
			eLogEntryCategory::localSystem,
			5,
			eLogEntryType::warning,
			eColor::cyborgBlood);
	}

	if (mRecentTransactions.size() > mMaxRecentTransactions) {
		mTools->logEvent("Recent transactions cache size exceeds maximum allowed",
			"CBlockchainManager",
			eLogEntryCategory::localSystem,
			5,
			eLogEntryType::warning,
			eColor::cyborgBlood);
	}

	if (mRecentTransactions.size() != mRecentTransactionsMap.size() ||
		mRecentTransactions.size() != mRecentTransactionsByReceiptID.size()) {
		mTools->logEvent("Mismatch between recent transactions deque and maps sizes",
			"CBlockchainManager",
			eLogEntryCategory::localSystem,
			5,
			eLogEntryType::warning,
			eColor::cyborgBlood);
	}
}

void CBlockchainManager::addTransactionToCache(
	const std::shared_ptr<CTransaction>& transaction,
	const std::shared_ptr<CReceipt>& receipt,
	const std::shared_ptr<CBlock>& block,
	bool genMetaData,
	bool unsafe
) {


	assertGN(transaction && receipt);
	// Pre-flight - BEGIN
	if (!transaction) {
		mTools->logEvent("Attempt to add null transaction to recent transactions cache",
			"CBlockchainManager",
			eLogEntryCategory::debug,
			5,
			eLogEntryType::failure,
			eColor::cyborgBlood);
		return;
	}

	// Sanitize Trie Node copy - BEGIN
	// Rationale: we need to make sure trie-node does not 'think' it's part of a Trie (all its internal pointers need to be clear);
	if (transaction)
	{
		transaction->unregister(); // otherwise sanitize() would throw.
		transaction->sanitize();
	}
	if (receipt)
	{
		receipt->unregister(); // otherwise sanitize() would throw.
		receipt->sanitize();
	}
	// Sanitize Trie Node copy - END
	// Pre-flight - END

	// Local Variables - BEGIN
	std::shared_ptr<CTransactionDesc> description;
	// Local Variables - END

	// Operational Logic - BEGIN

	// Level 3 Meta Data Support - BEGIN
	if (genMetaData) {
		std::shared_ptr<CBlockHeader> header = block ? block->getHeader() : nullptr;

		auto descInv = createTransactionDescription(transaction,
			receipt,
			header ? header->getSolvedAtTime() : 0,
			true,
			header);
		if (auto ptr = std::get_if<std::shared_ptr<CTransactionDesc>>(&descInv)) {
			description = *ptr;
		}
	}
	// Level 3 Meta Data Support - END

	auto updateCache = [&]() {
		const std::vector<uint8_t>& txHash = transaction->getHash();
		std::vector<uint8_t> receiptID = mTools->getReceiptIDForTransaction(eBlockchainMode::TestNet, txHash);
		uint64_t txTime = transaction->getTime();

		auto mapIt = mRecentTransactionsMap.find(txHash);

		if (mapIt != mRecentTransactionsMap.end()) {
			// Update existing entry
			auto& existingInfo = mapIt->second;
			existingInfo->setTransaction(transaction);
			existingInfo->setReceipt(receipt);
			existingInfo->setDescription(description);

			std::vector<uint8_t> oldReceiptID = mTools->getReceiptIDForTransaction(eBlockchainMode::TestNet, existingInfo->getTransaction()->getHash());
			if (receiptID != oldReceiptID) {
				mRecentTransactionsByReceiptID.erase(oldReceiptID);
				mRecentTransactionsByReceiptID[receiptID] = existingInfo;
			}

			// Remove and reinsert to maintain time order
			auto dequeIt = std::find(mRecentTransactions.begin(), mRecentTransactions.end(), existingInfo);
			if (dequeIt != mRecentTransactions.end()) {
				mRecentTransactions.erase(dequeIt);

				// Use binary search to find correct insert position
				auto insertPos = std::lower_bound(
					mRecentTransactions.begin(),
					mRecentTransactions.end(),
					txTime,
					[](const std::shared_ptr<CTXInfo>& info, uint64_t time) {
						return info->getTransaction()->getTime() > time;
					}
				);

				mRecentTransactions.insert(insertPos, existingInfo);
			}

			mTools->logEvent("Updated existing transaction in recent transactions cache",
				"CBlockchainManager",
				eLogEntryCategory::localSystem,
				0,
				eLogEntryType::notification);
		}
		else {
			// Add new entry
			auto newInfo = std::make_shared<CTXInfo>(transaction, receipt, description);

			// Use binary search to find correct insert position
			auto insertPos = std::lower_bound(
				mRecentTransactions.begin(),
				mRecentTransactions.end(),
				txTime,
				[](const std::shared_ptr<CTXInfo>& info, uint64_t time) {
					return info->getTransaction()->getTime() > time;
				}
			);

			mRecentTransactions.insert(insertPos, newInfo);
			mRecentTransactionsMap[txHash] = newInfo;
			mRecentTransactionsByReceiptID[receiptID] = newInfo;

			if (mRecentTransactions.size() > mMaxRecentTransactions) {
				auto oldestInfo = mRecentTransactions.back();
				mRecentTransactions.pop_back();

				const std::vector<uint8_t>& oldestTxHash = oldestInfo->getTransaction()->getHash();
				mRecentTransactionsMap.erase(oldestTxHash);

				std::vector<uint8_t> oldestReceiptID = mTools->getReceiptIDForTransaction(eBlockchainMode::TestNet, oldestTxHash);
				mRecentTransactionsByReceiptID.erase(oldestReceiptID);

				mTools->logEvent("Removed oldest transaction from recent transactions cache due to size limit",
					"CBlockchainManager",
					eLogEntryCategory::localSystem,
					0,
					eLogEntryType::notification);
			}

			mTools->logEvent("Added new transaction to recent transactions cache",
				"CBlockchainManager",
				eLogEntryCategory::localSystem,
				0,
				eLogEntryType::notification,
				eColor::lightGreen);
		}
		};

	// Lock mutex only if not unsafe
	if (!unsafe) {
		std::unique_lock<std::shared_mutex> lock(mRecentTransactionsGuardian);
		updateCache();
	}
	else {
		updateCache();
	}
	// Operational Logic - END

	// Sanity checks - BEGIN
	// Perform sanity checks regardless of unsafe flag
	if (mRecentTransactions.empty()) {
		mTools->logEvent("Recent transactions cache is unexpectedly empty after addition",
			"CBlockchainManager",
			eLogEntryCategory::localSystem,
			5,
			eLogEntryType::warning,
			eColor::cyborgBlood);
	}

	if (mRecentTransactions.size() > mMaxRecentTransactions) {
		mTools->logEvent("Recent transactions cache size exceeds maximum allowed",
			"CBlockchainManager",
			eLogEntryCategory::localSystem,
			5,
			eLogEntryType::warning,
			eColor::cyborgBlood);
	}

	if (mRecentTransactions.size() != mRecentTransactionsMap.size() ||
		mRecentTransactions.size() != mRecentTransactionsByReceiptID.size()) {
		mTools->logEvent("Mismatch between recent transactions deque and maps sizes",
			"CBlockchainManager",
			eLogEntryCategory::localSystem,
			5,
			eLogEntryType::warning,
			eColor::cyborgBlood);
	}
	// Sanity checks - END
}
uint64_t CBlockchainManager::getTotalRecentTransactionsCount() {
	std::shared_lock<std::shared_mutex> lock(mRecentTransactionsGuardian);
	return mRecentTransactions.size();
}

/**
 * @brief Retrieves a range of recent transaction information, always from latest to oldest.
 *
 * @param startIndex The starting index for retrieval (0 is the most recent transaction)
 * @param count The maximum number of transactions to retrieve
 * @param isDepth Deprecated parameter, maintained for backward compatibility
 * @return std::vector<std::shared_ptr<CTXInfo>> A vector of transaction information pointers
 */
 /**
  * @brief Retrieves a range of recent transaction information.
  *
  * @param startIndex The starting index for retrieval. In forward mode, 0 is the oldest transaction.
  *                   In reverse mode, 0 is the most recent transaction.
  * @param count The maximum number of transactions to retrieve.
  * @param isForward If true, retrieves transactions from oldest to newest (default).
  *                  If false, retrieves transactions from newest to oldest.
  * @return std::vector<std::shared_ptr<CTXInfo>> A vector of transaction information pointers.
  */
  /**
   * @brief Retrieves a range of recent transaction information, always from latest to oldest.
   *
   * @param startIndex The starting index for retrieval (0 is the most recent transaction)
   * @param count The maximum number of transactions to retrieve
   * @param isDepth Deprecated parameter, maintained for backward compatibility
   * @return std::vector<std::shared_ptr<CTXInfo>> A vector of transaction information pointers
   */
std::vector<std::shared_ptr<CTXInfo>> CBlockchainManager::getRecentTransactionsInfo(
	uint64_t startIndex,
	uint64_t count
) {
	std::vector<std::shared_ptr<CTXInfo>> result;
	std::shared_lock<std::shared_mutex> lock(mRecentTransactionsGuardian);

	uint64_t totalTransactions = mRecentTransactions.size();
	if (totalTransactions == 0) return result;

	startIndex = min(startIndex, totalTransactions - 1);
	count = min(count, totalTransactions - startIndex);
	result.reserve(count);

	auto rStartIt = mRecentTransactions.rbegin() + startIndex;
	auto rEndIt = rStartIt + count;
	result.assign(rStartIt, rEndIt);

	return result;
}

std::vector<std::shared_ptr<CTXInfo>> CBlockchainManager::getRecentTransactionsInfoPage(uint64_t page, uint64_t size) {
	std::vector<std::shared_ptr<CTXInfo>> result;

	std::shared_lock<std::shared_mutex> lock(mRecentTransactionsGuardian);

	uint64_t totalTransactions = mRecentTransactions.size();
	uint64_t startIndex = page * size;
	uint64_t endIndex = min(startIndex + size, totalTransactions);

	if (startIndex >= totalTransactions) {
		return result; // Return empty vector if page is out of range
	}

	result.reserve(endIndex - startIndex);

	// Copy the relevant range of transactions into the result vector
	auto startIt = mRecentTransactions.begin() + startIndex;
	auto endIt = mRecentTransactions.begin() + endIndex;

	result.assign(startIt, endIt);

	return result;
}

/**
 * @brief Sets the maximum number of recent transactions to keep.
 *
 * This method updates the maximum size of the recent transactions cache.
 * If the new maximum size is smaller than the current cache size, it
 * removes the oldest transactions from the deque and the associated maps.
 *
 * @param max The maximum number of recent transactions to keep.
 */
void CBlockchainManager::setMaxRecentTransactions(uint64_t max) {
	std::unique_lock<std::shared_mutex> lock(mRecentTransactionsGuardian);
	mMaxRecentTransactions = max;

	// Remove oldest transactions if the current size exceeds the new maximum
	while (mRecentTransactions.size() > mMaxRecentTransactions) {
		// Remove from deque and maps
		auto oldestInfo = mRecentTransactions.back();
		mRecentTransactions.pop_back();

		const std::vector<uint8_t>& oldestTxHash = oldestInfo->getTransaction()->getHash();
		mRecentTransactionsMap.erase(oldestTxHash);

		std::vector<uint8_t> oldestReceiptID = mTools->getReceiptIDForTransaction(eBlockchainMode::TestNet, oldestTxHash);
		mRecentTransactionsByReceiptID.erase(oldestReceiptID);
	}
}

/**
 * @brief Clears the recent transactions cache.
 *
 * This method removes all entries from the recent transactions deque and
 * clears the associated hash maps used for quick look-ups.
 */
void CBlockchainManager::clearRecentTXCache() {
	std::unique_lock<std::shared_mutex> lock(mRecentTransactionsGuardian);
	mRecentTransactions.clear();
	mRecentTransactionsMap.clear();
	mRecentTransactionsByReceiptID.clear();
}


// Recent Transactions Methods - END


/**
 * @brief Gets the transaction count for a specific date.
 *
 * This method counts the number of transactions that occurred on the specified date only.
 * It utilizes a cache to store transaction counts for specific dates to improve performance
 * on subsequent calls. An additional caching layer is introduced, which stores the total
 * number of transactions on a particular day in a cache if the date is at least
 * `cacheDelayDays` days behind the current date.
 *
 * The count includes all transactions that occurred from the start (00:00:00)
 * to the end (23:59:59) of the specified date.
 *
 * @param date The date in UNIX timestamp format (seconds since epoch).
 * @param numThreads The number of threads to use for processing.
 * @param threadPool An optional shared pointer to a thread pool.
 * @param cacheDelayDays The number of days behind the current date when caching begins.
 * @param useCache A boolean indicating whether the cache can be used when returning data.
 * @return The total number of transactions that occurred on the specified date.
 */
uint64_t CBlockchainManager::getTransactionCountOnDate(
	uint64_t date,
	size_t numThreads,
	std::shared_ptr<ThreadPool> threadPool,
	uint64_t cacheDelayDays,
	bool useCache
) {
	// Local Variables - BEGIN
	uint64_t currentTime = std::time(nullptr);
	uint64_t startDate = date - (date % (24 * 60 * 60)); // Round down to start of day
	uint64_t endDate = startDate + 86399;                // Set to end of the same day (23:59:59)
	uint64_t currentHeight = getHeight();
	uint64_t maxPrunedBlocks = getMaxNrOfPrunedBlocksToKeepInMemory();
	std::atomic<uint64_t> transactionCount(0);
	std::vector<std::exception_ptr> exceptions;
	std::mutex exceptionMutex;
	bool ownThreadPool = false;
	uint64_t cacheDelaySeconds = cacheDelayDays * 24 * 60 * 60;
	// Local Variables - END

	// Pre-Flight - BEGIN
	if (startDate > currentTime) {
		return 0; // Future date, no transactions yet
	}

	if (maxPrunedBlocks == 0 || currentHeight == 0) {
		return 0; // No blocks to check
	}

	// Ensure numThreads is at least 1
	if (numThreads == 0) {
		numThreads = 1;
	}

	uint64_t timeDifference = currentTime - startDate;
	// Pre-Flight - END

	// Cache Check - BEGIN
	if (useCache) {
		std::shared_lock<std::shared_mutex> lock(mDailyStatsCacheMutex);
		auto cacheEntry = std::find_if(mTransactionCountCache.begin(), mTransactionCountCache.end(),
			[startDate](const TransactionCountCache& entry) {
				return entry.startDate == startDate &&
					entry.endDate == (startDate + 86399);
			});

		if (cacheEntry != mTransactionCountCache.end()) {
			mTools->logEvent("Returning cached transaction count for date: " +
				mTools->timeToString(startDate),
				"Transaction Count Cache");
			return cacheEntry->count;
		}
	}
	// Cache Check - END

	// Initialize thread pool if needed
	if (numThreads > 1 && !threadPool) {
		threadPool = std::make_shared<ThreadPool>(numThreads, numThreads, numThreads);
		ownThreadPool = true;
	}

	// Determine the range of blocks to process
	uint64_t totalBlocks = min(maxPrunedBlocks, currentHeight);
	uint64_t startBlock = currentHeight - totalBlocks + 1;
	uint64_t endBlock = currentHeight;

	// Multi-threaded processing - BEGIN
	if (numThreads > 1) {
		// Adjust numThreads if totalBlocks is less than numThreads
		if (totalBlocks < numThreads) {
			numThreads = static_cast<size_t>(totalBlocks);
		}

		// Divide blocks among threads
		uint64_t blocksPerThread = totalBlocks / numThreads;
		uint64_t remainingBlocks = totalBlocks % numThreads;

		std::vector<std::future<void>> futures;

		for (size_t i = 0; i < numThreads; ++i) {
			uint64_t threadStartBlock = startBlock + i * blocksPerThread + std::min<uint64_t>(i, remainingBlocks);
			uint64_t threadEndBlock = threadStartBlock + blocksPerThread - 1;
			if (i < remainingBlocks) {
				threadEndBlock += 1;
			}

			futures.push_back(threadPool->enqueue([&, threadStartBlock, threadEndBlock]() {
				try {
					for (uint64_t blockHeight = threadStartBlock; blockHeight <= threadEndBlock; ++blockHeight) {
						std::shared_ptr<CBlock> block = getBlockAtHeight(blockHeight,
							false, // non key-depth
							eChainProof::verifiedCached);

						if (!block) {
							continue;
						}

						std::shared_ptr<CBlockDesc> desc = block->getDescription();
						if (!desc) {
							continue;
						}

						uint64_t blockTime = desc->getSolvedAt();

						if (blockTime > endDate || blockTime < startDate) {
							continue;
						}

						transactionCount.fetch_add(desc->getTransactionsCount(), std::memory_order_relaxed);
					}
				}
				catch (...) {
					std::lock_guard<std::mutex> lock(exceptionMutex);
					exceptions.push_back(std::current_exception());
				}
				}));
		}

		// Wait for all tasks to complete
		for (auto& future : futures) {
			future.get();
		}

		// Handle exceptions from threads
		if (!exceptions.empty()) {
			// Log the first exception
			try {
				std::rethrow_exception(exceptions.front());
			}
			catch (const std::exception& e) {
				mTools->logEvent("Error in parallel transaction counting: " + std::string(e.what()),
					"Transaction Count",
					eLogEntryCategory::localSystem,
					5,
					eLogEntryType::failure);
			}

			// Clean up if we created our own thread pool
			if (ownThreadPool) {
				threadPool->waitAll();
			}
			throw;  // Re-throw the exception after cleanup
		}

		// Clean up if we created our own thread pool
		if (ownThreadPool) {
			threadPool->waitAll();
		}
	}
	// Multi-threaded processing - END
	else {
		// Single-threaded processing - BEGIN
		for (uint64_t blockHeight = startBlock; blockHeight <= endBlock; ++blockHeight) {
			std::shared_ptr<CBlock> block = getBlockAtHeight(blockHeight,
				false, // non key-depth
				eChainProof::verifiedCached);

			if (!block) {
				continue;
			}

			std::shared_ptr<CBlockDesc> desc = block->getDescription();
			if (!desc) {
				continue;
			}

			uint64_t blockTime = desc->getSolvedAt();

			if (blockTime > endDate || blockTime < startDate) {
				continue;
			}

			transactionCount.fetch_add(desc->getTransactionsCount(), std::memory_order_relaxed);
		}
		// Single-threaded processing - END
	}

	mTools->logEvent("Counted " + std::to_string(transactionCount.load()) + " transactions for date: " +
		mTools->timeToString(startDate),
		"Transaction Count",
		eLogEntryCategory::localSystem, 2, eLogEntryType::notification);

	// Cache Update - BEGIN
	if (timeDifference >= cacheDelaySeconds) {
		std::unique_lock<std::shared_mutex> lock(mDailyStatsCacheMutex);
		auto cacheEntry = std::find_if(mTransactionCountCache.begin(), mTransactionCountCache.end(),
			[startDate](const TransactionCountCache& entry) {
				return entry.startDate == startDate &&
					entry.endDate == (startDate + 86399);
			});

		if (cacheEntry != mTransactionCountCache.end()) {
			cacheEntry->count = transactionCount.load();
			cacheEntry->lastUpdated = currentTime;
		}
		else {
			mTransactionCountCache.push_back({ startDate, endDate, transactionCount.load(), currentTime });
		}

		// Cache cleanup: Remove entries older than 14 days
		/*uint64_t fourteenDaysAgo = currentTime - (14 * 24 * 60 * 60);
		mTransactionCountCache.erase(
			std::remove_if(mTransactionCountCache.begin(), mTransactionCountCache.end(),
				[fourteenDaysAgo](const TransactionCountCache& entry) {
					return entry.startDate < fourteenDaysAgo;
				}),
			mTransactionCountCache.end());*/
	}
	// Cache Update - END

	return transactionCount.load();
}

uint64_t CBlockchainManager::getTransactionCountSinceDate(uint64_t startDate) {
	// Local Variables - BEGIN
	uint64_t currentTime = std::time(nullptr);
	startDate = startDate - (startDate % (24 * 60 * 60)); // Round down to start of day
	uint64_t endDate = currentTime - (currentTime % (24 * 60 * 60)) + 86399; // Round up to end of current day
	uint64_t transactionCount = 0;
	uint64_t currentHeight = getHeight();
	uint64_t maxPrunedBlocks = getMaxNrOfPrunedBlocksToKeepInMemory();
	uint64_t blocksChecked = 0;
	// Local Variables - END

	// Pre-Flight - BEGIN

	if (startDate > currentTime) {
		return 0; // Future date, no transactions yet
	}

	if (maxPrunedBlocks == 0 || currentHeight == 0) {
		return 0; // No blocks to check
	}
	// Pre-Flight - END

	// Check a Dedicated Time-Period-TX-Count Cache - BEGIN
	// Rationale: there may have been prior requests regarding same time-range.
	//	         In such a case, the count is expected to be pre-computed within of the cache.
	//		    Entries are rounded daily, thurs retrieval of cached respones is feasible.
	{
		std::shared_lock<std::shared_mutex> lock(mDailyStatsCacheMutex);
		auto cacheEntry = std::find_if(mTransactionCountCache.begin(), mTransactionCountCache.end(),
			[startDate, endDate](const TransactionCountCache& entry) {
				return entry.startDate == startDate && entry.endDate >= endDate;
			});

		if (cacheEntry != mTransactionCountCache.end()) {
			if (currentTime - cacheEntry->lastUpdated < CACHE_DURATION) {
				mTools->logEvent("Returning cached transaction count from date: " +
					std::to_string(startDate) + " to current time",
					"Transaction Count Cache");
				return cacheEntry->count;
			}
		}
	}
	// Check a Dedicated Time-Period-TX-Count Cache - END

	// Operational Logic - BEGIN
	mTools->logEvent("Counting transactions from date: " +
		mTools->timeToString(startDate) + " to current time",
		"Transaction Count");

	// Traverse the blockchain Block meta-data cache using block descriptions
	while (blocksChecked < maxPrunedBlocks && blocksChecked < currentHeight) {
		std::shared_ptr<CBlock> block = getBlockAtDepth(currentHeight - blocksChecked,
			false, // non key-depth
			eChainProof::verifiedCached);

		if (!block) {
			blocksChecked++;
			continue;
		}

		// Get block metadata
		std::shared_ptr<CBlockDesc> desc = block->getDescription();
		if (!desc) {
			blocksChecked++;
			continue;
		}

		// Access all data through BlockDesc
		uint64_t blockTime = desc->getSolvedAt();
		if (blockTime < startDate) {
			break; // We've gone past the start date we're interested in
		}

		// Use metadata for transaction count
		transactionCount += desc->getTransactionsCount();
		blocksChecked++;
	}

	mTools->logEvent("Counted " + std::to_string(transactionCount) + " transactions from " +
		std::to_string(blocksChecked) + " blocks from date: " +
		std::to_string(startDate) + " to current time",
		eLogEntryCategory::localSystem, 5, eLogEntryType::notification, eColor::lightGreen);
	// Operational Logic - END

	// Cache Update - BEGIN
	{
		std::unique_lock<std::shared_mutex> lock(mDailyStatsCacheMutex);
		auto cacheEntry = std::find_if(mTransactionCountCache.begin(), mTransactionCountCache.end(),
			[startDate](const TransactionCountCache& entry) {
				return entry.startDate == startDate;
			});

		if (cacheEntry != mTransactionCountCache.end()) {
			// Update existing cache entry
			cacheEntry->count = transactionCount;
			cacheEntry->lastUpdated = currentTime;
			cacheEntry->endDate = endDate;
		}
		else {
			// Add new cache entry
			mTransactionCountCache.push_back({ startDate, endDate, transactionCount, currentTime });
		}

		// Cache cleanup: Remove entries older than 14 days
		uint64_t fourteenDaysAgo = currentTime - (14 * 24 * 60 * 60);
		mTransactionCountCache.erase(
			std::remove_if(mTransactionCountCache.begin(), mTransactionCountCache.end(),
				[fourteenDaysAgo](const TransactionCountCache& entry) {
					return entry.startDate < fourteenDaysAgo;
				}),
			mTransactionCountCache.end());
	}
	// Cache Update - END

	return transactionCount;
}


// Recent Transactions Counts - Cache

// Recent Transactions Mechanics - END

/// <summary>
/// Looks for a block within the current mainChain.
/// WARNING: the pointer might become invalid pretty quick.
/// </summary>p
/// <param name=""></param>
/// <returns></returns>
std::shared_ptr<CBlock> CBlockchainManager::findBlockInCache(std::vector<uint8_t> id)
{
	if (id.size() != 32)
		return nullptr;
	std::shared_ptr<CTools> tools = getTools();
	std::lock_guard<ExclusiveWorkerMutex> lock(mChainGuardian);
	mLeaderGuardian.lock();
	std::shared_ptr<CBlock> current = mLeader;
	mLeaderGuardian.unlock();
	uint64_t travered = 0;
	while (current != nullptr)
	{
		if (current->getHotStorageID().size() == 32)
		{
			if (tools->compareByteVectors(current->getHotStorageID(), id))
				return current;
		}
		current = current->getParentPtr();
		travered++;
	}
	return nullptr;
}

size_t CBlockchainManager::getMaxNrOfPrunedBlocksToKeepInMemory()
{
	std::lock_guard<std::mutex> lock(mFieldsGuardian);
	return mMaxNrOfPrunedBlocksToKeepInMemory;
}

size_t CBlockchainManager::getMaxNrOfFullBlocksToKeepInMemory()
{
	std::lock_guard<std::mutex> lock(mFieldsGuardian);
	return mMaxNrOfFullBlocksToKeepInMemory;

}
size_t CBlockchainManager::getMaxOverallBlocksToKeepInMemory()
{
	std::lock_guard<std::mutex> lock(mFieldsGuardian);
	return mMaxNrOfOverallBlocksToKeepInMemory;

}
void  CBlockchainManager::setMaxNrOfPrunedBlocksToKeepInMemory(size_t count)
{
	std::lock_guard<std::mutex> lock(mFieldsGuardian);
	mMaxNrOfPrunedBlocksToKeepInMemory = count;
}


void CBlockchainManager::cleanCache()
{
	if (!getIsReady())
	{
		return;
	}
	pingLastTimeBlockCacheCleaned();
	// Preliminaries - BEGIN
	std::lock_guard<ExclusiveWorkerMutex> lock(mChainGuardian);
	getTools()->writeLine("Cleaning up the blockchain Mem-Cache");


	// Safely acquire the leader block
	std::shared_ptr<CBlock> leader = nullptr;
	{
		std::lock_guard<std::recursive_mutex> leaderLock(mLeaderGuardian);
		leader = mLeader;
	}
	// Preliminaries - END

	// Local Variables - BEGIN
	std::shared_ptr<CBlock> currentBlock = leader;
	std::shared_ptr<CBlock> nextParent = nullptr;
	std::shared_ptr<CBlock> previousBlock = nullptr;

	size_t totalBlocksProcessed = 0;
	size_t fullBlocks = 0;
	size_t prunedBlocks = 0;
	size_t freed = 0;
	size_t scheduledToBeFreed = 0;
	bool cut = false;
	std::shared_ptr<CBlock> lastBlock;
	bool eliminationActivated = false;
	uint64_t maxPrunedBlocks = getMaxNrOfPrunedBlocksToKeepInMemory();
	uint64_t maxFullBlocks = getMaxNrOfFullBlocksToKeepInMemory();
	uint64_t maxOverallBlockCacheLength = getMaxOverallBlocksToKeepInMemory();
	// Local Variables - END

	// Operational Logic - BEGIN

	// Edge case: Ensure maxOverallBlockCacheLength is not less than maxUnprunedBlocks + maxPrunedBlocks
	maxOverallBlockCacheLength = max(maxOverallBlockCacheLength, maxFullBlocks + maxPrunedBlocks);

	while (currentBlock != nullptr && totalBlocksProcessed < maxOverallBlockCacheLength)
	{
		nextParent = currentBlock->getHeader()->getParentPtrK();
		assertGN(nextParent != currentBlock);

		if (fullBlocks <= maxFullBlocks)
		{
			// Full-Block - BEGIN

			// Keep block unpruned
			if (!currentBlock->getHeader()->areTriesLoaded())
			{
				currentBlock->getHeader()->loadTries();
			}
			fullBlocks++;
			// Full-Block - END
		}
		else if (prunedBlocks <= maxPrunedBlocks)
		{
			// Pruned Blocks (MPTs Unwinding) - BEGIN

			// Prune block if it's not already pruned
			if (currentBlock->getHeader()->areTriesLoaded())
			{
				currentBlock->getHeader()->freeTries();
				prunedBlocks++;
			}
			else
			{
				// Block was already pruned, just count it
				prunedBlocks++;
			}
			// Pruned Blocks (MPTs Unwinding) - BEGIN

		}
		else
		{	// all limits exceeded
			if (!eliminationActivated)
			{
				eliminationActivated = true;
				lastBlock = currentBlock;
			}
			// Elimination - BEGIN

			// We've exceeded both pruned and unpruned limits
			if (previousBlock != nullptr && !cut)
			{
				// Cut the chain here
				previousBlock->getHeader()->setParent(nullptr);
				cut = true;
			}

			// Prepare block for removal
			uint64_t useCountBefore = currentBlock.use_count();
			currentBlock->prepareForRemoval();
			uint64_t useCountAfter = currentBlock.use_count();

			if (useCountAfter == 1)
			{
				freed++;
			}
			else if (useCountAfter < useCountBefore)
			{
				scheduledToBeFreed++;
			}
			// else: block is still in use somewhere else, do nothing

			// Elimination - END
		}

		previousBlock = currentBlock;
		currentBlock = nextParent;
		totalBlocksProcessed++;
	}

	if (eliminationActivated && lastBlock)
	{
		// Notice: if complete elimination has not been activated above, there is no need so store the deepest block, since it was taken care of by the cache preparation mechanism already.
		setDeepestBlockInCache(lastBlock);
	}
	// Operational Logic - END

	// Reporting - BEGIN

	// Log cleanup results
	std::stringstream ss;
	ss << "Blocks processed: " << totalBlocksProcessed
		<< " Unpruned: " << fullBlocks
		<< " Pruned: " << prunedBlocks
		<< " Freed: " << freed
		<< " Scheduled: " << scheduledToBeFreed;

	getTools()->logEvent(ss.str(), "Cache Cleaning", eLogEntryCategory::localSystem, 1);

	// Reporting - END
}




uint64_t CBlockchainManager::getHotStorageCacheLength(bool recalculate)
{
	uint64_t result = 0;
	if (recalculate)
	{
		std::lock_guard<ExclusiveWorkerMutex> lock(mChainGuardian);

		std::shared_ptr<CBlock> leader = getLeader();
		if (leader != nullptr)
		{
			std::shared_ptr<CBlock> current = leader->getParentPtr();
			while (current != nullptr)
			{
				current = current->getHeader()->getParentPtr();
				result++;
			}
		}
	}

	return result;
}

BigInt CBlockchainManager::getCoinbaseRewardForKeyHeight(uint64_t height)
{
	return CGlobalSecSettings::getBasicMiningRewardForKeyHeight(height);
}

uint64_t CBlockchainManager::calculateRewardForUncleBlock(std::shared_ptr<CBlock> block)
{
	std::lock_guard<std::recursive_mutex> lock(mGuardian);
	uint64_t currentDepth = getLeader()->getHeader()->getHeight();
	uint64_t proposalDepth = block->getHeader()->getHeight();
	if ((currentDepth - proposalDepth) > 10)
		return 0;
	return ((double)mSettings->getCurrentMiningReward() * (double)0.2) / (double)(currentDepth - proposalDepth);
}

std::vector<std::shared_ptr<CBlock>> CBlockchainManager::getRecentUncles()
{
	std::lock_guard<std::recursive_mutex> lock(mGuardian);
	return std::vector<std::shared_ptr<CBlock>>();
}




/// <summary>
/// Never initialize a CBlockchainManager directly; instead use this factory-model function instead.
/// </summary>
/// <param name="whichOne"></param>
/// <returns></returns>
std::shared_ptr<CBlockchainManager> CBlockchainManager::getInstance(eBlockchainMode::eBlockchainMode whichOne, bool initIfNull, bool waitTillReady)
{

	std::shared_ptr<CBlockchainManager> tempPtr;
	bool wasInited = false;
	if (!(whichOne >= 0 && whichOne < 5))
		return nullptr;
	try {
		switch (whichOne)
		{
		case eBlockchainMode::eBlockchainMode::TestNet:
			sStaticPointersGuardian.lock();
			tempPtr = sTestNetInstance;
			wasInited = sTestNetInstanceInited;
			sStaticPointersGuardian.unlock();
			if (tempPtr != nullptr)
				return tempPtr;
			else {
				if (wasInited || !initIfNull)
				{
					if (waitTillReady)
					{
						do
						{
							std::this_thread::sleep_for(std::chrono::milliseconds(100));
							sStaticPointersGuardian.lock();

							tempPtr = sLocalTestsInstance;
							sStaticPointersGuardian.unlock();
						} while (tempPtr == nullptr);
						return tempPtr;
					}
					else
						return nullptr;
				}
				sTestNetInstanceInited = true;
				tempPtr = std::make_shared<CBlockchainManager>(whichOne, CGRIDNET::getWorkManager());
				if (CBlockchainManager::getIsMissionAbort())
					return nullptr;
				assertGN(tempPtr != nullptr);

				{
					std::lock_guard<std::recursive_mutex> lock(sStaticPointersGuardian);
					sTestNetInstance = tempPtr;
				}

				assertGN(sTestNetInstance != nullptr);
				if (!sTestNetInstance->postInstantiationPreparations())
				{
					assertGN(false);
					sTestNetInstance->invalidatePointer();
					return nullptr;
				}
				sTestNetInstance->setIsReady();
				return sTestNetInstance;
			}
			break;

		case eBlockchainMode::eBlockchainMode::LIVE:
			return nullptr;
			sStaticPointersGuardian.lock();
			tempPtr = sLiveInstance;
			wasInited = sLiveInstanceInited;
			sStaticPointersGuardian.unlock();
			if (tempPtr != nullptr)
				return tempPtr;
			else {
				if (wasInited || !initIfNull)
				{
					if (waitTillReady)
					{
						do
						{
							std::this_thread::sleep_for(std::chrono::milliseconds(100));
							sStaticPointersGuardian.lock();
							tempPtr = sLocalTestsInstance;
							sStaticPointersGuardian.unlock();
						} while (tempPtr == nullptr);
						return tempPtr;
					}
					else
						return nullptr;
				}
				sLiveInstanceInited = true;
				tempPtr = std::make_shared<CBlockchainManager>(whichOne, CGRIDNET::getWorkManager());
				assertGN(tempPtr != nullptr);
				std::lock_guard<std::recursive_mutex> lock(sStaticPointersGuardian);
				sLiveInstance = tempPtr;
				assertGN(sLiveInstance != nullptr);
				if (!sLiveInstance->postInstantiationPreparations())
				{
					assertGN(false);
					sLiveInstance->invalidatePointer();
					return nullptr;
				}
				sLiveInstance->setIsReady();
				return sLiveInstance;
			}
			break;

		case eBlockchainMode::eBlockchainMode::LIVESandBox:
			return nullptr;
			sStaticPointersGuardian.lock();
			tempPtr = sLIVESandBoxInstance;
			wasInited = sLIVESandBoxInstanceInited;
			sStaticPointersGuardian.unlock();
			if (tempPtr != nullptr)
				return tempPtr;
			else {
				if (wasInited || !initIfNull)
				{
					if (waitTillReady)
					{
						do
						{
							std::this_thread::sleep_for(std::chrono::milliseconds(100));
							sStaticPointersGuardian.lock();
							tempPtr = sLocalTestsInstance;
							sStaticPointersGuardian.unlock();
						} while (tempPtr == nullptr);
						return tempPtr;
					}
					else
						return nullptr;
				}
				sLIVESandBoxInstanceInited = true;
				tempPtr = std::make_shared<CBlockchainManager>(whichOne, CGRIDNET::getWorkManager());
				assertGN(tempPtr != nullptr);
				std::lock_guard<std::recursive_mutex> lock(sStaticPointersGuardian);
				sLIVESandBoxInstance = tempPtr;
				assertGN(sLIVESandBoxInstance != nullptr);
				if (!sLIVESandBoxInstance->postInstantiationPreparations())
				{
					assertGN(false);
					sLIVESandBoxInstance->invalidatePointer();
					return nullptr;
				}
				sLIVESandBoxInstance->setIsReady();
				return sLIVESandBoxInstance;
			}
			break;
		case eBlockchainMode::eBlockchainMode::TestNetSandBox:
			sStaticPointersGuardian.lock();
			tempPtr = sTestSandBoxInstance;
			wasInited = sTestSandBoxInstanceInited;
			sStaticPointersGuardian.unlock();
			if (tempPtr != nullptr)
				return tempPtr;
			else {
				if (wasInited || !initIfNull)
				{
					if (waitTillReady)
					{
						do
						{
							std::this_thread::sleep_for(std::chrono::milliseconds(100));
							sStaticPointersGuardian.lock();
							tempPtr = sLocalTestsInstance;
							sStaticPointersGuardian.unlock();
						} while (tempPtr == nullptr);
						return tempPtr;
					}
					else
						return nullptr;
				}
				sTestSandBoxInstanceInited = true;
				tempPtr = std::make_shared<CBlockchainManager>(whichOne, CGRIDNET::getWorkManager());
				assertGN(tempPtr != nullptr);
				std::lock_guard<std::recursive_mutex> lock(sStaticPointersGuardian);
				sTestSandBoxInstance = tempPtr;
				assertGN(sTestSandBoxInstance != nullptr);
				if (!sTestSandBoxInstance->postInstantiationPreparations())
				{
					assertGN(false);
					sTestSandBoxInstance->invalidatePointer();
					return nullptr;
				}
				sTestSandBoxInstance->setIsReady();
				return sTestSandBoxInstance;
			}
			break;

		case eBlockchainMode::eBlockchainMode::LocalData:
			sStaticPointersGuardian.lock();
			tempPtr = sLocalTestsInstance;
			wasInited = sLocalTestsInstanceInited;
			sStaticPointersGuardian.unlock();
			if (tempPtr != nullptr)
				return tempPtr;
			else {
				if (wasInited || !initIfNull)
				{
					if (waitTillReady)
					{
						do
						{
							std::this_thread::sleep_for(std::chrono::milliseconds(100));
							sStaticPointersGuardian.lock();
							tempPtr = sLocalTestsInstance;
							sStaticPointersGuardian.unlock();
						} while (tempPtr == nullptr);
						return tempPtr;
					}
					else
						return nullptr;
				}
				sLocalTestsInstanceInited = true;
				tempPtr = std::make_shared<CBlockchainManager>(whichOne, CGRIDNET::getWorkManager());
				assertGN(tempPtr != nullptr);
				std::lock_guard<std::recursive_mutex> lock(sStaticPointersGuardian);
				sLocalTestsInstance = tempPtr;

				assertGN(sLocalTestsInstance != nullptr);
				if (!sLocalTestsInstance->postInstantiationPreparations())
				{
					assertGN(false);
					sLocalTestsInstance->invalidatePointer();
					return nullptr;
				}
				sLocalTestsInstance->setIsReady();
				return sLocalTestsInstance;
			}
			break;
		default:
			assertGN(false);
			break;
		}

	}
	catch (std::bad_alloc ex)
	{
		CTools::writeLineS("An unhandled exception due to low memory has occurred");
		std::exit(1);
	}
	return nullptr;
}

/// <summary>
/// Retrieves KEY-BLOCK for a given key or data/reg block.
/// </summary>
/// <param name="block"></param>
std::shared_ptr<CBlock> CBlockchainManager::getKeyBlockForBlock(
	std::shared_ptr<CBlock> block,
	bool omitHardForkBlocks,
	eChainProof::eChainProof chain,
	bool allowHotStorageCache)
{

	// LOCAL VARIABLES - BEGIN
	eBlockInstantiationResult::eBlockInstantiationResult ir;
	std::string error;
	std::shared_ptr<CBlock> current = block;
	uint64_t currentKeyHeight = 0;
	// LOCAL VARIABLES - END

	if (block == nullptr || block->getHeader() == nullptr)
		return nullptr;

	// Determine the key height of the input block
	currentKeyHeight = block->getHeader()->getKeyHeight();

	if (currentKeyHeight == 0)
		return nullptr;
	// The following 'methods' are order in a declining efficiency order.

	// Method 1 - Flat Cache Check - BEGIN
	// [ Rationale]: the aim is to use the 'flat-cache' which does not require iterative pointer traversals but direct indexes to the key-blocks array instead.
	if ((chain == eChainProof::verified || chain == eChainProof::verifiedCached))
	{

		uint64_t i = current->getHeader()->isKeyBlock() ? (currentKeyHeight - 1) : currentKeyHeight;
		//  ^-- so that a parental key-block for current key-block is looked for and nearest key-block for a data block
		do
		{// Notice the requirement for hard-fork block omitting logic below
			current = getBlockFlatCache(i, false, true, chain);
			if (current != nullptr)
			{
				if (current->getHeader()->isKeyBlock() && (!(omitHardForkBlocks && current->getHeader()->getNonce() == 0)))
					return current;
			}

			if (i)
			{
				--i;
			}
		} while (current != nullptr);

		// Log or handle case where no suitable block was found
	}
	// Method 1 - Flat Cache Check - END

	// Method 2 - Hot Storage Check - BEGIN
	std::lock_guard<ExclusiveWorkerMutex> lock(mChainGuardian);
	current = block;  // revert
	currentKeyHeight = block->getHeader()->getKeyHeight();// revert
	if (allowHotStorageCache && (chain == eChainProof::verified || chain == eChainProof::verifiedCached))
	{
		do
		{// Notice the requirement for hard-fork block omitting logic below
			current = current->getParent(ir, true, false, true, shared_from_this());
			if (current != nullptr)
			{
				if (current->getHeader()->isKeyBlock() && (!(omitHardForkBlocks && current->getHeader()->getNonce() == 0)))
					return current;
			}
		} while (current != nullptr);
	}
	//  Method 2 - Hot Storage Check - END

	//  Method 3 - Cold Storage Access - BEGIN
	if (currentKeyHeight > 0) // Ensure we're not at the genesis block
	{
		current = block; // revert
		uint64_t previousKeyHeight = currentKeyHeight - 1;
		std::vector<uint8_t> previousKeyBlockID = getBlockIDAtKeyHeight(previousKeyHeight, chain);

		if (!previousKeyBlockID.empty())
		{
			current = getBlockByHash(previousKeyBlockID, ir, true);

			if (current != nullptr && current->getHeader()->isKeyBlock() &&
				(!(omitHardForkBlocks && current->getHeader()->getNonce() == 0)))
			{
				return current;
			}
		}
	}
	//  Method 3 - Cold Storage Access - END

	return nullptr;
}

std::shared_ptr<CBlock> CBlockchainManager::getLatestKeyBlock(std::vector<uint8_t> fromPerspectiveoOfBlockID)
{
	eBlockInstantiationResult::eBlockInstantiationResult bir;
	std::shared_ptr<CBlock> block = getBlockByHash(fromPerspectiveoOfBlockID, bir);
	if (!wasBlockRetrievalSuccessful(bir))
		return nullptr;
	return getLatestKeyBlock(block);
}

std::shared_ptr<CBlock> CBlockchainManager::getLatestKeyBlock(std::shared_ptr<CBlock> fromPerspectiveOf)
{
	std::lock_guard<ExclusiveWorkerMutex> lock(mChainGuardian);
	std::vector<std::shared_ptr<CBlock>> blocks = getRecentKeyBlocks(1, fromPerspectiveOf);
	if (blocks.size() > 0)
		return blocks[0];
	else return nullptr;
}

std::vector<std::shared_ptr<CBlock>> CBlockchainManager::getRecentKeyBlocks(uint64_t howMany, std::vector<uint8_t> fromPerspectiveoOfBlockID)
{
	std::lock_guard<ExclusiveWorkerMutex> lock(mChainGuardian);
	eBlockInstantiationResult::eBlockInstantiationResult bir;
	std::shared_ptr<CBlock> block = getBlockByHash(fromPerspectiveoOfBlockID, bir);
	if (!wasBlockRetrievalSuccessful(bir))
		return std::vector<std::shared_ptr<CBlock>>();
	else
		return getRecentKeyBlocks(howMany, block);
}

/// <summary>
/// Goes through the cache, and attempts to retrieve a givena mmount of recent key blocks.
/// Latest ones go first.
/// </summary>
/// <param name="howMany"></param>
/// <returns></returns>
std::vector<std::shared_ptr<CBlock>> CBlockchainManager::getRecentKeyBlocks(uint64_t howMany, std::shared_ptr<CBlock> fromPerspectiveOf)
{
	std::lock_guard<ExclusiveWorkerMutex> lock(mChainGuardian);

	std::shared_ptr<CBlock> current;
	std::vector<std::shared_ptr<CBlock>> blocks;
	current = (fromPerspectiveOf == nullptr ? mLeader : fromPerspectiveOf);
	std::shared_ptr<CBlockHeader> currentHeader = nullptr;
	if (mLeader == nullptr)
		return blocks;
	eBlockInstantiationResult::eBlockInstantiationResult res;
	for (uint64_t i = 0; blocks.size() < howMany && current != nullptr; i++)
	{
		currentHeader = current->getHeader();
		assertGN(currentHeader != nullptr);
		if (currentHeader->isKeyBlock())
			blocks.push_back(current);
		current = current->getParent(res, true, false, false, shared_from_this());
	}
	return blocks;
}

/// <summary>
/// The function traverses the chain in a look-out for the most recent KEY-BLOCK.
/// When found, the coresponding Public-Key is returned from within it.
/// </summary>
/// <returns></returns>
std::vector<uint8_t> CBlockchainManager::getPubKeyOfRecentKeyBlockOwner()
{
	return std::vector<uint8_t>();
}

/// <summary>
/// Returns the current peer ID (address generated based on the current state of local key-chain).
/// Returns a cached value if agreed upon and available.
/// </summary>
/// <param name="getCached"></param>
/// <returns></returns>
std::vector<uint8_t> CBlockchainManager::getCurrentID(bool getCached)
{
	//Local Variables - BEGIN
	std::vector<uint8_t> toRet;
	CKeyChain chain(false);
	std::vector<uint8_t> currentPubKey;
	//Local Variables - END

	//try to get cached ID (optmization)
	if (getCached)
	{
		toRet = getLocalPeerId();
		if (toRet.size() > 0)
			return toRet;
	}


	//go the longer way - no other choice
	if (!mSettings->getCurrentKeyChain(chain, false))
		return toRet;

	if (!mCryptoFactory->genAddress(chain.getPubKey(), toRet))
		return toRet;

	setLocalPeerId(toRet);//cache it for future usage.

	return toRet;

}

/// <summary>
/// Retrieves current leading KEY-BLOCK and checks if the public key within it
/// corresponds to one of the local KeyChains.
/// </summary>
/// <returns></returns>
bool CBlockchainManager::amITheLeader(CKeyChain chain, CKeyChain& leaderAtChain)

{
	if (CGlobalSecSettings::getFoceCurrentNodeLeaderDisableSigChecks())
	{
		leaderAtChain = chain;
		return true;
	}
	//------ remove above


	std::shared_ptr<CTools> tools = getTools();
	std::shared_ptr<CBlock> leadingKeyBlock = getLeader(true);
	if (leadingKeyBlock == nullptr)
		return false;
	//LOCAL VARIABLES - BEGIN
	std::vector<uint8_t> pubKeyInKeyBlock, myPubKey;
	std::string minersID;

	//LOCAL VARIABLES - END

	pubKeyInKeyBlock = leadingKeyBlock->getHeader()->getPubKey();
	minersID = mSettings->getMinersKeyChainID();

	if (minersID.size() == 0)
		return false;

	bool idFound = false;
	chain.setIndex(chain.getUsedUptillIndex());//yes, traverse from last to first - try all available keys
	do
	{

		if (tools->compareByteVectors(pubKeyInKeyBlock, chain.getPubKey()))
		{
			idFound = true;
			leaderAtChain = chain;
			break;
		}
		if (chain.getCurrentIndex() > 0)
			chain.setIndex(chain.getCurrentIndex() - 1);
		else
			break;

	} while (!idFound);

	return idFound;
}

bool CBlockchainManager::isStateDomainOwned(std::vector<uint8_t> id, const CKeyChain& chain)
{
	//LOCAL VARIABLES - BEGIN
	std::vector<uint8_t> myPubKey, currentAddr;
	bool idFound = false;
	//LOCAL VARIABLES - END
	std::shared_ptr<CTools> tools = getTools();
	if (!(mSettings->getCurrentKeyChain(const_cast<CKeyChain&>(chain), false, false, tools->bytesToString(id)) ||//first try to locate a domain-specific key-chain
		mSettings->getCurrentKeyChain(const_cast<CKeyChain&>(chain), false, false, mSettings->getMinersKeyChainID())))//then try to traverse the miner's main key-chain))
	{
		return false;
	}

	const_cast<CKeyChain&>(chain).setIndex(const_cast<CKeyChain&>(chain).getUsedUptillIndex());

	do
	{
		if (!mCryptoFactory->genAddress(const_cast<CKeyChain&>(chain).getPubKey(), currentAddr))
			return false;

		if (tools->compareByteVectors(currentAddr, id))
		{
			idFound = true;
			break;
		}
		if (const_cast<CKeyChain&>(const_cast<CKeyChain&>(chain)).getCurrentIndex() > 0)
			const_cast<CKeyChain&>(chain).setIndex(const_cast<CKeyChain&>(chain).getCurrentIndex() - 1);
		else
			break;

	} while (!idFound);

	return idFound;
}

std::shared_ptr<CNetworkManager> CBlockchainManager::getNetworkManager()
{
	return mNetworkManager;
}

void CBlockchainManager::updateLiveTransactionManagerStatistics(bool keyBlock)
{
	getLiveTransactionsManager()->getStateDomainManager()->appendKnownDomainIDs(
		getVerificationFlowManager()->getStateDomainManager()->getDomainsCreatedDuringFlow()//notice: domains created within Formation Flow Manager are validated by Verification Flow Manage sooner or later once the formed block gets verified.
	);
}

bool CBlockchainManager::addBlockToHuntedList(std::vector<uint8_t>& blockID, std::shared_ptr<CBlockHeader> header)
{
	if (blockID.size() != 32)
		return false;
	std::shared_ptr<CTools> tools = getTools();
	std::lock_guard<std::recursive_mutex> lock(mHuntedBlocksGuardian);

	for (int i = 0; i < mHuntedBlocks.size(); i++)
	{
		if (std::memcmp(std::get<0>(mHuntedBlocks[i]).data(), blockID.data(), 32) == 0)
			return false;
	}

	tools->logEvent(tools->getColoredString("[DSM-sync]:", eColor::lightCyan) +
		" adding block " + tools->base58CheckEncode(blockID) + " to the list of hunted blocks..", eLogEntryCategory::localSystem, 1);

	mHuntedBlocks.push_back(std::make_tuple(blockID, header, std::time(0)));//height is used as an optimization during availability checks.
	return true;
}


uint64_t CBlockchainManager::getNumberOfHuntedBlocks(bool doAutoRemoval)
{

	//Notice
	std::lock_guard<std::recursive_mutex> lock(mHuntedBlocksGuardian);

	uint64_t now = std::time(0);
	uint64_t huntedSince = 0;
	uint64_t maxTime = CGlobalSecSettings::getMaxTimeBlockHuntedFallback();//fall-back value since conversations should keep track of timeouts on their own
	//yet still we need a global check on the grounds of its own (if there was a fork and blocks holding prior blocks are no longer available).
	if (mHuntedBlocks.empty())
		return 0;

	if (doAutoRemoval)
	{
		std::shared_ptr<CTools> tools = CTools::getInstance();
		for (auto it = mHuntedBlocks.begin(); it != mHuntedBlocks.end(); )
		{
			huntedSince = std::get<2>(*it);

			if ((now > huntedSince) && (now - huntedSince) > maxTime)
			{
				tools->logEvent("Download of block " + tools->base58CheckEncode(std::get<0>(*it)) + tools->getColoredString(" timed-out", eColor::lightPink),
					eLogEntryCategory::network, 5);
				it = mHuntedBlocks.erase(it);

			}
			else
			{
				++it;
			}
		}
	}

	return mHuntedBlocks.size();
}


bool CBlockchainManager::isBlockHunted(std::vector<uint8_t>& blockID)
{
	uint64_t now = std::time(0);
	uint64_t huntedSince = 0;
	if (blockID.size() != 32)
		return false;
	std::lock_guard<std::recursive_mutex> lock(mHuntedBlocksGuardian);
	if (mHuntedBlocks.size() == 0)
		return false;


	for (int i = mHuntedBlocks.size() - 1; i > 0; i--)
	{


		if (std::memcmp(blockID.data(), std::get<0>(mHuntedBlocks[i]).data(), 32) == 0)
		{
			huntedSince = std::get<2>(mHuntedBlocks[i]);
			return true;
			///if ((now > huntedSince) && (now - huntedSince) < 120)
			//{
			//	return true;
			//}
			//else
			//{

			///}
		}

	}
	return false;
}

bool CBlockchainManager::removeBlockFromHuntedList(std::vector<uint8_t>& blockID)
{
	if (blockID.size() != 32)
		return false;

	std::shared_ptr<CTools> tools = getTools();
	std::lock_guard<std::recursive_mutex> lock(mHuntedBlocksGuardian);
	if (mHuntedBlocks.size() == 0)
		return false;
	for (int i = mHuntedBlocks.size() - 1; i >= 0; i--)
	{
		if (std::memcmp(blockID.data(), std::get<0>(mHuntedBlocks[i]).data(), 32) == 0)
		{
			tools->logEvent(tools->getColoredString("[DSM-sync]:", eColor::lightCyan) +
				" removing block " + tools->base58CheckEncode(blockID) + " from  the list of hunted blocks..", eLogEntryCategory::localSystem, 1);
			mHuntedBlocks.erase(mHuntedBlocks.begin() + i);
			return true;
		}
		if (i == 0)
			break;
	}
	return false;
}


CTests* CBlockchainManager::getTestsEngine()
{
	//assert(mTests != nullptr);//might be nullptr at first (circular dependancy between CScriptEngine and CTests).
	//	CScriptEngine will lazy query for CTests on demand.
	return mTests;
}

std::shared_ptr<CWorkManager> CBlockchainManager::getWorkManager()
{
	assertGN(mWorkManager != nullptr);

	return mWorkManager;
}

bool CBlockchainManager::wasBlockRetrievalSuccessful(eBlockInstantiationResult::eBlockInstantiationResult res)
{
	if (res == eBlockInstantiationResult::eBlockInstantiationResult::Failure ||
		res == eBlockInstantiationResult::eBlockInstantiationResult::blockDataUnavailableInCS
		|| res == eBlockInstantiationResult::eBlockInstantiationResult::parentMissing
		|| res == eBlockInstantiationResult::eBlockInstantiationResult::headerInstantationFailure)

		return false;
	else return true;
}



/**
 * @brief Updates the difficulty coefficients for the blockchain.
 *
 * This function recalculates and updates the difficulty coefficients used in the blockchain
 * to match the targeted block interval defined in the global security settings. The calculation
 * is based on the current leader block. If the current leader block is not known, the function
 * falls back to the initial difficulty setting.
 *
 * The function optionally acquires a lock on the blockchain's guardian mutex to ensure thread safety
 * during the update. This lock is managed based on the function's argument, allowing for flexibility
 * in concurrent environments where the mutex might already be locked at a higher level.
 *
 * Updates min. required difficulty. This takes into account the last time a valid block was appended and the current min difficulty.
 IMPORTANT: this does NOT take into account the REQUIRED last timestamp representing the CURRENT MOMENT -
 the getMinDifficultyFunction() REQUIRES. This function is thus only an optimization so that we do not need to lock
 the entire chain when calculating current required difficulty which changes with each consecutive time-slot.NOTICE: the required difficulty needs to be computed for the timestamp present within the block.

 * @param lockIt A boolean flag indicating whether the guardian mutex should be locked by this function.
 *               If set to true, the function will lock the mutex before performing updates to ensure
 *               thread safety. If false, the function will proceed without attempting to lock, assuming
 *               external synchronization.
 *
 * @note This function locks `mChainGuardian` and `mLeaderGuardian` mutexes unconditionally to protect
 *       the integrity of the blockchain's state during the update process. These locks are always
 *       acquired, regardless of the `lockIt` parameter, which only affects the `mGuardian` mutex.
 *
 * @warning Ensure that the calling context accounts for potential deadlocks when setting `lockIt` to false,
 *          especially in multi-threaded environments where mutex locking order can lead to deadlock situations.
 *
 * @todo Improve the storage mechanism for difficulty values to ensure proper rounding and precision.
 */
void CBlockchainManager::updateMinDifficultyCoefficients(bool lockIt)
{
	std::unique_lock<std::recursive_mutex> guardianLock(mGuardian, std::defer_lock);
	std::unique_lock<ExclusiveWorkerMutex> chainGuardianLock(mChainGuardian, std::defer_lock);
	std::unique_lock<std::recursive_mutex> leaderGuardianLock(mLeaderGuardian, std::defer_lock);

	if (lockIt) {
		std::lock(guardianLock, chainGuardianLock, leaderGuardianLock);
	}

	// Local Variables - BEGIN
	bool ok = false;
	double diff = 1;
	// Local Variables - END

	// Operational Logic - BEGIN
	getTools()->writeLine("Updating new cached difficulty co-efficients to match the target (sec):" + std::to_string(CGlobalSecSettings::getTargetedBlockInterval()));

	if (mLeader == nullptr)
	{
		getTools()->writeLine("Falling back to initial difficulty, Leader unknown");
		ok = true;
	}
	else {
		diff = getMinDIfficultyForBlock(mLeader, 0, false, true, ok, shared_from_this());//the 'now' will be accounted for per query
	}
	assertGN(ok);

	//Todo: change how we store difficulty to ensure proper rounding.
	getTools()->writeLine("New Base Difficulty: " + std::to_string(diff));
	// Operational Logic - END
}






double CBlockchainManager::getMinDIfficultyForBlock(std::vector<uint8_t> blockID, uint64_t now, bool& ok)
{
	std::lock_guard<std::recursive_mutex> lock(mGuardian);
	eBlockInstantiationResult::eBlockInstantiationResult result;
	std::shared_ptr<CBlock> block = getBlockByHash(blockID, result);
	if (block == nullptr || !wasBlockRetrievalSuccessful(result))
	{
		ok = false;
		return 0;
	}

	double diff = getMinDIfficultyForBlock(block, now, false, false, ok);
	return diff;
}

void CBlockchainManager::updateDataBlockInterval()
{
	sync::SynchronizedLocker lock(sync::LockingPolicy::MemoryOrdered, mChainGuardian, mVerifiedPathGuardian, mLeaderGuardian);

	//std::lock_guard<std::recursive_mutex> lock(mGuardian);

	if (getLeader() == nullptr)
	{
		setAverageDataBlockInterval(0);
	}

	eBlockInstantiationResult::eBlockInstantiationResult res = eBlockInstantiationResult::eBlockInstantiationResult::OK;

	uint64_t sampled = 0;
	double avrTimeBetweenBlocks = 0;

	std::shared_ptr<CBlock> parentBlock;
	uint64_t localTimeInteval = 0;

	std::shared_ptr<CBlock> currentBlock = getLeader();


	if (currentBlock != nullptr)
		parentBlock = currentBlock->getParent(res, true, false, true, shared_from_this());

	if (parentBlock == nullptr) {
		getTools()->writeLine("No parent block available calculation of current difficulty impossible!");
		getTools()->writeLine("I will fall-back to the default difficulty.");
		return;
	}

	avrTimeBetweenBlocks = CGlobalSecSettings::getTargetedBlockInterval();
	//std::shared_ptr<CBlock> lastBlock = nullptr;

	while (sampled < 288 && currentBlock != nullptr && parentBlock != nullptr)
	{
		if (currentBlock->getHeader()->getSolvedAtTime() <= parentBlock->getHeader()->getSolvedAtTime()
			|| currentBlock->getHeader()->getSolvedAtTime() == 0 || parentBlock->getHeader()->getSolvedAtTime() == 0)
		{
			currentBlock = parentBlock;
			parentBlock = currentBlock->getParent(res, true, false, true, shared_from_this());
			continue;
		}

		localTimeInteval = currentBlock->getHeader()->getSolvedAtTime() - parentBlock->getHeader()->getSolvedAtTime();
		if (localTimeInteval == 0 || avrTimeBetweenBlocks == 0)
		{
			currentBlock = parentBlock;
			parentBlock = currentBlock->getParent(res, true, false, true, shared_from_this());
			continue;
		}


		avrTimeBetweenBlocks = (avrTimeBetweenBlocks + localTimeInteval) / 2;

		sampled++;

		currentBlock = parentBlock;
		parentBlock = currentBlock->getParent(res, true, false, true, shared_from_this());
		if (!wasBlockRetrievalSuccessful(res) && !currentBlock->isGenesis())
		{
			return;
		}
		else if (currentBlock->isGenesis())
			break;

	}
	setAverageDataBlockInterval(avrTimeBetweenBlocks);
	getTools()->writeLine("Average time between data-blocks at height: " + std::to_string(getLeader()->getHeader()->getHeight()) + " was found to be (sec): " + std::to_string((uint32_t)avrTimeBetweenBlocks)
		+ "\n (expected " + std::to_string(CGlobalSecSettings::getTargetedBlockInterval()) + "sec ) compensating with new Difficulty..");


}

/// <summary>
/// This function is used directly by the mining system.
/// AND the block verification mechanics (through the doKeyPartVerification() method)
/// </summary>
/// Warning: 'useOptimization' CANNOT be used for blocks forking the current chain.Only for blocks that EXTEND the current chain.
/// <param name="block"></param>
/// <param name="now"></param>
/// <param name="ok"></param>
/// <param name="bm"></param>
/// <returns></returns>
double CBlockchainManager::getMinDIfficultyForBlockSMA(std::shared_ptr<CBlock> block, uint64_t now, bool useOptimization, bool& ok, std::shared_ptr<CBlockchainManager> bm)
{
	// Local Variables - BEGIN
	uint64_t summedTimeDiffs = 0;
	uint64_t sampledKeyBlocks = 0;
	double summedDiff = 0;
	uint64_t avrTimeBetweenBlocks = 0;
	uint64_t localTimeInteval = 0;
	double   avrDifficulty = 0;
	double currentDiff = 1;
	std::shared_ptr<CBlock> parentKeyBlock, imminentParentKeyBlock;
	std::shared_ptr<CSettings> settings = getSettings();
	// Local Variables - END

	//Pre-Flight - BEGIN
	// we cannot use optimization if current key-leader is unkown
	if (useOptimization)
	{
		parentKeyBlock = getCachedLeader(true);//valid under the assumption that optimization used only when extending proclaimed chain.
		if (!parentKeyBlock)
		{
			useOptimization = false;
		}
		else
		{
			imminentParentKeyBlock = parentKeyBlock;
		}
	}
	//Pre-Flight - END

	//std::lock_guard<std::recursive_mutex> lock(mGuardian);
	if (!useOptimization)
	{// No Optimization - BEGN
		//need to lock local chain (forking)
		std::lock_guard<ExclusiveWorkerMutex> lock2(mChainGuardian);

		if (block == nullptr)
		{
			ok = true;
			return 1;
		}
		//retflag = true;
		//rationale and ideas in other projects:
		//https://blog.bitmex.com/the-implications-for-bitcoin-of-the-new-bitcoin-cash-difficulty-adjustment/
		//https://www.trustnodes.com/2017/10/30/bitcoin-cash-adjust-difficulty-algorithm-two-weeks

		//we use a moving average over a 24 hours window, with samples each 5 minutes (supposed).
		//which is equal to a moving average over last 288 blocks
		//we calculate the average block interval between consecutive blocks within that window and average difficulty
		//the difficulty is adjusted proportionally to maintain the 5 minute block interval.

		eBlockInstantiationResult::eBlockInstantiationResult res = eBlockInstantiationResult::eBlockInstantiationResult::OK;
		//parentBlock = block->getHeader()->getParent(res);

		std::shared_ptr<CBlock> currentBlock = block;

		if (!currentBlock->getHeader()->isKeyBlock())
			currentBlock = getKeyBlockForBlock(currentBlock);


		if (currentBlock != nullptr)
		{
			parentKeyBlock = getKeyBlockForBlock(currentBlock);
		}

		if (parentKeyBlock == nullptr)
		{
			if (!currentBlock->isGenesis())
			{
				getTools()->writeLine("No parent key-block available calculation of current difficulty impossible!");
				getTools()->writeLine("I will fall-back to the default difficulty.");
				ok = false;
				return 1;
			}
			else
			{
				getTools()->writeLine("The grand-parent is the Genesis-Block! I shall assume mining difficulty equal to 1..");
				ok = true;
				return 1;
			}
		}
		assertGN(parentKeyBlock->getHeader()->isKeyBlock());

		avrTimeBetweenBlocks = CGlobalSecSettings::getTargetedBlockInterval();
		currentDiff = parentKeyBlock->getHeader()->getDifficulty();
		//std::shared_ptr<CBlock> lastBlock = nullptr;
		uint64_t windowSize = CGlobalSecSettings::getKeyBlockDiffWindowSize();

		while (sampledKeyBlocks < windowSize && currentBlock != nullptr && parentKeyBlock != nullptr)
		{
			if (!currentBlock->getHeader()->isKeyBlock())
			{//we're interested only in KEY-BLOCKs for difficulty adjustments
				currentBlock = parentKeyBlock;
				parentKeyBlock = getKeyBlockForBlock(currentBlock);
				continue;
			}

			if (currentBlock->getHeader()->getSolvedAtTime() <= parentKeyBlock->getHeader()->getSolvedAtTime()
				|| currentBlock->getHeader()->getSolvedAtTime() == 0 || parentKeyBlock->getHeader()->getSolvedAtTime() == 0)
			{
				currentBlock = parentKeyBlock;
				parentKeyBlock = getKeyBlockForBlock(currentBlock);
				continue;
			}

			localTimeInteval = currentBlock->getHeader()->getSolvedAtTime() - parentKeyBlock->getHeader()->getSolvedAtTime();

			summedTimeDiffs += localTimeInteval;
			summedDiff += currentBlock->getHeader()->getDifficulty();
			sampledKeyBlocks++;

			currentBlock = parentKeyBlock;
			parentKeyBlock = getKeyBlockForBlock(currentBlock, true);
			if (!wasBlockRetrievalSuccessful(res) && !currentBlock->isGenesis())
			{
				ok = false;
				return currentDiff;
			}
			else if (currentBlock->isGenesis())
				break;

		}
		std::lock_guard<std::recursive_mutex> lock(mDiffCoefficientsGuardian);
		mSettings->setMinDifficultyCoefficientSummedTimeDiffs(summedTimeDiffs);
		mSettings->setMinDifficultyCoefficientTimeSlotsCount(sampledKeyBlocks);
		mSettings->setEMADifficultyCoefficient(summedDiff);
		// No Optimization - END
	}
	else
	{
		//Optimization Enabled  - BEGIN
		std::lock_guard<std::recursive_mutex> lock(mDiffCoefficientsGuardian);
		summedTimeDiffs = mSettings->getMinDifficultyCoefficientSummedTimeDiffs();
		sampledKeyBlocks = mSettings->getMinDifficultyCoefficientTimeSlotsCount();
		summedDiff = mSettings->getEMADifficultyCoefficient();

		//Optimization Enabled  - END
	}

	//account for the current moment - BEGIN
	if (now && imminentParentKeyBlock)//account for current moment only when provided.
	{//if not provided then we simply update the coefficients.
		//IMPORTANT: only value based on current time can be used for consensus purposes, that is because the difficulty needs
		// to DROP with each passing moment.

		// [Time is Relative]
		//From the miner's perspective 'now' is going to be the local system time (Unix Epoch).
		//From the validator's perspective 'now' is to be the timestamp injected within of the block.
		uint64_t parentBlockTime = imminentParentKeyBlock->getHeader()->getSolvedAtTime();
		assertGN(now > parentBlockTime);//more gentle checks MUST be present beforehand. It's just a last resort check.
		localTimeInteval = now - parentBlockTime;
		summedTimeDiffs += localTimeInteval;
		//summedDiff += currentBlock->getHeader()->getDifficulty();
	}
	//account for the current moment - END
	if (!imminentParentKeyBlock)
	{
		if (block && block->getHeader()->getKeyHeight() == 0)
		{//for Genesis Block return 1
			ok = true;
			return 1;
		}
		//otherwise a parent key block must be known
		ok = true;//return false
		return (uint64_t)(-1);//return a prohibitibly high difficulty
	}
	//assertGN(!((summedTimeDiffs|| sampledKeyBlocks) && !parentKeyBlock));

	uint64_t divisor = (parentKeyBlock ? (sampledKeyBlocks + 1) : sampledKeyBlocks);

	if (divisor == 0)
	{
		ok = false;
		return (uint64_t)(-1);//return a prohibitibly high difficulty
	}

	avrTimeBetweenBlocks = summedTimeDiffs / divisor;//+1 to account for now

	setAverageSMAKeyBlockInterval(avrTimeBetweenBlocks);
	if (block)
	{
		getTools()->writeLine("Average time between key-blocks at height: " + std::to_string(block->getHeader()->getHeight()) + " was found to be (sec): " + std::to_string((uint32_t)avrTimeBetweenBlocks)
			+ "\n (expected " + std::to_string(CGlobalSecSettings::getTargetedBlockInterval()) + "sec ) compensating with new Difficulty..");
	}
	if (avrTimeBetweenBlocks == 0)
		return 1;//default for Genesis Block

	if (sampledKeyBlocks > 0)
	{
		avrDifficulty = summedDiff / (double)sampledKeyBlocks;
		
		if (avrTimeBetweenBlocks == 0)
		{
			ok = false;
			return  (uint64_t)(-1);//return a prohibitibly high difficulty;
		}

		currentDiff = max(avrDifficulty * ((double)CGlobalSecSettings::getTargetedBlockInterval() / (double)avrTimeBetweenBlocks), 1);
	}
	else currentDiff = 1;

	ok = true;
	return currentDiff;
}
/*

### `getMinDIfficultyForBlock` Function Description

The `getMinDIfficultyForBlock` method within the `CBlockchainManager` class calculates the mining difficulty for an upcoming block in the blockchain. The calculation is based on a moving average mechanism, more specifically, the Exponential Moving Average (EMA) and Simple Moving Average (SMA).

#### Function Operation:

1. **Initialization**:
   - The function starts by initializing local variables, including the EMA's base smoothing factor `baseAlpha` and some other parameters like the targeted block interval.

2. **Pre-Flight Checks**:
   - If the optimization flag is enabled (`useOptimization`), the function attempts to retrieve the cached leader block. If it fails, the optimization mode is turned off for this execution.
   - This ensures that the function can fall back to a non-optimized mode if necessary conditions for optimization are not met.

3. **Non-Optimized Difficulty Calculation**:
   - In the absence of optimization, the function locks the blockchain using `mChainGuardian` to ensure thread safety during data access.
   - It then iteratively processes previous key blocks to gather time intervals between them.
   - For each key block, it adjusts the EMA values for both the time between blocks (`emaTimeBetweenBlocks`) and difficulty (`emaDifficulty`). The EMA calculation incorporates a dynamically adjusted smoothing factor.
   - SMA values are simultaneously calculated but are primarily used for reporting, not for the final difficulty computation.
   - At the end of this segment, the calculated EMA values are cached for potential future use in optimized mode.

4. **Optimized Difficulty Calculation**:
   - If the optimization mode is used, the previously cached EMA values are directly fetched, skipping the iterative process over past key blocks.

5. **Final Difficulty Computation**:
   - If the `now` time-stamp is provided, the function factors in the time since the last key block to adjust the EMA values one final time.
   - The current difficulty is then computed using the formula: `emaDifficulty * (targetInterval / emaTimeBetweenBlocks)`.
   - In the absence of the `now` time-stamp, the current difficulty is set directly to `emaDifficulty`.

6. **Edge Cases & Reporting**:
   - The function checks for specific scenarios like the genesis block or the absence of a valid parent key block.
   - There are reporting steps embedded in the function, which provide insights into how the calculated difficulty compares to the targeted block interval values.

#### Important Considerations:

- **Thread Safety**: The method employs `std::lock_guard` at critical sections to ensure thread safety during concurrent access of shared resources.
- **Flexibility**: The function can operate in both optimized and non-optimized modes, ensuring adaptability depending on available data and the context of the call.
- **Error Handling**: The function checks for edge cases and potential pitfalls, ensuring graceful fall-backs or meaningful outputs in such scenarios.

#### Usage:
This function is pivotal in determining the mining difficulty, which ensures the blockchain's security and adjusts the rate of block generation to align with network goals.



### Cached Values
The only cached value related to the optimization process seems to be stored in `mSettings`. Specifically:
- `mSettings->getEMATimeBetweenBlocks()`
- `mSettings->getMinDifficultyCoefficientSummedDiff()`

These values are used when `useOptimization` is set to `true`:
```cpp
emaTimeBetweenBlocks = mSettings->getEMATimeBetweenBlocks();
emaDifficulty = mSettings->getMinDifficultyCoefficientSummedDiff();
```

In the non-optimized mode, after processing all the blocks within the required window, these values are stored:
```cpp
mSettings->setEMATimeBetweenBlocks(emaTimeBetweenBlocks);
mSettings->setMinDifficultyCoefficientSummedDiff(emaDifficulty);
```

### Ensuring Coherence Between Optimized and Non-Optimized Modes

1. **Initialization**:
   - In the non-optimized mode, the Exponential Moving Averages (EMA) for time between blocks and difficulty are initialized with default values.
   - In the optimized mode, the EMA values are initialized from the cached values.

2. **Block Processing**:
   - Non-Optimized Mode: The loop processes all the key blocks within the window, updating the EMA values using the `adjustedAlpha` smoothing factor.
   - Optimized Mode: Only uses the cached EMA values without looping through the key blocks.

3. **Accounting for the Current Moment**:
   - This section of the code is executed in both optimized and non-optimized modes when the 'now' timestamp is provided. It uses the parent block's timestamp to adjust the difficulty based on the time taken for the latest block. Both modes utilize the same logic here, ensuring coherence.

### Verification

1. **Cached Value Validity**: We have to ensure that the cached values stored in `mSettings` are always updated correctly after the non-optimized loop finishes processing. This ensures that the optimized mode starts with the correct EMA values.

2. **Coherence**: If the cached values are accurate, and no blocks are added or removed between two calls (one using optimized mode and another not), both modes should return the same difficulty.

### Average Time to Produce Blocks

The desired average time between blocks is stored in `CGlobalSecSettings::getTargetedBlockInterval()`.

The mechanism that tries to maintain this average is the adjustment of difficulty. If blocks are being produced faster than this target, difficulty is increased. If they're being produced slower, it's decreased.

The adjustment logic:
currentDiff = max(emaDifficulty * (CGlobalSecSettings::getTargetedBlockInterval() / emaTimeBetweenBlocks), 1.0);


This logic attempts to keep the actual average time (`emaTimeBetweenBlocks`) close to the target by adjusting the difficulty (`currentDiff`).

*/
double CBlockchainManager::getMinDIfficultyForBlock(std::shared_ptr<CBlock> block, uint64_t now, bool useOptimization, bool updateLIVECoefficients, bool& ok, std::shared_ptr<CBlockchainManager> bm, const uint64_t& EMA, const  uint64_t& SMA, double forcedAlpha, double forcedStepFactor, const uint64_t& alphaZeroedAtStep)
{
	// Local Variables - BEGIN
	uint64_t sampledKeyBlocks = 0;
	uint64_t avrSMATimeBetweenBlocks = 0;
	uint64_t currentDifficulty = 0;
	bool isParentHF = false;
	bool isCurrentHF = false;
	uint64_t parentDifficulty = 0;
	uint64_t timeInterval = 0;
	std::shared_ptr<CBlock> parentBlock;
	std::shared_ptr<CSettings> settings = getSettings();
	uint64_t summedSMATimeDiffs = 0;
	uint64_t windowSize = CGlobalSecSettings::getKeyBlockDiffWindowSize();
	const_cast<uint64_t&>(alphaZeroedAtStep) = 0;
	uint64_t targetBlockInterval = CGlobalSecSettings::getTargetedBlockInterval();
	double alpha = CGlobalSecSettings::getPoWDiffBaseAlpha(); //2.0 / (windowSize + 1.0); // Base smoothing factor for EMA
	double emaTimeBetweenBlocks = 0;// settings->getEMATimeBetweenBlocks();// CGlobalSecSettings::getTargetedBlockInterval();
	uint64_t parentBlockTime = 0;
	std::shared_ptr<CTools> tools = getTools();
	uint64_t timeSeriesIndex = 1;
	uint64_t currentBlockTime = 0;
	bool alphaAlreadyZeroed = false;
	double currentDiff = DEFAULT_DIFFICULTY;
	double emaDifficulty = DEFAULT_DIFFICULTY;
	double avrDifficulty = 0;
	double stepFactor = CGlobalSecSettings::getPoWDiffBaseStepFactor(); //IMPORTANT: windowSize * some_small_factor CANNOT get close to 1.
	std::shared_ptr<CBlock> currentBlock = block; // at all stages, 'currentBlock' must always reresent to block relative to which difficulty is to be calculated.
	std::vector<std::tuple<uint64_t, uint64_t, bool>> timeSeries; // [ timestamp | difficulty | isHardForkBlock ]
	//int blockIndex = 0; // Start with the most recent block

	//Coefficients override support - BEGIN
	if (forcedAlpha)
	{
		useOptimization = false;
		alpha = forcedAlpha;
	}

	if (forcedStepFactor)
	{
		useOptimization = false;

		stepFactor = forcedStepFactor;
	}
	//Coefficients override support - END


	//Imminent History Boost - BEGIN

	//Imminent History Boost - END


			/*

					/* Initializing an Exponential Moving Average (EMA) is
					typically done with the first actual data point available
					because an EMA is a type of infinite impulse response filter
					that applies weighting factors which decrease exponentially.
					The weighting for each older data point decreases
					exponentially, giving much more importance to recent data
					points.

					 Given the frequency of data points and the nature of the
					 EMA, initializing the EMA to the expected block time
					 interval and the parent's difficulty is a pragmatic
					 approach. It will provide a good balance between simplicity
					 and accuracy, with any initial variance being quickly
					 corrected as new data points are factored into the EMA
					 calculation.



					// we kick-start EMA with 1) the expected block time interval 2) the difficulty as seen by parent.
					// Then, all the further EMA steps are only to increase precision of measurement.
			*/
			// initial EMA values - BEGIN
	emaTimeBetweenBlocks = targetBlockInterval;
	emaDifficulty = parentDifficulty;
	// initial EMA values - END	


// Local Variables - END

//Pre-Flight - BEGIN
//here we load up all the data used by both the optimized and non-optimized modes.
//if any data is missing we switch modes of operation or ABORT.

/* -------------------------------------------------------
	[ILL LOGIC] --- BEGIN
	UPDATE: current moment needs to have most influence.
			Thus current moment 'now' - it needs to be processed first and benefit from the highest value of the Alpha coefficient.
			We need to use optimization for rapid lookups of PoW difficulty.
			Since future values of EMA depend on prior computations (ex. accounting for 'now') - we MUST calculate EMA from earlier blocks towards the most recent ones.
			Only in this way can we 'optimize' for frequent looks by pre-caching computations performed by prior blocks. It wouldn't be feasible the other way around (from most recent towards earlier
			blocks).

			If 'block' provided - we compute minimum expected difficulty relevant to 'block' and 'now'.

			We begin calculating EMA beginning with a block which is utmost 'windows-size' back into the past.
			The alpha value starts with INITIAL_ALPHA and continues being incremented.
			We keep track of when Alpha reaches FINAL_ALPHA (the step at which would be returned through a reference).
			At each step we adjust Alpha by the adjustedStepFactor which itself is adjusted at each and every step.https://cdn.discordapp.com/attachments/1160915498498805871/1169996396879937556/image.png?ex=65576f0e&is=6544fa0e&hm=3fc62c0f3697dcf638c79194c9bbbe0f057a0de93f2d4de0377611805e96f16c&

			[adjustedStepFactor]: it would best be initially very small and only crease as we approach newer data points.
								  notice: the adjustedStepFactor only reinforces the already present nature of EMA, which is promoting ear.

			Thus, in Optimized Mode - we basically take the pre-fetched values and account only for 'now'.
	[ILL LOGIC] --- END

	We cannot do the above. We NEED to compute from earliest to furthest because that's what the nature of EMA *DEMANDS* if we are to prioritize most recent data points.
	The adjustedStepFactor ONLY reinforces this very nature of EMA. But ultimately it is the ORDER of computation.
	Typical EMA algorithm uses a CONSTANT Alpha coefficient which does not change at each step.
  -------------------------------------------------------
*/

/*
Optimization or not, the basic logic is as follows:
We take into account key-blocks ONLY. All blocks involved here are key-blocks.

	1) calculate EMA of difficulty AND block-intervals of timestamps comprising the window size.
		Block headers contain target (the nonce needs to be below). Difficulty is the inverse.

		In any case, this function is to calculate difficulty required by the next consecutive block, taking into account the prior earlier one.
		We thus need to calculate EMA of difficulty among all the past blocks, taking into account the amount of blocks *up to and including* the window size.
		[IMPORTANT]: + the 'now' timestamp need to count-up to the window size when calculating the block-interval EMA.
					 + the difficulty of the to-be-produced block DOES NOT count up to the difficulty EMA. That's the value which is to be established.
					 + STILL, when 'updateLIVECoefficients' is set, both of the resulting final EMAs and the last window height used are to be cached.

	2) adjust the difficulty to match the Target time-interval between blocks.

	[Method of Operation],
	A) Optimized (approximated) Mode - we use pre-calculated EMA coefficients. Thus, only the most recent timestamp (provided by the 'now' argument is allowed to change).
	B) Non-Optimized Mode - re-calculate all of the EMA coefficients by traversing all blocks comprising the window of blocks which are taken into account (define by 'windowSize').


	[When to use which]:
	A) Optimized Mode - ONLY for reporting in real-time
					  - the reason is: as of now, the optimized mode only returns an ESTIMATE. Blocks already outside of the window keep influencing the computed
									   difficulty due to the cached co-efficients
									   being updated indefinitely. As of now we risk the EMA coefficients being out of sync - something we cannot allow when computing / verifying PoW.
									   This stays in contrast with non-optimized mode which takes into account ONLY the recent window-size
									   blocks and is guaranteed to return valid results. For optimized mode to be any good for 'mining' or verification purposes, the non-optimized mode would need to
									   recalculate EMA coefficients starting from the very Genesis Block, on each fork and the 'optimized' version could be then used during consecutive
									   computations up until a fork occurs, which is when the non optimized mode with 'update EMA coefficients' flag would need to be invoke at least once.
									   [Future changes]:Notice that such a change would require a new obligatory checkpoint to be introduced as most of the previous PoWs would be rendered invalid.

	B) Non-Optimized Mode - after a fork. Non-optimized mode needs to be invoked at least once. Then, Optimized Mode may be used (until next fork occurs as it would).
*/

//block might have not had been provided at all.

// Current Block - BEGIN
// [IMPORTANT]: current block, provided in function argument may be ANY block (data-block, key-block, Hard-Fork block, a nullptr etc.)
//				It is thus the responsibility of this function to come up with an appropriate value, based on the one provided.
	if (!currentBlock)
	{
		if (useOptimization)
		{
			currentBlock = getCachedLeader(true); // needed to compute time difference between 'now'

			//if (currentBlock && currentBlock->getHeader()->getNonce() == 0)
			//{
				// Hard-Fork block
			//	currentBlock = getKeyBlockForBlock(currentBlock, false);
			//}

			if (!currentBlock)
			{
				ok = false;
				return PROHIBITIVE_DIFFICULTY;
			}
		}
		else
		{
			currentBlock = getLeader(true); // needed to compute time difference between 'now' (notice: not cached).

			/*if (currentBlock && currentBlock->getHeader()->getNonce() == 0)
			{
				// Hard-Fork block
				currentBlock = getKeyBlockForBlock(currentBlock, false);
			}*/

			if (!currentBlock)
			{
				ok = true;
				return DEFAULT_DIFFICULTY;//for Genesis Block
			}
		}
	}

	//Just to be sure:
	//is the block really a key-block?
	if (currentBlock && (currentBlock->getHeader()->isKeyBlock() == false))// || currentBlock && currentBlock->getHeader()->getNonce()==0))
	{//find the corresponding key-block
		currentBlock = getKeyBlockForBlock(currentBlock, false);

		if (!currentBlock)
		{
			ok = false;
			return PROHIBITIVE_DIFFICULTY;
		}
	}

	if (!currentBlock)
	{
		ok = false;
		return PROHIBITIVE_DIFFICULTY;
	}


	// Current Block - END

	// Parent Block - BEGIN

	//the parent (relative to 'block') KEY-block needs to be known for anything else than Genesis Block.
	//that is because we need to be able to compute the time-difference between 'now' and past block.
	if (currentBlock->isGenesis() == false)
	{
		parentBlock = getKeyBlockForBlock(currentBlock, false);

		if (!parentBlock)
		{
			ok = false;
			return PROHIBITIVE_DIFFICULTY;
		}

	
	}
	else {
		tools->writeLine("Genesis Block, falling back to default difficulty.");
		ok = true;
		return DEFAULT_DIFFICULTY;
	}


	if (!parentBlock)
	{
		tools->writeLine("No parent key-block available calculation of current difficulty impossible!");
		tools->writeLine("I will fall-back to the prohibitive difficulty.");
		ok = false;
		return PROHIBITIVE_DIFFICULTY;
	}
	// Parent Block - END

	// 
	//Pre-Flight - END

	//Operational Logic - BEGIN

	// [ PHASE 1 ] Compute Block Interval (seconds) and Difficulty EMAs - BEGIN

	// Find the furthest Key-Block up to the (windows_size-1) - leave a time-slot to account for 'now'.
	// We would then compute EMA by going towards most recent block and finally towards 'now' respectively (if provided). That way newer blocks have most significant effect.
	// The 'now' data-point would be the one considered, if provided. If not provided, then we simply pre-recompute the pre-cached EMA values.


	//Construct the Time Series - BEGIN
	// begin traversal from the provided block - the current presumed leading block. We would then continue going back in time.
	// IMPORTANT: the 'currentBlock' and 'parentBlock' pointers are used later on for further assessment (not for traversal though).

	if (!useOptimization)
	{
		std::shared_ptr<CBlock> temp;
		std::shared_ptr<CBlock> iterator = currentBlock;
		if (windowSize >= 2 && iterator)
		{
			uint64_t priorTimestamp = 0;
			uint64_t currentTimestamp = 0;
			for (uint64_t i = 0; i < windowSize - 1; i++) // Loop runs windowSize - 1 times. Thus the loop would run up to windowSize times (144-1) = 143 elements in timeSeries.
			{// this effectively produces 144 measurements in 'timeSeries' - each measurement every ~10 minutes over the period of ~24 hours.

				if (iterator->getHeader()->isHardForkBlock())
				{//Hard Fork Block
					timeSeries.push_back(std::make_tuple<uint64_t, uint64_t, bool>(
						iterator->getHeader()->getSolvedAtTime(),
						CGlobalSecSettings::getHardForkDifficulty(),
						iterator->getHeader()->isHardForkBlock()
					));
				
					break;
				}
				// Push data from the current block into the time series.
				
				currentBlockTime = iterator->getHeader()->getSolvedAtTime();

				timeSeries.push_back(std::tuple<uint64_t, uint64_t, bool>(
					currentBlockTime,
					iterator->getHeader()->getDifficulty(),
					iterator->getHeader()->isHardForkBlock()
				));

				if (parentBlockTime == currentBlockTime)
				{
					//assertGN(false);
				}
				parentBlockTime = currentBlockTime;

				// Update the parent block pointer with the parent of the temporary block (which was the current block).
				temp = getKeyBlockForBlock(iterator, false);//keep omitting Hard-Fork blocks.

				if (!temp)// If there is no parent block, it's the end of the chain (Genesis Block or broken chain).
				{
					// Push a placeholder indicating no more data points are available.
					timeSeries.push_back(std::make_tuple<uint64_t, uint64_t,bool>(0, 0, false));
					break; // Exit the loop since we've reached the end of the chain.
				}

				// Move the parent block to be the current block for the next iteration.
				iterator = temp;

				// Continue with the next iteration until the loop finishes or breaks early.
			}
		}
	}

	parentBlockTime = 0;
	currentBlockTime = 0;
	//Construct the Time Series - END


	/*	[IMPORTANT] - ALWAYS account for the current moment LAST.* LITERALLY *
					  -'now' needs to be accounted for as the very LAST element
					  of the time-series. (the ORDER of computation *matters*).

					  That is to benefit from the inherent nature of EMA which
					  promotes earlier data points over the latter. Any dynamic
					  adjustments to Alpha, during computation of the time
					  series, are NOT typical and NOT advised.

					  Bottom Line: way better to adjust the size of the window
					  (in 'emergency mode' rather than to play around with
					  dynamic adjustments of Alpha (through the concept of a
					  'dynamic step factor'). Thus, the dynamic step factor is now
					  0 by default.
			*/


			// ----------------------- IMPORTANT -----------------------------------------
			/*
				We always account for the current moment LAST. It is thus only the matter
				of whether we reuse the precomputed EMA time series (Optimized Mode) or
				whether we compute EMA for the entire preceding (windows_size-1)
				time-series anew (Non-Optimized Mode).

			*/

	if (useOptimization)
	{// Optimized Mode - BEGIN
	   //we need these values to have been precomputed and present already, otherwise fall-back to normal mode.
		emaTimeBetweenBlocks = mSettings->getEMATimeBetweenBlocks();//As far as time-between blocks is concerned, for difficulty adjustments, we need to store only this EMA value (not the SMA time between blocks).
		emaDifficulty = mSettings->getEMADifficultyCoefficient();

		if (emaTimeBetweenBlocks == 0 || emaDifficulty == 0)
		{// if not pre-cached values available - fall back to defaults.
			emaTimeBetweenBlocks = targetBlockInterval;
			emaDifficulty = DEFAULT_DIFFICULTY;
		}

		// Optimized Mode - END
	}
	else
		// No Optimization - BEGIN
	{
		/*
		Here, instead of reusing the already pre-computed EMA values - we compute these anew.
		That might be necessary if the chain forked recently or if quick approximated results are desirable.
		*/

		//need to lock the chain
		std::lock_guard<ExclusiveWorkerMutex> lock2(mChainGuardian);

		if (currentBlock == nullptr)
		{
			ok = true;
			return DEFAULT_DIFFICULTY;
		}

		//rationale and ideas in other projects:
		//https://blog.bitmex.com/the-implications-for-bitcoin-of-the-new-bitcoin-cash-difficulty-adjustment/
		//https://www.trustnodes.com/2017/10/30/bitcoin-cash-adjust-difficulty-algorithm-two-weeks

		//we use a moving average over a 24 hours window, with samples each 10 minutes (expected).
		//which is equal to a moving average over last 144 blocks
		//we calculate the average block interval between consecutive blocks within that window and average difficulty
		//the difficulty is adjusted proportionally to maintain the 5 minute block interval.

		eBlockInstantiationResult::eBlockInstantiationResult res = eBlockInstantiationResult::eBlockInstantiationResult::OK;
		//parentBlock = block->getHeader()->getParent(res);

		if (timeSeries.size() > 1)//at least two elements in the time-series are required. Otherwise, the Genesis Block and other Edge Case scenario measures should have taken care of earlier.
		{
			// [ IMPORTANT ]: initial data points in the 'timeSeries'  represent the most recent blocks. This stands in contract with how 'chain-proofs' are structured.
			for (timeSeriesIndex = 0; timeSeriesIndex < timeSeries.size() - 1; timeSeriesIndex++) // we can now presume the length of the time-series to be of the correct size already.
			{
				// [ 0 | 0 ] - Genesis Block
				parentBlockTime = std::get<0>(timeSeries[timeSeriesIndex + 1]);
				currentBlockTime = std::get<0>(timeSeries[timeSeriesIndex]);

				parentDifficulty = std::get<1>(timeSeries[timeSeriesIndex + 1]);
				currentDifficulty = std::get<1>(timeSeries[timeSeriesIndex]);

				isParentHF = std::get<2>(timeSeries[timeSeriesIndex + 1]);
				isCurrentHF = std::get<2>(timeSeries[timeSeriesIndex]);

				//Special Blocks Support - BEGIN
				// Genesis Block Support - BEGIN
				if (parentBlockTime == 0 || parentDifficulty == 0)
				{
					timeInterval = targetBlockInterval;
					emaTimeBetweenBlocks = targetBlockInterval;
				}
				// Genesis Block Support- END
				//Hard Fork Block Support - BEGIN
				else if (parentBlockTime == 1 && parentDifficulty == 1)
				{
					//timeInterval =
				}
				//Hard Fork Block Support - END
				//Special Blocks Support - END

				// SECURITY - BEGIN
				if (currentBlockTime <= parentBlockTime)// BLOCK_N+1 was found to be in the past compared to BLOCK_N (this should never happen - under the strength of the
					// chain-proof validation algorithm).
				{/*
					We need to distinguish between two type of events:
					- a block being into the future when the current timestamp is involved (when calculating difficulty for new blocks being produced).
					- a block being into the future in past already verified blocks.

				   [10/26/23]: we introduce two mitigation strategies:
								[Strategy 1]: LOCAL, pro-active - we prevent GRIDNET Core from constructing blocks which are *into the past* (in relationship with parent) at all.
											   doing so would require a custom implementation.
								[Strategy 2]: GLOBAL, reactive - GRIDNET Core would not allow blocks (key-or-data) into the future as compared with its parent - at all.
				 */

				 //thus the below is not needed here under validity of the chain-proof validation algorithm.
				 //On the other hand it is needed later on, down below to protect against attackers who have mined blocks that reportedly are
				 //excessively into the future (compared to present moment).

					timeInterval =  static_cast<uint64_t>((double)CGlobalSecSettings::getTargetedBlockInterval() / CGlobalSecSettings::getPenaltyFactorForBlocksIntoTheFuture());
					/*This ensures difficulty sees almost no time, but does not “divide target interval by
					10”(or another large factor).Instead, you treat it as a 1 - second difference,
					which is still “fast, ” but not so punishing that it kills the entire network’s difficulty for hours.*/


				}// SECURITY - END
				else
				{
					//time interval between current pair
					timeInterval = currentBlockTime - parentBlockTime;//time interval between blocks in seconds.
				}

				if (isParentHF) {
					// Force the time interval to the target interval.
					timeInterval = CGlobalSecSettings::getTargetedBlockInterval();
				}

				summedSMATimeDiffs += timeInterval;// for reporting only. Calculate SMA of block intervals.


				//Calculates Exponential Moving Average Values (EMAs) - BEGIN

				// Notice: (it's just a step in a recursive computation sequence)

				//[General Rule]: EMAToday = (ValueToday * alpha) + (EMA_yesterday * (1-alpha))

				//EMA of time between blocks (calculated iteratively)
				emaTimeBetweenBlocks = ((timeInterval * alpha) + (emaTimeBetweenBlocks * (1 - alpha)));

				emaDifficulty = (currentDifficulty * alpha) + (emaDifficulty * (1 - alpha));
				//Calculates Exponential Moving Average Values (EMAs) - END

				sampledKeyBlocks++;

			}
		}
		else if (timeSeries.size() == 1)
		{
			emaTimeBetweenBlocks = targetBlockInterval;
			emaDifficulty = std::get<1>(timeSeries[0]);
		}
		// Storing the EMA values in settings for optimized retrieval next time.
		if (updateLIVECoefficients && !now)//notice only if 'now' not provided do we update these coefficients right now.
			//otherwise we wait for the computations to account for 'now'.
		{//IMPORTANT: the LIVE co-efficients need to be updated ONLY after a block affected the state-machine. ONLY. 
			//this is the only case in which 'updateLIVECoefficients' is allowed to be set to true and this function is then called by updateMinDifficultyCoefficients() with the current mLeader passed as first argument.
			std::lock_guard<std::recursive_mutex> lock(mDiffCoefficientsGuardian);
			mSettings->setEMATimeBetweenBlocks(emaTimeBetweenBlocks);//As far as time-between blocks is concerned, for difficulty adjustments, we need to store only this EMA value (not the SMA time between blocks).
			mSettings->setEMADifficultyCoefficient(emaDifficulty);
			//mSettings->setEMALastBlockIndex(blockIndex);//we store

		}
		// No Optimization - END
	}


	// Account for the current moment - BEGIN (OPTIONAL stage of [ PHASE 1 ])

		//[ Notice ]: 
		// We account for the current moment ('now') only when provided.
		// If not provided - we 'simply' update all of the coefficients. These might be then used during consecutive invocations in 'optimized' mode.

		// [ IMPORTANT 1 ]: only computation taking 'now' into account can be used for consensus purposes. That is because the difficulty needs
		// to continue dropping with each and every passing moment.

		// [ IMPORTANT 2 ]:
		// [Time is Relative]
		//	From the miner's perspective: 'now' is going to be the local system time (Unix Epoch).
		//	From the validator's perspective :'now' is to be the time-stamp injected within of the block currently being validated.

	if (now != 0 && currentBlock)/* Notice that 'block' at this point is the actual 'parent block'. During previous calculations in non - optimized mode
		'parentBlock' was always being recomputed to represent parent of the 'current block' -  during each iteration of the loop. */
	{
		/*The below is to be executed both for optimized and non - optimized modes when *minimum* difficulty for an anticipated next consecutive block to be mined at a
		predefined (by the 'now' timestamp) is to be computed.

		[IMPORTANT]: 'now' thus represents a time-stamp for a block which is to be mined.
		we need to ensure that the result of difficulty computation would be exactly the same as if it would be part of the block sequence.
		the difficulty computed in optimized and non optimized  modes need to be exactly the same.
		Since EMA is recursive we can pre-compute the time series up to 'now' and cache the resulting EMA.
		When 'optimizing' we would the simply account for 'now' by performing one additional EMA step on past EMA value.
		*/

		//[CAUTION]: proceed EXACTLY as in the former loop (i.e. as in the non 'optimized' run, without pre-cached values).
		parentBlockTime = currentBlock->getHeader()->getSolvedAtTime();
		currentBlockTime = now; //assume 'now' as the timestamp of a block which is 1) about to be produced 2) the PoW of which is to be verified.

		// Security - BEGIN
		if (!parentBlockTime || !currentBlockTime)
		{//[SECURITY]: do not account for blocks with a zero timestamp
			ok = false;
			return PROHIBITIVE_DIFFICULTY;
		}

		if (currentBlockTime < parentBlockTime)
		{
			timeInterval =  static_cast<uint64_t>((double)CGlobalSecSettings::getTargetedBlockInterval() / CGlobalSecSettings::getPenaltyFactorForBlocksIntoTheFuture());

			//currentBlockTime = parentBlockTime;//DO NOT assume 0 difficulty
			//IMPORTANT: block validation mechanics need only to allow for minimal time skew.
			//			 Yet still, a small time skew is allowed in 'both directions'.
			//			 If, a parent block is reported to be produced earlier than child
			//			 we simply assume these were produced at the very same moment (to avoid an overflow).

			//ok = false;
			//return PROHIBITIVE_DIFFICULTY;
		}
		else {
			// Security - END

			//time interval between members of the current pair
			timeInterval = currentBlockTime - parentBlockTime;//time interval between blocks in seconds
		}

		if (parentBlock->getHeader()->isHardForkBlock())
		{
			timeInterval = CGlobalSecSettings::getTargetedBlockInterval();
		}

		summedSMATimeDiffs += timeInterval;//for reporting only to calculate SMA of block intervals


		//Calculates Exponential Moving Average Values (EMAs) - BEGIN

		//[General Rule]: EMAToday = (ValueToday * alpha) + (EMA_yesterday * (1-alpha))
		//double difficultyNow = currentBlock->getHeader()->getDifficulty();
		//EMA of time between blocks (calculated iteratively)
		emaTimeBetweenBlocks = ((timeInterval * alpha) + (emaTimeBetweenBlocks * (1 - alpha)));
		//emaDifficulty = (difficultyNow * adjustedAlpha) + (emaDifficulty * (1 - adjustedAlpha));

		/* [Notice] : v----- 'emaDifficulty' is not computed in this case.
				emaDifficulty = (currentBlock->getHeader()->getDifficulty() * adjustedAlpha) + (emaDifficulty * (1 - adjustedAlpha));

				The logic here is that since the difficulty for this block isn't known yet (because that's what we're trying to compute),
				we shouldn't factor it into the EMA calculation.
		*/
		//Calculates EMAs - END


		//TODO: check the below--v
		if (updateLIVECoefficients)//used only by the Optimized (approximated) Mode.
		{	///Normally this would never happen and co-efficients would be updated earlier. As setLeader() calls this method with now set to 0.
			//there's never really a point in calling this function with both 'updateLIVECoefficients' and 'now' set.
			//IMPORTANT: the LIVE co-efficients need to be updated ONLY after a block affected the state-machine. ONLY. 
			//this is the only case in which 'updateLIVECoefficients' is allowed to be set to true and this function is then called by updateMinDifficultyCoefficients() with the current mLeader passed as first argument.
			std::lock_guard<std::recursive_mutex> lock(mDiffCoefficientsGuardian);
			mSettings->setEMATimeBetweenBlocks(emaTimeBetweenBlocks);//As far as time-between blocks is concerned, for difficulty adjustments, we need to store only this EMA value (not the SMA time between blocks).
			mSettings->setEMADifficultyCoefficient(emaDifficulty);
		}
	}
	else
	{//if the 'now' time-stamp was not provided we do calculations solely based on the available data of recorded blocks
		//currentDiff = emaDifficulty; *NO* - emaDifficulty is 'JUST' an exponentially averaged difficulty of previous blocks
		//EXTREMELY IMPORTANT: we NEED to take into account the EMA averaged(?) time as well between the consecutive blocks and adjust difficulty to match target block interval.
	}

	// Account for the current moment - END (OPTIONAL stage of [ PHASE 1 ])

	// [ PHASE 1 ] Compute Block Interval (seconds)  and Difficulty EMAs - END

	// [ PHASE 2 ] Difficulty Adjustment - BEGIN

	// Difficulty Adjustment - BEGIN
	if (emaTimeBetweenBlocks)
	{
		ok = true;
		currentDiff = emaDifficulty * (targetBlockInterval / emaTimeBetweenBlocks);

		// [ Security ]: enforce minimal difficulty equal to the initial Hard Fork difficulty.
		currentDiff = max(currentDiff, CGlobalSecSettings::getHardForkDifficulty());

	}
	else
	{
		//this should never happen. We check for Genesis Block earlier on.
		ok = false;
		currentDiff = PROHIBITIVE_DIFFICULTY;
	}
	/* [References]:
		1) targetTime -  a global constant.
		2) emaTimeBetweenBlocks - an either calculated or restored pre-computed value (in Optimized Mode).
		3) emaDifficulty  - either calculated or restored (in Optimized Mode).
		4) currentDiff - the unknown which it to be computed and returned.
	 */

	 // Difficulty Adjustment - END

	 // [ PHASE 2 ] Difficulty Adjustment - END

	 // [ PHASE 3 ] Reporting - BEGIN

	 //SMA Reporting - BEGIN
	 //IMPORTANT: SMA used solely for live-reporting purposes.
	if (!useOptimization)
	{
		if (sampledKeyBlocks == 0)
		{
			avrSMATimeBetweenBlocks = 0;
		}
		else {
			avrSMATimeBetweenBlocks = summedSMATimeDiffs / (parentBlock ? (sampledKeyBlocks + 1) : sampledKeyBlocks);//+1 to account for now
			setAverageSMAKeyBlockInterval(avrSMATimeBetweenBlocks);// this *SMA* value MUST NOT be used for difficulty adjustment purposes.
			//notice, the SMA value is NOT stored in Cold Storage. it would become available only after first invocation of this method in non-optimized mode.
		}
	}
	else
	{
		avrSMATimeBetweenBlocks = getAverageSMAKeyBlockInterval();
		avrSMATimeBetweenBlocks = ((avrSMATimeBetweenBlocks + timeInterval) / 2);
	}

	// [ PHASE 3 ] Reporting - END

	const_cast<uint64_t&>(SMA) = avrSMATimeBetweenBlocks;
	//SMA Reporting - END

	//EMA Reporting - BEGIN
	const_cast<uint64_t&>(EMA) = emaTimeBetweenBlocks;
	//EMA Reporting - END

	ok = true;
	return currentDiff;
	//Operational Logic - END
}

bool CBlockchainManager::blockFromHeader(std::vector<uint8_t> headerBytes, std::shared_ptr<CBlock>& block, bool instantiateTries)
{
	if (headerBytes.size() == 0)
		return false;

	CBlockHeader::eBlockHeaderInstantiationResult bhir;
	std::string err;
	std::shared_ptr<CBlockHeader> bh = CBlockHeader::instantiate(headerBytes, bhir, err, true, getMode());
	if (bh == nullptr)
		return false;
	return blockFromHeader(bh, block, instantiateTries);

}

bool CBlockchainManager::blockFromHeader(std::shared_ptr<CBlockHeader>& header, std::shared_ptr<CBlock>& block, bool instantiateTries)
{
	if (header == nullptr)
		return false;

	eBlockInstantiationResult::eBlockInstantiationResult bir;
	std::vector<uint8_t> id = header->getHash();
	if ((block = getBlockByHash(id, bir, instantiateTries)) != nullptr)
		return true;

	block = CBlock::newBlock(nullptr, bir, getMode(), header->isKeyBlock());
	block->setHeader(header);
	return true;

}

void CBlockchainManager::updateMinERGPrice()
{
	std::lock_guard<std::recursive_mutex> lock(mMinERGPriceGuardian);
	BigInt currentERGPrice = mLiveTransactionsManager->getAverageERGBid();
	getTools()->writeLine("Updating the current ERG price");
	mSettings->setSetMinNodeERGPrice(currentERGPrice);
}



std::vector<uint8_t> CBlockchainManager::getPerspective()
{
	std::lock_guard<std::recursive_mutex> lock(mLiveStateDBGuardian);
	return mLiveStateDB->getPerspective();
}

/// <summary>
/// Retrieves depth of the entire Blockchain Cache.
/// Notice: the returned depth of a chain with a single block is 1 (to indicate an empty cache with depth equal to 0 as one with no block at all thus as one with no leader).
///         However, when requesin block at depth 0 we get the latest block.
/// </summary>
/// <returns></returns>
uint64_t CBlockchainManager::getBlockCacheLength(bool optimize)
{
	// Local Variables - BEGIN
	std::shared_ptr<CBlock> deepestBlock = getDeepestBlockInCache();
	std::shared_ptr<CBlock> cachedLeader = getCachedLeader();
	// Local Variables - END

	// Operational Logic - BEGIN

	// Optimized Mode - BEGIN
	if (optimize && !cachedLeader)
	{
		return 0;
	}
	// Rationale: to eliminate iterative pointer traversal and to eliminate additional critical section usage.
	if (optimize && (cachedLeader && deepestBlock)) // can we optimize and is optimization even possible ?
	{
		return (cachedLeader->getHeader()->getHeight() - deepestBlock->getHeader()->getHeight()) + 1;
	}
	// Optimized Mode - END

	// Non Optimized Mode - BEGIN
	else
	{
		// Preliminaries - BEGIN
		// Notice: in RAM cache lock is required since the function employs kernel methods without additional mutex usage.
		// Use MemoryOrdered policy to prevent deadlocks
		sync::SynchronizedLocker lock(sync::LockingPolicy::MemoryOrdered, mChainGuardian, mLeaderGuardian);
		uint64_t depth = 0;
		std::shared_ptr<CBlock> currentTemp = mLeader;
		// Preliminaries - END

		if (!currentTemp)
		{
			return depth;
		}

		uint64_t depthTemp = 0;
		while ((currentTemp = currentTemp->getParentPtrK()))
		{
			depth++;
		}
		setDeepestBlockInCache(currentTemp);
		return depth + 1;
	}
	// Non Optimized Mode - END

	// Operational Logic - END
}


bool CBlockchainManager::prepareBlockTXMetaDataCache(uint32_t numThreads /* = 8 */)
{

	// Use MemoryOrdered policy to prevent deadlocks
	sync::SynchronizedLocker lock1(sync::LockingPolicy::MemoryOrdered, mCacheOperationGuardian, mChainGuardian, mLeaderGuardian);

	setIsBlockMetaDataAvailable(false);
	setIsTXMetaDataAvailable(false);
	// Lock guardians to ensure thread safety for shared resources


	// Pre-Flight Checks
	std::shared_ptr<CTools> tools = getTools();
	if (mLeader == nullptr)
	{
		tools->logEvent("Leader is unavailable, can't prepare the block TX meta-data cache", "Block TX Meta-Data Cache", eLogEntryCategory::localSystem, 10, eLogEntryType::failure);
		return false;
	}

	// Initialize local variables
	std::atomic<uint64_t> currentBlockCacheLength = 0;
	std::shared_ptr<CStatusBarHub> barHub = CStatusBarHub::getInstance();
	eBlockchainMode::eBlockchainMode mode = getMode();
	uint64_t barID = getCacheBarID();

	std::atomic<size_t> numberOfActiveThreads(0);
	constexpr size_t BLOCKS_PER_THREAD = 100;

	// Initialize progress tracking variables
	std::atomic<uint64_t> blocksProcessed(0);
	std::atomic<int> lastProgressValue(-1);
	std::atomic<uint64_t> lastReportAtTotalBlockCount(0);
	std::mutex progressMutex;

	// Log the start of meta-data cache preparation
	tools->logEvent("Preparing Block TX Meta-Data Cache...", "Block TX Meta-Data Cache");

	// Determine the total number of blocks in the blockchain
	std::shared_ptr<CBlock> leaderBlock = mLeader;
	if (leaderBlock == nullptr)
	{
		tools->logEvent("Unable to retrieve the leader block at depth 0", eLogEntryCategory::localSystem, 10, eLogEntryType::failure);
		return false;
	}

	uint64_t leaderHeight = leaderBlock->getHeader()->getHeight();
	uint64_t totalBlocksInChain = leaderHeight + 1; // Including genesis block at height 0

	// Collect depths to process for meta-data cache (from depth 0 upwards)
	std::vector<size_t> globalDepthsToProcess(totalBlocksInChain);
	for (size_t depth = 0; depth < totalBlocksInChain; ++depth)
	{
		globalDepthsToProcess[depth] = depth;
	}

	// Edge Case Handling: Ensure there is at least one block to process
	if (globalDepthsToProcess.empty())
	{
		tools->logEvent("No blocks to process for meta-data cache preparation", "Block TX Meta-Data Cache");
		barHub->invalidateCustomStatusBar(mode, barID);
		return true; // Nothing to do, but not an error
	}

	// Divide depths into chunks for threads
	size_t chunkSize = (globalDepthsToProcess.size() + numThreads - 1) / numThreads;
	std::vector<std::pair<size_t, size_t>> chunks;
	for (size_t i = 0; i < globalDepthsToProcess.size(); i += chunkSize)
	{
		size_t chunkStart = i;
		size_t chunkEnd = min(i + chunkSize, globalDepthsToProcess.size());
		chunks.emplace_back(std::make_pair(chunkStart, chunkEnd));
	}

	// Initialize thread EMAs for progress estimation
	std::mutex emaListMutex;
	std::vector<std::shared_ptr<ThreadTimeEstimation>> threadEmas;
	threadEmas.reserve(numThreads);
	for (uint32_t i = 0; i < numThreads; ++i) {
		threadEmas.emplace_back(std::make_shared<ThreadTimeEstimation>());
	}

	// Prepare to launch threads
	std::vector<std::future<void>> futures;
	std::mutex blockMutex;
	std::atomic<bool> valid(true);

	for (size_t threadIndex = 0; threadIndex < chunks.size(); ++threadIndex)
	{
		const auto& chunk = chunks[threadIndex];
		std::shared_ptr<ThreadTimeEstimation> threadEma;
		{
			std::lock_guard<std::mutex> lock(emaListMutex);
			threadEmas[threadIndex % threadEmas.size()] = threadEmas[threadIndex % threadEmas.size()];
			threadEma = threadEmas[threadIndex % threadEmas.size()];
		}

		futures.emplace_back(std::async(std::launch::async, [&, chunk, threadEma]() {
			ExclusiveWorkerAuthorization threadAuth(mChainGuardian);

			threadEma->lastReportTime = std::chrono::steady_clock::now();
			numberOfActiveThreads.fetch_add(1);

			FinalAction finally([&numberOfActiveThreads]() {
				numberOfActiveThreads.fetch_sub(1);
				});

			size_t threadBlocksProcessedSinceLastReport = 0;
			size_t chunkStart = chunk.first;
			size_t chunkEnd = chunk.second;

			auto threadStartTime = std::chrono::steady_clock::now();

			for (size_t idx = chunkStart; idx < chunkEnd; ++idx)
			{
				size_t depth = globalDepthsToProcess[idx];
				std::shared_ptr<CBlock> current;

				// Retrieve the block at the requested depth
				current = getBlockAtDepth(depth, false, eChainProof::verifiedCached); // re-use existing block cache

				if (current)
				{
					// Meta Data Cache - BEGIN
					std::shared_ptr<CBlockDesc> desc = createBlockDescription(current, true, true);
					current->setDescription(desc);
					// Meta Data Cache - END

				}
				else
				{
					tools->logEvent("Failed to retrieve block at depth " + std::to_string(depth),
						eLogEntryCategory::localSystem, 10, eLogEntryType::failure);
					valid.store(false);
					return;
				}

				// Update progress
				{
					std::lock_guard<std::mutex> lock(progressMutex);
					if ((blocksProcessed.load() - lastReportAtTotalBlockCount.load()) > CACHE_REPORT_EVERY_BLOCKS)
					{
						// Time-Left estimation
						auto now = std::chrono::steady_clock::now();
						lastReportAtTotalBlockCount.store(blocksProcessed.load());
						uint64_t processed = blocksProcessed.load();

						int progress = static_cast<int>((static_cast<double>(processed) / totalBlocksInChain) * 100);

						if (progress != lastProgressValue)
						{
							lastProgressValue = progress;

							// Aggregate EMAs from all threads
							double aggregatedEma = 0.0;
							size_t reportableThreadsCount = 0;
							{
								std::lock_guard<std::mutex> lock(emaListMutex);
								for (const auto& ema : threadEmas)
								{
									if (!ema->firstEstimation) {
										aggregatedEma += ema->emaBlocksPerSecond;
										++reportableThreadsCount;
									}
								}
							}

							reportableThreadsCount = min(numberOfActiveThreads.load(), reportableThreadsCount);
							double globalEma = (reportableThreadsCount > 0) ? (aggregatedEma / reportableThreadsCount) : 0.0;

							// Calculate ETA based on global EMA
							std::string timeLeftStr;
							if (globalEma > 0.0)
							{
								uint64_t remainingBlocks = totalBlocksInChain - processed;
								double estimatedRemainingSeconds = remainingBlocks / globalEma;
								timeLeftStr = mTools->secondsToFormattedString(static_cast<uint64_t>(estimatedRemainingSeconds));
							}
							else
							{
								timeLeftStr = "Calculating...";
							}

							// Prepare progress text
							std::ostringstream progressText;
							progressText << tools->getColoredString("[Block | TX ] Meta-Data Coverage: ", eColor::blue)
								<< tools->getColoredString(std::to_string(progress) + "% ", eColor::lightGreen)
								<< " ETA: " << tools->getColoredString(timeLeftStr, eColor::blue);

							barHub->setCustomStatusBarText(mode, barID, progressText.str());
						}
					}
				}

				// Increment blocksProcessed after processing a block
				blocksProcessed.fetch_add(1);
				threadBlocksProcessedSinceLastReport++;

				// Update thread-specific EMA
				auto threadEndTime = std::chrono::steady_clock::now();
				double timeElapsedSeconds = std::chrono::duration<double>(threadEndTime - threadStartTime).count();
				double timeSinceLastUpdateSeconds = std::chrono::duration<double>(threadEndTime - threadEma->lastReportTime).count();

				if (threadEma->firstEstimation || timeSinceLastUpdateSeconds >= MIN_TIME_INTERVAL_FOR_EMA_UPDATE)
				{
					if (threadBlocksProcessedSinceLastReport > 0) {
						threadEma->update(static_cast<double>(threadBlocksProcessedSinceLastReport), timeSinceLastUpdateSeconds);
						threadBlocksProcessedSinceLastReport = 0;
						threadEma->lastReportTime = threadEndTime;
					}
				}
			}
			}));
	}

	// Wait for all threads to finish
	for (auto& future : futures)
	{
		future.get();
	}

	// Check if any thread encountered an error
	if (!valid.load())
	{
		barHub->invalidateCustomStatusBar(mode, barID);
		return false;
	}

	// Invalidate progress bar
	barHub->invalidateCustomStatusBar(mode, barID);

	// Log final cache sizes
	tools->logEvent(
		tools->getColoredString("[Block TX Meta-Data Cache]: ", eColor::blue) +
		std::to_string(blocksProcessed.load()) + " blocks processed.",
		eLogEntryCategory::localSystem, 5
	);

	setIsBlockMetaDataAvailable(true);
	setIsTXMetaDataAvailable(true);

	return true;
}

/**
 * @brief Prepares an in-memory cache of blocks and optionally receipts.
 *
 * This method constructs a cache of blocks starting from the current leader
 * and moving towards the genesis block. Optionally, it also caches receipts
 * from these blocks. The caching process continues until either the genesis
 * block is reached, the maximum number of blocks to cache is reached, or
 * the receipts cache (if enabled) reaches 95% of its maximum size.
 *
 * @param PoWs A vector of cumulative Proof of Work values for each block.
 * @param cacheReceipts A boolean flag to enable or disable receipts caching.
 *
 * @return true if the caching process completed successfully, false otherwise.
 *
 * @throws std::runtime_error if critical errors occur during the caching process.
 *
 * @note This method is thread-safe, using locks on mChainGuardian and mLeaderGuardian.
 */
bool CBlockchainManager::prepareCache(bool cacheReceipts, const std::vector<uint64_t> PoWs)
{

	mTools->logEvent("Fallback to single-threaded cache preparation requested.", "Caching", eLogEntryCategory::localSystem, 8, eLogEntryType::warning);
	// Use MemoryOrdered policy to prevent deadlocks
	sync::SynchronizedLocker lock(sync::LockingPolicy::MemoryOrdered, mCacheOperationGuardian, mChainGuardian, mLeaderGuardian);

	//Pre-Flight - BEGIN
	std::shared_ptr<CTools> tools = getTools();
	if (mLeader == nullptr)
	{
		tools->logEvent("Leader is unavailable, can't prepare the block cache", "Block Cache", eLogEntryCategory::localSystem, 10, eLogEntryType::failure);
		return false;
	}
	//Pre-Flight - END

	//Local Variables - BEGIN
	uint64_t currentBlockCacheSize = 0;
	CReceipt rec(eBlockchainMode::LocalData);
	size_t recSizeEstimate = sizeof(rec) * 4;
	uint64_t currentReceiptsCacheSize = getReceiptsCacheSize();
	uint64_t maxReceiptsCacheSize = getMaxReceiptsCacheSize();
	bool powsAvailable = mLeader && (PoWs.size() > 0) && mLeader->getHeader()->getHeight() == PoWs.size() - 1;
	std::shared_ptr<CBlock> current = mLeader;
	eBlockInstantiationResult::eBlockInstantiationResult res;
	std::shared_ptr<CBlock> retrieved;
	uint64_t diffWindowSize = CGlobalSecSettings::getKeyBlockDiffWindowSize();
	uint64_t keyBlockInCache = 0;
	uint64_t depth = 0;
	uint64_t maxPrunedBlocksToKeep = max(getMaxNrOfPrunedBlocksToKeepInMemory(), diffWindowSize);
	std::shared_ptr<CStatusBarHub> barHub = CStatusBarHub::getInstance();
	eBlockchainMode::eBlockchainMode mode = getMode();
	uint64_t barID = getCacheBarID();
	uint64_t estimatedBlockCacheMemory = 0;
	uint64_t estimatedReceiptsCacheMemory = 0;
	uint64_t staticBlockSizeOverhead = sizeof(CBlock) + sizeof(CBlockHeader);
	//Local Variables - END
	uint64_t blockSizeBytes = 0;
	tools->logEvent("Preparing block" + std::string(cacheReceipts ? " and receipts " : " ") + "cache..", "Cache Preparation");

	//Operational Logic - BEGIN

	// Security Check - BEGIN
	if (!powsAvailable)
	{
		tools->logEvent("Unable to construct main cache since no PoW data available.", "Cache Preparation", eLogEntryCategory::localSystem, 10, eLogEntryType::failure, eColor::cyborgBlood);
		return false;
	}
	// Security Check - END

	if (cacheReceipts)
	{
		forceClearReceiptsCache();
	}

	bool continueReceiptsCaching = cacheReceipts;
	bool continueBlocksCaching = true;
	while (current != nullptr)
	{
		// Indexes Support - BEGIN

		if (continueBlocksCaching)
		{
			// Update Flat Cache - BEGIN

			eSetBlockCacheResult::eSetBlockCacheResult resCPR = setBlockFlatCache(current);

			if (!(eSetBlockCacheResult::Success || eSetBlockCacheResult::EmptyCacheSuccess))
			{
				std::stringstream ssCPR;
				ssCPR << "Unable to populate flat block cache at height ";
				ssCPR << std::to_string(mLeader ? mLeader->getHeader()->getHeight() : 0)
					<< " " << "Reason: " << mTools->blockCachingResultToString(resCPR);
				tools->logEvent(ssCPR.str(), "Leader Election", eLogEntryCategory::localSystem, 10, eLogEntryType::failure);
			}
			// Update Flat Cache - END
		}

		// Block-ID -> Block Height Index Support - BEGIN

		// Block-ID -> Block Height Index Support - END
		if (!addToBlockIDHeightMap(current->getID(), current->getHeader()->getHeight()))//  Flat block Index
		{
			tools->logEvent("Unable to populate the [Block ID] -> [Block Height] Index at height " + std::to_string(current->getHeader()->getHeight()), "Cache Population", eLogEntryCategory::localSystem, 10, eLogEntryType::failure);
			return false;
		}
		// Indexes Support - END

		if (current->isGenesis())
		{
			tools->logEvent("Reached genesis block. Cache preparation complete.", "Cache Preparation");
			break;
		}

		if (continueBlocksCaching)
		{
			//Parent Missing - BEGIN (optimization)
			if (!current->getParentPtr())
			{
				try
				{
					retrieved = mSolidStorage->getBlockByHash(current->getHeader()->getParentID(), res, true, blockSizeBytes);
					if (retrieved == nullptr)
					{
						throw std::runtime_error("Unable to retrieve block from Cold Storage");
					}
					current->setMainCacheMember(true);
					current->getHeader()->setParentPtr(retrieved);//towards Genesis Block
					retrieved->setNext(current);//towards recent blocks
					current = retrieved;

					// Meta Data Cache - BEGIN
					std::shared_ptr<CBlockDesc> desc = createBlockDescription(current, true, true);
					//   ^--- updates global TX cache
					current->setDescription(desc); // affix Block meta-data onto the block
					// Meta Data Cache - END
				}
				catch (const std::exception& e)
				{
					tools->logEvent("Error during block retrieval: " + std::string(e.what()), eLogEntryCategory::localSystem, 10, eLogEntryType::failure);
					return false;
				}
			}
			else
			{
				current = current->getParentPtr();
			}
			//Parent Missing - END
		}

		// Proof-of-Work Difficulty - BEGIN

		if (powsAvailable)
		{
			if (depth < PoWs.size())
			{
				current->getHeader()->setTotalDiffField(PoWs[PoWs.size() - (depth + 1)]);
			}
			else
			{
				tools->logEvent("Warning: PoW data exhausted before reaching genesis block", eLogEntryCategory::localSystem, 5, eLogEntryType::warning);
				powsAvailable = false;
			}
		}
		// Proof-of-Work Difficulty - END

		// Block Cache Logic - BEGIN
		if (continueBlocksCaching && (currentBlockCacheSize <= maxPrunedBlocksToKeep))
		{
			currentBlockCacheSize++;
			estimatedBlockCacheMemory += (blockSizeBytes + staticBlockSizeOverhead); // Rough estimate
			if (current->getHeader()->isKeyBlock())
			{
				keyBlockInCache++;
				//if (keyBlockInCache >= diffWindowSize)
				////{
				//	tools->logEvent("Reached required number of key blocks in cache", "Block Cache");
				//	break;
				//}
			}
		}
		else if (continueBlocksCaching)
		{
			continueBlocksCaching = false;
			setDeepestBlockInCache(current);
		}

		// Block Cache Logic - END

		// Receipts Cache Logic - BEGIN
		if (continueReceiptsCaching)
		{
			std::vector<CReceipt> blockReceipts = current->getReceipts();
			for (const auto& receipt : blockReceipts)
			{
				if (currentReceiptsCacheSize >= 0.95 * maxReceiptsCacheSize)
				{
					continueReceiptsCaching = false;
					tools->logEvent("Receipts cache reached 95% capacity", "Receipts Cache");
					break;
				}
				try
				{
					std::shared_ptr<CReceipt> receiptPtr = std::make_shared<CReceipt>(receipt);
					receiptPtr->setBlockInfo(current); //to maintain block height
					addReceiptToHotCache(receiptPtr);
					currentReceiptsCacheSize = getReceiptsCacheSize();
					estimatedReceiptsCacheMemory += recSizeEstimate; // Rough estimate
				}
				catch (const std::exception& e)
				{
					tools->logEvent("Error adding receipt to cache: " + std::string(e.what()), eLogEntryCategory::localSystem, 5, eLogEntryType::warning);
				}
			}
		}
		// Receipts Cache Logic - END

		// Progress Reporting - BEGIN
		double blockProgress = (double)currentBlockCacheSize / (double)maxPrunedBlocksToKeep * 100.0;
		double receiptsProgress = cacheReceipts ? (double)currentReceiptsCacheSize / (double)maxReceiptsCacheSize * 100.0 : 0.0;

		std::string memoryUnitBlock = (estimatedBlockCacheMemory >= BYTES_PER_MEGABYTE) ? "MB" : "KB";
		double blockMemory = (memoryUnitBlock == "MB") ? estimatedBlockCacheMemory / static_cast<double>(BYTES_PER_MEGABYTE) : estimatedBlockCacheMemory / 1024.0;

		std::string memoryUnitReceipts = (estimatedReceiptsCacheMemory >= BYTES_PER_MEGABYTE) ? "MB" : "KB";
		double receiptsMemory = (memoryUnitReceipts == "MB") ? estimatedReceiptsCacheMemory / static_cast<double>(BYTES_PER_MEGABYTE) : estimatedReceiptsCacheMemory / 1024.0;

		std::string progressText = tools->getColoredString("Blocks: ", eColor::blue) +
			tools->getColoredString(tools->to_string_with_precision(blockProgress, 2) + "% ", eColor::lightCyan) +
			tools->getColoredString("(" + tools->to_string_with_precision(blockMemory, 2) + " " + memoryUnitBlock + ") ", eColor::lightCyan);

		if (cacheReceipts)
		{
			progressText += tools->getColoredString("Receipts: ", eColor::orange) +
				tools->getColoredString(tools->to_string_with_precision(receiptsProgress, 2) + "% ", eColor::lightGreen) +
				tools->getColoredString("(" + tools->to_string_with_precision(receiptsMemory, 2) + " " + memoryUnitReceipts + ")", eColor::lightGreen);
		}

		barHub->setCustomStatusBarText(mode, barID, progressText);
		// Progress Reporting - END

		depth++;
	}
	barHub->invalidateCustomStatusBar(mode, barID);
	//Operational Logic - END

	tools->logEvent(tools->getColoredString("[Blockchain Cache Length]: ", eColor::blue) + std::to_string(currentBlockCacheSize), eLogEntryCategory::localSystem, 5);
	if (cacheReceipts)
	{
		tools->logEvent(tools->getColoredString("[Receipts Cache Size]: ", eColor::lightCyan) + std::to_string(currentReceiptsCacheSize) + " bytes", eLogEntryCategory::localSystem, 5);
	}

	return true;
}

bool CBlockchainManager::prepareCacheMT(bool cacheReceipts, const std::vector<uint64_t>& PoWs, bool flashCurrentCount /*= false*/, uint32_t numThreads /* = 8 */, std::shared_ptr<ThreadPool> threadPool /* = nullptr */)
{
	// Use MemoryOrdered policy to prevent deadlocks
	sync::SynchronizedLocker lock1(sync::LockingPolicy::MemoryOrdered, mCacheOperationGuardian, mChainGuardian, mLeaderGuardian);

	// Lock guardians to ensure thread safety for shared resources

	// Optimisation - BEGIN
	// Rationale: to omit cache preparation whenever not needed.
	// Assumptions: - new leader is appended to Hot Storage two-way connected list as soon as it's processed by setLeader() 
	//            - new leader is set in Flat Cache at same moment
	//            - receipts are also stored in dedicated cache as part of setLeader()
	// 
	// When Needed: - whenever chain is reorganized (soft-fork). We would know because setLeader() would wipe out all caches when this occurs. 
	//            - which is when the optimization logic below would not triger.
	uint64_t currentCacheLength = getBlockCacheLength();
	uint64_t currentCacheDepth = currentCacheLength ? (currentCacheLength - 1) : 0;
	uint64_t realDepth = getDepth();
	if (currentCacheDepth >= getMaxOverallBlocksToKeepInMemory() || (currentCacheDepth == realDepth))// no need to rebuild cache if not more data could be cached anyway.
	{//notice that Receipts cache and indexes are also updates once each block gets processed. Full cache rebuild seldomly is expected as needed.
		return true;
	}
	// Optimisation - END

	/*
			[ Definitions ]
			A block - a data structure building a blockchain each block has a height (counting from the Genesis Block) so also a depth (when counting from current leading, latest bock). Block at depth 0 represents current leading block
			A Chunk - an ordered set (a sequence) of block depths which are to be processed by a single thread during processing of a batch.
			A Batch - an ordered set (a sequence) of chunks. The size of a batch depends on CPU capabilities (the number of CPU cores). The number of active threads which are allowed for processing is provided throguh numThreads.


			[ Final Products ]
			 - A two-way connected list of blockchain blocks which are to comprise a blockchain cache.
			 - An in-RAM cache of Receipts.

			[ Means ]
			Batches are scheduled on demand. When one batch is finished another one is scheduled until the entire blockchain has been cached in RAM or limits reached.
			Results of batch and thus chunk processing need to be combined so to form a two-way connected list. This holds for inner- and inter- batch/chunk links.
			The cache of receipts may continue to be built long after the limits of blockchain cache have been exceeded.
	*/

	// Pre-Flight Checks
	std::shared_ptr<CTools> tools = getTools();
	if (mLeader == nullptr)
	{
		tools->logEvent("Leader is unavailable, can't prepare the block cache", "Block Cache", eLogEntryCategory::localSystem, 10, eLogEntryType::failure);
		return false;
	}

	// Local Variables Initialization
	std::atomic <uint64_t> currentBlockCacheLength = 0;
	uint64_t blockStaticSizeOverhead = sizeof(CBlock) + sizeof(CBlockHeader);
	uint64_t receiptStaticSizeOverhead = sizeof(CReceipt);
	uint64_t currentReceiptsCacheSize = getReceiptsCacheSize();

	// Cache Size Limits - BEGIN

	// Hot-Storage (RAM) memory limits - BEGIN
	uint64_t maxReceiptsCacheSize = getMaxReceiptsCacheSize();
	uint64_t maxBlockchainCacheSize = getMaxBlockchainCacheSize();
	// Hot-Storage (RAM) memory limits - END

	// Quantity Limits - BEGIN
	uint64_t maxFullBlocksToKeep = getMaxNrOfFullBlocksToKeepInMemory();
	uint64_t maxPrunedBlocksToKeep = getMaxNrOfPrunedBlocksToKeepInMemory();
	uint64_t maxOverallBlockCacheLengthLimit = getMaxOverallBlocksToKeepInMemory();
	std::atomic<uint64_t> currentFullBlocksInMemory = 0;
	std::atomic<uint64_t> currentPrunedlBlocksInMemory = 0;
	// Quantity Limits - END
	// How many blocks to keep - END

	// Cache Size Limits - END

	bool powsAvailable = mLeader && !PoWs.empty() && mLeader->getHeader()->getHeight() == PoWs.size() - 1;
	uint64_t diffWindowSize = CGlobalSecSettings::getKeyBlockDiffWindowSize();
	std::atomic<uint64_t> keyBlockInCache(0);
	std::shared_ptr<CStatusBarHub> barHub = CStatusBarHub::getInstance();
	eBlockchainMode::eBlockchainMode mode = getMode();
	uint64_t barID = getCacheBarID();
	bool isFirstBatch = true;
	std::atomic<uint64_t> estimatedBlockCacheMemory(0);
	std::atomic<uint64_t> estimatedReceiptsCacheMemory(0);
	std::atomic<bool> continueReceiptsCaching = cacheReceipts;
	std::atomic<bool> isBootstrapSequence = getIsReady();;
	std::atomic<uint64_t>  lastReportAtTotalBlockCount = 0;
	auto startTime = std::chrono::steady_clock::now();
	std::atomic<size_t> numberOfActiveThreads(0);

	// Constants for EMA calculation
	constexpr double ALPHA = 0.2;
	constexpr double MILLISECONDS_PER_SECOND = 1000.0;
	constexpr uint64_t BLOCKS_PER_THREAD = 100;

	// Variables for EMA calculation
	std::mutex emaListMutex;
	std::vector<std::shared_ptr<ThreadTimeEstimation>> threadEmas;
	{
		std::lock_guard<std::mutex> lock(emaListMutex);
		threadEmas.reserve(numThreads);
		for (uint32_t i = 0; i < numThreads; ++i) {
			threadEmas.emplace_back(std::make_shared<ThreadTimeEstimation>());
		}
	}

	// Progress Reporting Variables 
	std::atomic<uint64_t> blocksProcessed(0);
	std::atomic<int> lastProgressValue(-1);
	std::atomic<uint64_t> lastReportTime(0);
	std::atomic<uint64_t> lastReportedBlockCount(0);
	std::mutex progressMutex;

	// Log the start of cache preparation
	tools->logEvent("Preparing block" + std::string(cacheReceipts ? " and receipts " : " ") + "cache...", "Cache Preparation");

	// Clear Receipts Cache if needed
	if (cacheReceipts)
	{
		forceClearReceiptsCache();
	}

	// Determine the total number of blocks in the blockchain
	std::shared_ptr<CBlock> leaderBlock = mLeader; // IMPORTANT: the current leader MUST prevail. Read on.

	/* [ Memory Leak Sensitive Area ]
	* Even though smart-pointers are in use throughout this code, the area of blockchain cache maintenance is extremely sensitive to memory leaks.
	* The main reasoon is a two-way shared-pointer (not weak-pointer) relationship between parent and an immediate offspring.
	* If by an accident we replace one node in a sequence with a new one, the remaining zombie tail of the prior cache would remain in memory indefinitely.
	*
	Thus,
	1) the current leader MUST prevail. Otherwise we would be creating a detached cache. Which due to being a two connected list would utlimately result in a massive memory leak.
	2)
	*/
	if (leaderBlock == nullptr)
	{
		tools->logEvent("Unable to retrieve the leader block at depth 0", eLogEntryCategory::localSystem, 10, eLogEntryType::failure);
		return false;
	}
	markBlockLocalAvailability(leaderBlock->getID());

	uint64_t leaderHeight = leaderBlock->getHeader()->getHeight();
	uint64_t totalBlocksInChain = leaderHeight + 1; // Including genesis block at height 0

	// Limit the amount of blocks to cache based on maxPrunedBlocksToKeep
	uint64_t blocksToCache = min(totalBlocksInChain, maxOverallBlockCacheLengthLimit);

	// Collect depths to process for block cache (from depth 0 upwards)
	std::vector<size_t> globalDepthsToProcess;
	for (size_t depth = 0; depth < blocksToCache; ++depth)
	{
		globalDepthsToProcess.push_back(depth);
	}

	// Edge Case Handling: Ensure there is at least one block to process
	if (globalDepthsToProcess.empty())
	{
		tools->logEvent("No blocks to process for cache preparation", "Cache Preparation");
		barHub->invalidateCustomStatusBar(mode, barID);
		return true; // Nothing to do, but not an error
	}

	// Prepare vector to store blocks
	// Notice: there's also batchBlocks vector for storing blocks in scope of a single batch. 
	std::vector<std::shared_ptr<CBlock>> blocks(0);//This creates an empty vector, which is correct as we'll be adding to it incrementally.
	blocks.reserve(blocksToCache); // we can pre-allocate blocks to the expected size.

	// Prepare per-thread results
	std::vector<std::future<void>> futures; // to store threads responsible for processing of CHUNKS. At any given time there would be at least 1 chunk processed by at least a single thread (future).
	// all these chunks (threads) are part of a single processing BATCH. Thus always at least a single chunk is part of a SINGLE batch.
	std::mutex blockMutex; // For updating shared variables

	// Check if we need to create our own thread pool
	bool ownThreadPool = false;
	if (!threadPool) {
		threadPool = std::make_shared<ThreadPool>(numThreads, numThreads, numThreads);
		ownThreadPool = true;
	}

	// Phase 1-A: Retrieve Blocks and Process Receipts in Parallel.
	uint64_t currentGlobalDepth = 0;
	std::atomic<bool> valid(true);

	std::shared_ptr<CBlock> lastBatchFinalBlock; // store the last (deepest) block which was processed by latest BATCH - so that we can connect two consecutive BATCHES during Phase 1-B.

	// [ WARNING ]: the amount of blocks IS ALLOWED to be little more than dictated by limits.
	//            We do not want individual threads to abort abruptly once limits reached since the thread aborting might be the one with blocks in the middle which would overcomplicate things (implying a need for a rollback of partial results).
	//            While respecting blockchain-length limits on per block and per-thread basis is trivial, it is not so for their size in bytes.
	while (currentBlockCacheLength.load() < maxOverallBlockCacheLengthLimit && // enforce overall blockchain-cache length limits.
		estimatedBlockCacheMemory.load() < maxBlockchainCacheSize && // enforce blockchain-cache storage limits ( in bytes ).
		currentPrunedlBlocksInMemory.load() < maxPrunedBlocksToKeep && // enforce full-blocks limit (quantity).
		//currentFullBlocksInMemory.load() < maxFullBlocksToKeep &&// enforce pruned-blocks limit (quantity).
		currentGlobalDepth < totalBlocksInChain)
	{
		uint64_t batchGlobalOffset = currentBlockCacheLength; // corresponds to the amount of blocks which have been already processed (as otherwise these would not be part of cache).
		uint64_t globalBlocksLeft = (totalBlocksInChain - currentBlockCacheLength); // corresponds to the amount of blocks which are left to be processed (but might not due to limits).

		// Divide depths into chunks for unitary threads.
		size_t totalBlocksInCurrentBatch = globalDepthsToProcess.size(); // Notice: a single batch has POSSIBLY multiple chunks (always tending towards 0 with time(. A single chunk is processed by a single thread (a Future).

		// Determine the number of blocks to process in this batch (a batch has multiple chunks and a single chunk has multiple blocks).
		size_t batchSize = min(numThreads * BLOCKS_PER_THREAD, totalBlocksInChain - currentBlockCacheLength.load(), static_cast<size_t>(maxOverallBlockCacheLengthLimit - currentBlockCacheLength.load())); // Adjust batch size as needed (the combined number of blocks to be processed by all threads).

		std::vector<size_t> depthsToProcessInBatch;// each depth and thus each block has its own entry on the list

		size_t endDepth = min(currentGlobalDepth + batchSize, totalBlocksInChain);
		for (size_t i = currentGlobalDepth; i < endDepth; ++i)
		{
			depthsToProcessInBatch.push_back(i);
		}

		if (depthsToProcessInBatch.empty())
		{
			break; // No more blocks to process
		}

		// Prepare vector to store blocks for this batch
		std::vector<std::shared_ptr<CBlock>> batchBlocks(depthsToProcessInBatch.size()); // This correctly pre-allocates the exact size needed for the batch.
		// Notice: batchBlocks[0] - the first block which is to be processed as part of the current batch. The depth of this block corresponds to depthsToProcessInBatch[0].
		//                       The global depth of block at batchBlocks[0]  (referring to the entire blockchain) is depthsToProcessInBatch[0]+batchGlobalOffset. 

		// Account For Existing Blocks In Cache - BEGIN
		for (size_t idx = 0; idx < depthsToProcessInBatch.size(); ++idx)
		{
			size_t requestedBlockDepth = depthsToProcessInBatch[idx];

			// Try to retrieve the block from the flat cache
			std::shared_ptr<CBlock> cachedBlock = getBlockFlatCache(requestedBlockDepth, true, false);

			if (cachedBlock)
			{
				// The block is already present in the cache.
				batchBlocks[idx] = cachedBlock;
			}
			else if (requestedBlockDepth == 0)
			{
				// Handle leaderBlock explicitly
				batchBlocks[idx] = leaderBlock;
			}
			else
			{
				// The block is not in the cache; leave all following blocks in batchBlocks as nullptr.
				// These will be handled later when fetching from cold storage.
				break; // Stop assigning blocks (from Hot Storage).
			}
		}
		// Account For Existing Blocks In Cache - END

		// Divide depths into chunks for threads
		size_t chunkSize = (depthsToProcessInBatch.size() + numThreads - 1) / numThreads;
		std::vector<std::pair<size_t, size_t>> batchLocalChunks;// IMPORTANT: pairs of INDICES describing sub-arrays to an array of depths (not depths themselves).
		size_t batchStart = 0;
		if (depthsToProcessInBatch.size())
		{
			batchStart = depthsToProcessInBatch[0];
		}

		if (batchGlobalOffset != batchStart)
		{
			return false;
		}

		// define batch-local chunks
		for (size_t i = 0; i < depthsToProcessInBatch.size(); i += chunkSize)
		{
			size_t chunkStart = i; // WARNING: chunkStart is thus an index to an array of depths (not a depth in itself).
			size_t chunkEnd = min(i + chunkSize, depthsToProcessInBatch.size()); // WARNING: chunkEnd is thus an index to an array of depths (not a depth in itself).
			batchLocalChunks.push_back(std::make_pair(chunkStart, chunkEnd));
		}

		// Process blocks in parallel using thread pool
		std::vector<std::future<void>> futures;
		futures.reserve(batchLocalChunks.size());

		for (size_t threadIndex = 0; threadIndex < batchLocalChunks.size(); ++threadIndex)
		{
			const auto& chunk = batchLocalChunks[threadIndex];// each thread has a single chunk
			std::shared_ptr<ThreadTimeEstimation> threadEma;
			{
				std::lock_guard<std::mutex> lock(emaListMutex);
				threadEma = threadEmas[threadIndex % threadEmas.size()];
			}

			// Create worker task for thread pool
			auto workerTask = [&, chunk, threadEma, batchStart]() {
				ExclusiveWorkerAuthorization threadAuth(mChainGuardian);
				ExclusiveWorkerAuthorization threadAuth2(mVerifiedPathDoubleGuardian); // needed by getBlockAtDepthSSDirect()

				threadEma->lastReportTime = std::chrono::steady_clock::now();
				// Thread Stats - BEGIN
				numberOfActiveThreads.fetch_add(1); // notify about a new active thread

				FinalAction finally([&numberOfActiveThreads]() {
					numberOfActiveThreads.fetch_sub(1); // as soon as thread finishes processing decrement the number of active threads
					});
				// Thread Stats - END

				// Thread Local Variables - BEGIN
				size_t threadBlocksProcessedSinceLastReport = 0;
				size_t chunkStart = chunk.first; // chunkStart is an index to depthsToProcessInBatch array of depths (not a depth in itself).
				size_t chunkEnd = chunk.second;  // chunkEnd is thus an index to depthsToProcessInBatch array of depths (not a depth in itself).
				// Track time for this chunk
				auto threadStartTime = std::chrono::steady_clock::now();
				uint64_t blockSizeBytes = 0;
				// Thread Local Variables - END

				// block processing loop
				bool isBoot = !isBootstrapSequence.load();// we continue loading unfolded MPTs during bootstrap sequence so to maximise performance 
														 // of cache preparations. Cache cleaning would trigger once all multi level meta data caches are ready.
				for (size_t idx = chunkStart; idx < chunkEnd; ++idx)// chunkStart is a starting *GLOBAL (relative to the entire blockchain)* DEPTH for a CHUNK and so, initially, is idx.
				{                                                    // idx thus tends towards final depth to be processed as part of this CHUNK.

					bool instantiateTrees = (isBoot || continueReceiptsCaching.load()); // whether we even need to unfold Merkle Patricia Tries from Cold Storage - needed for Receipts cache preparation.
					bool storeUnfolded = (isBoot || !(currentBlockCacheLength.load() > maxFullBlocksToKeep)); // even if Merkle Tries unfolded we would prune these if not to be stored, as soon as Receipts processed.

					std::shared_ptr<CBlock> current;

					// Single Block Processing - BEGIN
					size_t requestedBlockDepth = depthsToProcessInBatch[idx]; // read-only on depthsToProcessInBatch until all threads are finished thus no synchronisation on depthsToProcessInBatch is needed.

					if (requestedBlockDepth == 0)
					{
						current = leaderBlock; // let the current leader prevail
					}
					else
					{
						//  idx - an index to depthsToProcessInBatch

						if (batchBlocks[idx]) // read only on batchBlocks - no synchronisation needed.
						{// the block is already present in cache.
							current = batchBlocks[idx];
						}
						else
						{// the block is NOT already present in cache.
							// retrieve block at the requested depth.
							current = getBlockAtDepthSSDirect(requestedBlockDepth, eChainProof::verifiedCached, instantiateTrees, blockSizeBytes);// it's correct to use requestedBlockDepth as the function gets real global depth (not in relation to chunk or batch but to global blockchain instead).
							if (current)
							{
								batchBlocks[idx] = current; // all these blocks from batchBlocks would need to be connected with each other in Phase 1-B.
							}
							else
							{
								tools->logEvent("Failed to retrieve block at depth " + std::to_string(requestedBlockDepth),
									eLogEntryCategory::localSystem, 10, eLogEntryType::failure);
								valid.store(false);
								return;
							}
						}
					}

					// block availability cache - BEGIN
					markBlockLocalAvailability(current->getID());

					// block availability cache - END

					// Cumulative Proof-of-Work Support - BEGIN
					// Notice: this requires an external data structured (PoWs) which gets computed during local Verified Chain-Proof analysis.
					// Set total difficulty field if PoWs are available
					if (powsAvailable)
					{
						uint64_t height = current->getHeader()->getHeight();
						if (height < PoWs.size())
						{
							current->getHeader()->setTotalDiffField(PoWs[height]);
						}
						else
						{
							tools->logEvent("Warning: PoW data exhausted before reaching genesis block", eLogEntryCategory::localSystem, 5, eLogEntryType::warning);
							powsAvailable = false;
						}
					}
					// Cumulative Proof-of-Work Support - END

					// Accountability - BEGIN
					if (current)
					{
						if (instantiateTrees)
						{
							currentFullBlocksInMemory.fetch_add(1);
						}
						else
						{
							currentPrunedlBlocksInMemory.fetch_add(1);
						}
					}

					// Block Cache Logic
					{
						std::lock_guard<std::mutex> lock(blockMutex);
						currentBlockCacheLength.fetch_add(1);
						estimatedBlockCacheMemory += ((instantiateTrees ? blockSizeBytes : 0) + blockStaticSizeOverhead);

						if (current->getHeader()->isKeyBlock())
						{
							keyBlockInCache.fetch_add(1);
						}
					}

					// Accountability - END

					// Receipts Cache Logic
					if (continueReceiptsCaching.load())
					{
						std::vector<CReceipt> blockReceipts = current->getReceipts();
						for (const auto& receipt : blockReceipts)
						{
							if (currentReceiptsCacheSize >= maxReceiptsCacheSize)
							{
								continueReceiptsCaching.store(false);
								tools->logEvent("Receipts cache reached 100% capacity", "Receipts Cache");
								break;
							}
							try
							{
								std::shared_ptr<CReceipt> receiptPtr = std::make_shared<CReceipt>(receipt);
								receiptPtr->setBlockInfo(current); //to maintain block height
								addReceiptToHotCache(receiptPtr);
								currentReceiptsCacheSize = getReceiptsCacheSize();
								estimatedReceiptsCacheMemory += receiptStaticSizeOverhead + receipt.getLogSize() + (32 * 4); // Rough estimate
							}
							catch (const std::exception& e)
							{
								tools->logEvent("Error adding receipt to cache: " + std::string(e.what()), eLogEntryCategory::localSystem, 5, eLogEntryType::warning);
							}
						}
					}

					if (!storeUnfolded)
					{
						// only pruned block to be stored in cache
						// prune Merkle Patricia Tries if these are not to be cached
						current->getHeader()->freeTries(); // unload Merkle Patricia Tries since these are to be needed no more.
					}

					// Update progress - Phase 1 - BEGIN
					{ // CRITICAL SECTION - BEGIN
						std::lock_guard<std::mutex> lock(progressMutex); // read on multiple atomic variables requires a mutex

						if (flashCurrentCount && (blocksProcessed.load() - lastReportAtTotalBlockCount.load()) > CACHE_REPORT_EVERY_BLOCKS)
						{
							// Time-Left estimation - BEGIN
							auto now = std::chrono::steady_clock::now();
							lastReportAtTotalBlockCount.store(blocksProcessed.load());
							uint64_t processed = blocksProcessed.load();

							// In Phase 1, the time left should be based on the maximum number of blocks that can be contained or the total blockchain size if it's smaller.
							uint64_t total = min(totalBlocksInChain, maxPrunedBlocksToKeep);

							int progress = static_cast<int>((static_cast<double>(processed) / total) * 100);

							if (progress != lastProgressValue)
							{
								lastProgressValue = progress;

								// Aggregate EMAs from all threads
								double aggregatedEma = 0.0;
								size_t reportableThreadsCount = 0;
								{
									std::lock_guard<std::mutex> lock(emaListMutex);
									for (const auto& ema : threadEmas)
									{
										if (!ema->firstEstimation) { // Only include threads that have started estimation
											aggregatedEma += ema->emaBlocksPerSecond;
											++reportableThreadsCount;
										}
									}
								}

								reportableThreadsCount = min(numberOfActiveThreads.load(), reportableThreadsCount);// do not include threads that have finished execution

								double globalEma = (reportableThreadsCount > 0) ? (aggregatedEma / reportableThreadsCount) : 0.0;

								// Calculate ETA based on global EMA
								std::string timeLeftStr;
								if (globalEma > 0.0)
								{
									uint64_t remainingBlocks = blocksToCache - processed;
									double estimatedRemainingSeconds = remainingBlocks / globalEma;
									timeLeftStr = mTools->secondsToFormattedString(static_cast<uint64_t>(estimatedRemainingSeconds));
								}
								else
								{
									timeLeftStr = "Calculating...";
								}
								// Time-Left estimation - END

								// Compute estimated memory usage for blocks
								std::string memoryUnitBlock = (estimatedBlockCacheMemory.load() >= BYTES_PER_MEGABYTE) ? "MB" : "KB";
								double blockMemory = (memoryUnitBlock == "MB") ? estimatedBlockCacheMemory.load() / static_cast<double>(BYTES_PER_MEGABYTE) : estimatedBlockCacheMemory.load() / static_cast<double>(BYTES_PER_KILOBYTE);
								double blockCacheUsagePercentage = (double)currentBlockCacheLength.load() / (double)maxPrunedBlocksToKeep * 100.0;
								uint64_t blockCacheAvailablePercentage = 100 - static_cast<uint64_t>(blockCacheUsagePercentage);

								// Compute estimated memory usage for receipts
								std::string memoryUnitReceipts = (estimatedReceiptsCacheMemory.load() >= BYTES_PER_MEGABYTE) ? "MB" : "KB";
								double receiptsMemory = (memoryUnitReceipts == "MB") ? estimatedReceiptsCacheMemory.load() / static_cast<double>(BYTES_PER_MEGABYTE) : estimatedReceiptsCacheMemory.load() / static_cast<double>(BYTES_PER_KILOBYTE);
								double receiptsProgress = (double)currentReceiptsCacheSize / (double)maxReceiptsCacheSize * 100.0;
								uint64_t receiptsCacheAvailablePercentage = 100 - static_cast<uint64_t>(receiptsProgress);

								std::ostringstream progressText;

								// Coverage color
								eColor::eColor coverageColor;
								if (progress >= 90) coverageColor = eColor::lightCyan;
								else if (progress >= 70) coverageColor = eColor::lightGreen;
								else if (progress >= 50) coverageColor = eColor::orange;
								else if (progress >= 30) coverageColor = eColor::cyberWine;
								else if (progress >= 10) coverageColor = eColor::lightPink;
								else coverageColor = eColor::cyborgBlood;

								progressText << tools->getColoredString("[ Block" + std::string(cacheReceipts ? " | Receipts ]" : " ]") +
									"Coverage: ", eColor::blue)
									<< tools->getColoredString(tools->to_string_with_precision(progress, 3) + "% ", coverageColor);

								// Block cache color
								eColor::eColor blockCacheColor;
								if (blockCacheAvailablePercentage >= 50) blockCacheColor = eColor::lightCyan;
								else if (blockCacheAvailablePercentage >= 30) blockCacheColor = eColor::lightGreen;
								else if (blockCacheAvailablePercentage >= 20) blockCacheColor = eColor::orange;
								else if (blockCacheAvailablePercentage >= 10) blockCacheColor = eColor::cyberWine;
								else if (blockCacheAvailablePercentage >= 5) blockCacheColor = eColor::lightPink;
								else blockCacheColor = eColor::cyborgBlood;

								progressText << tools->getColoredString("[Blocks]: ", eColor::blue)
									<< tools->getColoredString("(" + tools->to_string_with_precision(blockMemory, 3) + " " + memoryUnitBlock + ") ", blockCacheColor)
									<< tools->getColoredString(tools->to_string_with_precision(blockCacheAvailablePercentage, 3) + "% Free ", blockCacheColor)
									<< " ETA: " << tools->getColoredString(timeLeftStr, eColor::blue);

								if (cacheReceipts)
								{
									// Receipts cache color
									eColor::eColor receiptsCacheColor;
									if (receiptsCacheAvailablePercentage >= 50) receiptsCacheColor = eColor::lightCyan;
									else if (receiptsCacheAvailablePercentage >= 30) receiptsCacheColor = eColor::lightGreen;
									else if (receiptsCacheAvailablePercentage >= 20) receiptsCacheColor = eColor::orange;
									else if (receiptsCacheAvailablePercentage >= 10) receiptsCacheColor = eColor::cyberWine;
									else if (receiptsCacheAvailablePercentage >= 5) receiptsCacheColor = eColor::lightPink;
									else receiptsCacheColor = eColor::cyborgBlood;

									progressText << tools->getColoredString(" [Receipts]: ", eColor::orange)
										<< tools->getColoredString("(" + tools->to_string_with_precision(receiptsMemory, 3) + " " + memoryUnitReceipts + ") ", receiptsCacheColor)
										<< tools->getColoredString(tools->to_string_with_precision(receiptsCacheAvailablePercentage, 3) + "% Free", receiptsCacheColor);
								}

								barHub->setCustomStatusBarText(mode, barID, progressText.str());
							}
						}
					}// CRITICAL SECTION -  END
					// Update progress - Phase 1 - END

					// Increment blocksProcessed after processing a block
					blocksProcessed.fetch_add(1);
					threadBlocksProcessedSinceLastReport++;

					// Thread Local EMA Update - BEGIN
					// [ Notice ]: thread-local EMA update has a CHANCE to occur every block. Every block in every chunk.

					// Update thread-specific EMA with the remaining time in the thread
					auto threadEndTime = std::chrono::steady_clock::now();
					double threadTimeElapsedSeconds = std::chrono::duration<double>(threadEndTime - threadStartTime).count();
					double timeSinceLastEMALocalUpdateSeconds = std::chrono::duration<double>(threadEndTime - threadEma->lastReportTime).count();

					size_t blocksSinceLastReport = blocksProcessed.load() - lastReportAtTotalBlockCount.load();

					if (threadEma->firstEstimation || timeSinceLastEMALocalUpdateSeconds >= MIN_TIME_INTERVAL_FOR_EMA_UPDATE)
					{
						if (threadBlocksProcessedSinceLastReport > 0) {
							threadEma->update(static_cast<double>(threadBlocksProcessedSinceLastReport), timeSinceLastEMALocalUpdateSeconds);
							threadBlocksProcessedSinceLastReport = 0; // Reset counter
							// Initialize last report time for this thread
							threadEma->lastReportTime = threadEndTime;
						}
					}
					// Thread Local EMA Update - END
				}
				}; // End of worker task

			// Submit task to thread pool and store future
			futures.push_back(threadPool->enqueue(workerTask));
		}

		// Wait for all futures from the thread pool
		for (auto& future : futures)
		{
			try {
				future.get(); // Will rethrow any exceptions from the worker tasks
			}
			catch (const std::exception& e) {
				tools->logEvent("Thread pool task failed: " + std::string(e.what()),
					eLogEntryCategory::localSystem, 10, eLogEntryType::failure);
				valid.store(false);
				break;
			}
		}

		// Check if any thread encountered an error
		if (!valid.load())
		{
			barHub->invalidateCustomStatusBar(mode, barID);
			return false;
		}

		// Phase 1-B: Connect Blocks to Restore Parent-Child Relationships - BEGIN
		{
			// Since blocks were retrieved in parallel, we need to ensure that the parent and next pointers are correctly set
			// We will traverse the blocks in order of depth (from depth 0 upwards)

			if (!batchBlocks.empty()) {
				for (size_t idx = 0; idx < batchBlocks.size(); ++idx)
				{
					std::shared_ptr<CBlock> current = batchBlocks[idx];
					if (!current) {
						tools->logEvent("Null block encountered at index " + std::to_string(idx), "Cache Population", eLogEntryCategory::localSystem, 10, eLogEntryType::failure);
						valid.store(false);
						break;
					}
					// Indexes Support - BEGIN

					// Update Flat Cache - BEGIN
					eSetBlockCacheResult::eSetBlockCacheResult resCPR = setBlockFlatCache(current);

					if (!(eSetBlockCacheResult::Success || eSetBlockCacheResult::EmptyCacheSuccess))
					{
						std::stringstream ssCPR;
						ssCPR << "Unable to populate flat block cache at height ";
						ssCPR << std::to_string(mLeader ? mLeader->getHeader()->getHeight() : 0)
							<< " " << "Reason: " << mTools->blockCachingResultToString(resCPR);
						tools->logEvent(ssCPR.str(), "Leader Election", eLogEntryCategory::localSystem, 10, eLogEntryType::failure);
					}
					// Update Flat Cache - END

					// Block-ID -> Block Height Index Support - BEGIN

					// Block-ID -> Block Height Index Support - END
					if (!addToBlockIDHeightMap(current->getID(), current->getHeader()->getHeight()))//  Flat block Index
					{
						tools->logEvent("Unable to populate the [Block ID] -> [Block Height] Index at height " + std::to_string(current->getHeader()->getHeight()), "Cache Population", eLogEntryCategory::localSystem, 10, eLogEntryType::failure);
						return false;
					}
					// Indexes Support - END

					// Memory Leak Prevention - BEGIN
					// [ Rationale ]: there's no need to fix parent-offspring relationship between existing cache members.
					//              Doing so, would orphan the entire tailing sub-chain of blocks.

					// todo: current->isMainCacheMember() check is expected to be enough, explicit pointers' validation shouldn't be needed.
					if (current->isMainCacheMember() && current->getHeader()->getParentPtr() != nullptr && current->getNext() != nullptr) // is this check enough or do we need to check if parent/next pointers are set for the block?
					{
						continue;
					}
					// Memory Leak Prevention - END

					current->setMainCacheMember(true);

					// Notice: block[N] is newer than block[N+1], thus block[N] is an offspring to  block[N+1] and  block[N+1] is a parent to block[N].
					//            ^-offspring              ^parent 
					// Set parent
					if (idx + 1 < batchBlocks.size())
					{
						std::shared_ptr<CBlock> parent = batchBlocks[idx + 1];
						if (parent) {
							current->getHeader()->setParentPtr(parent);
							// Verify parent-child relationship
							if (current->getHeader()->getParentID() != parent->getID()) {
								tools->logEvent("Parent-child relationship mismatch at index " + std::to_string(idx), "Cache Population", eLogEntryCategory::localSystem, 10, eLogEntryType::failure);
								valid.store(false);
								break;
							}
						}
						else {
							tools->logEvent("Null parent block encountered at index " + std::to_string(idx + 1), "Cache Population", eLogEntryCategory::localSystem, 10, eLogEntryType::failure);
							valid.store(false);
							break;
						}
					}

					// Set offspring
					if (idx > 0)
					{
						std::shared_ptr<CBlock> nextBlock = batchBlocks[idx - 1];
						if (nextBlock) {
							current->setNext(nextBlock);
						}
						else {
							tools->logEvent("Null next block encountered at index " + std::to_string(idx - 1), "Cache Population", eLogEntryCategory::localSystem, 10, eLogEntryType::failure);
							valid.store(false);
							break;
						}
					}
					else if (idx == 0)
					{ // This is the leader, meaning latest block, of the current batch (IMPORTANT - not necessarily of the entire blockchain. It would be the case only during processing of first batch).
						if (lastBatchFinalBlock)
						{// we need to maintain parent-child relationship between last block from previous batch (if there was one).
							current->setNext(lastBatchFinalBlock); // current is PARENT - since lastBatchFinalBlock is block[N] and current is block[N+1]
							lastBatchFinalBlock->getHeader()->setParentPtr(current); // lastBatchFinalBlock is an OFFSPRING - since lastBatchFinalBlock is block[N] and current is block[N+1]

							// Verify inter-batch connection
							if (current->getID() != lastBatchFinalBlock->getHeader()->getParentID()) {
								tools->logEvent("Inter-batch connection mismatch", "Cache Population", eLogEntryCategory::localSystem, 10, eLogEntryType::failure);
								valid.store(false);
								break;
							}
						}
						else
						{
							// detect a case in which block from last batch (lastBatchFinalBlock) would empty. This is never supposed to happen.
							if (isFirstBatch == false) //currentBlockCacheLength.load() > 0)  // If this is not the first batch
							{
								tools->logEvent("Critical error: lastBatchFinalBlock is null for a non-first batch", "Cache Population", eLogEntryCategory::localSystem, 10, eLogEntryType::failure);
								valid.store(false);
								break;
							}
							current->setNext(nullptr);
						}
					}
				}

#if ENABLE_INNER_BATCHCACHE_VERIFICATION_TEST==1
				// [ Notice ]: this test is REDUNDANT to ENABLE_INTER_BATCH_CACHE_VERIFICATION_TEST since the latter implies ENABLE_INNER_BATCHCACHE_VERIFICATION_TEST.
				// enable when debugging only.

				// Inter-Batch Verification - BEGIN
				if (valid.load())
				{
					// Start verification from the newest block (front of the vector)
					std::shared_ptr<CBlock> batchBlockFront = batchBlocks.front();
					std::shared_ptr<CBlock> current = batchBlocks.front();
					std::shared_ptr<CBlock> batchBlocksBack = batchBlocks.back();

					for (size_t i = 0; i < batchBlocks.size() - 1; ++i) {
						// The next block should be the parent of the current block
						if (current->getHeader()->getParentPtr() != batchBlocks[i + 1]) {
							tools->logEvent("Parent-child relationship verification failed at index " + std::to_string(i), "Cache Population",
								eLogEntryCategory::localSystem, 10, eLogEntryType::failure);
							valid.store(false);
							break;
						}

						// The current block should be the next (offspring) of its parent
						if (batchBlocks[i + 1]->getNext() != current) {
							tools->logEvent("Next-block relationship verification failed at index " + std::to_string(i), "Cache Population",
								eLogEntryCategory::localSystem, 10, eLogEntryType::failure);
							valid.store(false);
							break;
						}

						// Move to the next (older) block
						current = current->getHeader()->getParentPtr();
					}

					// Inter-Batch-Check - Verify connection with the previous batch - BEGIN
					 // batchBlockFront is expected to be at index 0 in batchBlocks. Thus height of block  batchBlocks[0] is expected 
					 // to be lower than the height of lastBatchFinalBlock, thus lastBatchFinalBlock is expected to a direct offspring of batchBlocks[0].
					if (!isFirstBatch) {
						if (batchBlockFront->getNext() != lastBatchFinalBlock) {
							tools->logEvent("Inter-batch connection verification failed: batchBlockFront->getNext() does not match lastBatchFinalBlock", "Cache Population",
								eLogEntryCategory::localSystem, 10, eLogEntryType::failure);
							valid.store(false);
						}
						if (lastBatchFinalBlock->getHeader()->getParentPtr() != batchBlockFront) {
							tools->logEvent("Inter-batch connection verification failed: lastBatchFinalBlock->getParentPtr() does not match batchBlockFront", "Cache Population",
								eLogEntryCategory::localSystem, 10, eLogEntryType::failure);
							valid.store(false);
						}
					}
					// Inter-Batch-Check - Verify connection with the previous batch - END
				}
				isFirstBatch = false;
				// Inner-Batch Verification - END
#endif          
			}
			else {
				tools->logEvent("Empty block batch encountered", "Cache Population", eLogEntryCategory::localSystem, 10, eLogEntryType::failure);
				valid.store(false);
			}
		}

		// POST-SINGLE-BATCH Processing - BEGIN
		// Phase 1-B: Connect Blocks to Restore Parent-Child Relationships - END

		if (valid.load())
		{
			blocks.insert(blocks.end(), batchBlocks.begin(), batchBlocks.end()); // after processing each batch and before starting the next one, append batchBlocks to blocks.
			lastBatchFinalBlock = batchBlocks.back(); // store last block from this batch
		}
		// After processing each batch, we should clear batchBlocks to ensure no leftover data.
		batchBlocks.clear();  // Clear the vector after processing
		currentGlobalDepth = endDepth;

		// Log the depth range for this batch
		tools->logEvent("Processed batch from depth " + std::to_string(depthsToProcessInBatch.front()) +
			" to " + std::to_string(depthsToProcessInBatch.back()), "Cache Preparation",
			eLogEntryCategory::localSystem, 0, eLogEntryType::notification);
		// POST-SINGLE-BATCH Processing - END
	}

	if (!valid.load())
	{
		return false; // any error is considered as critical and we return immediately.
	}

	// Phase 2: Continue Receipts Caching by Processing Blocks towards the Genesis Block
	if (continueReceiptsCaching.load())
	{
		// Start from the block immediately after the last cached block and move towards greater depths (genesis block)
		uint64_t depth = (totalBlocksInChain - 1 - blocksProcessed.load()); // Starting depth (immediately after cached blocks)
		bool keepProcessing = true;

		while (keepProcessing && continueReceiptsCaching.load() && depth < totalBlocksInChain)
		{
			// Determine the number of blocks to process in this batch
			size_t batchSize = numThreads * BLOCKS_PER_THREAD;
			std::vector<size_t> extraDepthsToProcessInABatch; // batch-local list of depths

			for (size_t i = 0; i < batchSize && depth < totalBlocksInChain; ++i)
			{
				extraDepthsToProcessInABatch.push_back(depth);
				depth++;
			}

			if (extraDepthsToProcessInABatch.empty())
			{
				break; // No more blocks to process
			}

			// Prepare per-thread results
			std::vector<std::future<void>> extraBatchFutures; // batch-local threads. Additional MAY be scheduled.

			// Divide depths into chunks for threads
			size_t extraBatchBlocksCount = extraDepthsToProcessInABatch.size(); // in the current pending batch (NOT till the entire remaining blockchain is parsed). Additional extra blocks and batches MAY be scheduled.
			size_t extraChunkSize = (extraBatchBlocksCount + numThreads - 1) / numThreads; // size of a single chunk (for a single thread).

			std::vector<std::pair<size_t, size_t>> extraChunks; // for current batch

			for (size_t i = 0; i < extraBatchBlocksCount; i += extraChunkSize)
			{
				size_t chunkStart = i;
				size_t chunkEnd = min(i + extraChunkSize, extraBatchBlocksCount);
				extraChunks.push_back(std::make_pair(chunkStart, chunkEnd));
			}

			// Process extra blocks (from a single pending batch) in parallel using thread pool
			for (size_t threadIndex = 0; threadIndex < extraChunks.size(); ++threadIndex)
			{
				const auto& chunk = extraChunks[threadIndex];
				// Assign a ThreadTimeEstimation instance to each thread
				std::shared_ptr<ThreadTimeEstimation> threadEma;
				{
					std::lock_guard<std::mutex> lock(emaListMutex);
					threadEmas.emplace_back(std::make_shared<ThreadTimeEstimation>());
					threadEma = threadEmas.back();
				}

				// Create worker task for thread pool
				auto workerTask = [&, chunk, threadEma]() {
					// Thread Stats - BEGIN
					threadEma->lastReportTime = std::chrono::steady_clock::now();
					numberOfActiveThreads.fetch_add(1); // notify about a new active thread

					FinalAction finally([&numberOfActiveThreads]() {
						numberOfActiveThreads.fetch_sub(1); // as soon as thread finishes processing decrement the number of active threads
						});
					// Thread Stats - END

					// Thread Local Variables - BEGIN
					size_t threadBlocksProcessedSinceLastReport = 0;
					size_t chunkStart = chunk.first;
					size_t chunkEnd = chunk.second;
					// Track time for this chunk
					auto threadStartTime = std::chrono::steady_clock::now();
					// Thread Local Variables - END

					for (size_t idx = chunkStart; idx < chunkEnd; ++idx)
					{
						// Single Block Processing - BEGIN
						size_t depth = extraDepthsToProcessInABatch[idx];

						bool instantiateTrees = true; //  in Phase 2 we NEED to keep instantiating Trees since we need access to receipts. These blocks would not be stored in cache anyway and removed once out of scope.

						// Retrieve the block at this depth
						std::shared_ptr<CBlock> current = getBlockAtDepthSSDirect(depth, eChainProof::verifiedCached, instantiateTrees);
						if (current == nullptr)
						{
							tools->logEvent("Unable to retrieve block at depth " + std::to_string(depth), eLogEntryCategory::localSystem, 10, eLogEntryType::failure);
							valid.store(false);
							return;
						}
						markBlockLocalAvailability(current->getID());

						// Receipts Cache Logic - BEGIN
						if (continueReceiptsCaching.load())
						{
							std::vector<CReceipt> blockReceipts = current->getReceipts();
							for (const auto& receipt : blockReceipts)
							{
								if (currentReceiptsCacheSize >= maxReceiptsCacheSize)
								{
									continueReceiptsCaching.store(false);
									tools->logEvent("Receipts cache reached 100% capacity", "Receipts Cache");
									break;
								}
								try
								{
									std::shared_ptr<CReceipt> receiptPtr = std::make_shared<CReceipt>(receipt);
									receiptPtr->setBlockInfo(current); //to maintain block height
									addReceiptToHotCache(receiptPtr);
									currentReceiptsCacheSize = getReceiptsCacheSize();
									estimatedReceiptsCacheMemory += sizeof(receipt) * 4 + receipt.getLogSize(); // Rough estimate
								}
								catch (const std::exception& e)
								{
									tools->logEvent("Error adding receipt to cache: " + std::string(e.what()), eLogEntryCategory::localSystem, 5, eLogEntryType::warning);
								}
							}
						}
						// Receipts Cache Logic - END

						// Update progress - Phase 2 - BEGIN
						// CRITICAL SECTION - BEGIN
						{
							std::lock_guard<std::mutex> lock(progressMutex); // read on multiple atomic variables requires a mutex
							if (flashCurrentCount && (blocksProcessed.load() - lastReportAtTotalBlockCount.load()) > CACHE_REPORT_EVERY_BLOCKS)
							{
								// Time-Left estimation - BEGIN
								auto now = std::chrono::steady_clock::now();
								lastReportAtTotalBlockCount.store(blocksProcessed.load());

								uint64_t processed = blocksProcessed.load();
								uint64_t totalBlocksLeft = (totalBlocksInChain - depth); // total amount of blocks left to be processed. This does not account for Hot-Storage limits.
								int progress = static_cast<int>((static_cast<double>(processed) / totalBlocksInChain) * 100); // global coverage of processed blocks

								if (progress != lastProgressValue)
								{
									lastProgressValue = progress;

									// Aggregate EMAs from all threads
									double aggregatedEma = 0.0;
									size_t reportableThreadsCount = 0;
									{
										std::lock_guard<std::mutex> lock(emaListMutex);
										for (const auto& ema : threadEmas)
										{
											if (!ema->firstEstimation) { // Only include threads that have started estimation
												aggregatedEma += ema->emaBlocksPerSecond;
												++reportableThreadsCount;
											}
										}
									}
									reportableThreadsCount = min(numberOfActiveThreads.load(), reportableThreadsCount);// do not include threads that have finished execution

									double globalEma = (reportableThreadsCount > 0) ? (aggregatedEma / reportableThreadsCount) : 0.0;

									// Calculate ETA based on global EMA
									std::string timeLeftStr;
									if (globalEma > 0.0)
									{
										uint64_t remainingBlocksCountGlobal = totalBlocksInChain - processed;
										double estimatedRemainingSeconds = remainingBlocksCountGlobal / globalEma;
										timeLeftStr = mTools->secondsToFormattedString(static_cast<uint64_t>(estimatedRemainingSeconds));
									}
									else
									{
										timeLeftStr = "Calculating...";
									}

									// Time-Left estimation - END

									// Compute estimated memory usage
									std::string memoryUnitReceipts = (estimatedReceiptsCacheMemory.load() >= BYTES_PER_MEGABYTE) ? "MB" : "KB";
									double receiptsMemory = (memoryUnitReceipts == "MB") ? estimatedReceiptsCacheMemory.load() / static_cast<double>(BYTES_PER_MEGABYTE) : estimatedReceiptsCacheMemory.load() / static_cast<double>(BYTES_PER_KILOBYTE);
									double receiptsProgress = (double)currentReceiptsCacheSize / (double)maxReceiptsCacheSize * 100.0;
									uint64_t cacheAvailablePercentage = static_cast<uint64_t>(100 - receiptsProgress);

									std::ostringstream progressText;
									progressText << tools->getColoredString("[Receipts Processing]: ", eColor::greyWhiteBox);

									// Color for coverage percentage
									eColor::eColor coverageColor;
									if (progress >= 90) coverageColor = eColor::lightCyan;
									else if (progress >= 70) coverageColor = eColor::lightGreen;
									else if (progress >= 50) coverageColor = eColor::orange;
									else if (progress >= 30) coverageColor = eColor::cyberWine;
									else if (progress >= 10) coverageColor = eColor::lightPink;
									else coverageColor = eColor::cyborgBlood;

									progressText << tools->getColoredString(tools->to_string_with_precision(progress, 3) + "% Coverage", coverageColor);

									// Color for memory usage
									eColor::eColor memoryColor;
									if (receiptsMemory < 10) memoryColor = eColor::lightGreen;
									else if (receiptsMemory < 30) memoryColor = eColor::lightWhite;
									else if (receiptsMemory < 50) memoryColor = eColor::orange;
									else if (receiptsMemory < 70) memoryColor = eColor::cyberWine;
									else if (receiptsMemory < 90) memoryColor = eColor::lightPink;
									else memoryColor = eColor::cyborgBlood;

									progressText << " " << tools->getColoredString("(" + tools->to_string_with_precision(receiptsMemory, 3) + " " + memoryUnitReceipts + ")", memoryColor);

									// Color for available space
									eColor::eColor spaceColor;
									if (cacheAvailablePercentage >= 50) spaceColor = eColor::lightGreen;
									else if (cacheAvailablePercentage >= 30) spaceColor = eColor::lightWhite;
									else if (cacheAvailablePercentage >= 20) spaceColor = eColor::orange;
									else if (cacheAvailablePercentage >= 10) spaceColor = eColor::cyberWine;
									else if (cacheAvailablePercentage >= 5) spaceColor = eColor::lightPink;
									else spaceColor = eColor::cyborgBlood;

									progressText << " " << tools->getColoredString(tools->to_string_with_precision(cacheAvailablePercentage, 3) + "%", spaceColor) << " Space Available";
									progressText << " ETA: " << tools->getColoredString(timeLeftStr, eColor::blue);
									barHub->setCustomStatusBarText(mode, barID, progressText.str());
								}
							}
						}// CRITICAL SECTION - END
						// Update progress - Phase 2 - END

						// Increment blocksProcessed after processing a block
						blocksProcessed.fetch_add(1);
						threadBlocksProcessedSinceLastReport++;

						// Thread Local EMA Update - BEGIN
						// [ Notice ]: thread-local EMA update has a CHANCE to occur every block. Every block in every chunk.

						// Update thread-specific EMA with the remaining time in the thread
						auto threadEndTime = std::chrono::steady_clock::now();
						double threadTimeElapsedSeconds = std::chrono::duration<double>(threadEndTime - threadStartTime).count();
						double timeSinceLastEMALocalUpdateSeconds = std::chrono::duration<double>(threadEndTime - threadEma->lastReportTime).count();

						if (timeSinceLastEMALocalUpdateSeconds >= MIN_TIME_INTERVAL_FOR_EMA_UPDATE)
						{
							if (threadBlocksProcessedSinceLastReport > 0) {
								threadEma->update(static_cast<double>(threadBlocksProcessedSinceLastReport), timeSinceLastEMALocalUpdateSeconds);
								threadBlocksProcessedSinceLastReport = 0; // Reset counter
								// Initialize last report time for this thread
								threadEma->lastReportTime = threadEndTime;
							}
						}
						// Thread Local EMA Update - END
					}
					};

				// Submit task to thread pool and store future
				extraBatchFutures.push_back(threadPool->enqueue(workerTask));
			}

			// Wait for all futures from the thread pool
			for (auto& future : extraBatchFutures)
			{
				try {
					future.get();  // Will rethrow any exceptions from the worker tasks
				}
				catch (const std::exception& e) {
					tools->logEvent("Thread pool task failed during receipts processing: " + std::string(e.what()),
						eLogEntryCategory::localSystem, 10, eLogEntryType::failure);
					valid.store(false);
					break;
				}
			}

			// Check if any thread encountered an error
			if (!valid.load())
			{
				barHub->invalidateCustomStatusBar(mode, barID);
				return false;
			}

			// If we've reached the total number of blocks in the chain, stop processing
			if (depth >= totalBlocksInChain)
			{
				keepProcessing = false;
			}
		}
	}

	// Invalidate progress bar
	barHub->invalidateCustomStatusBar(mode, barID);

	// Log final cache sizes

	// Compute human-readable block cache size
	std::string blockMemoryUnit = (estimatedBlockCacheMemory.load() >= BYTES_PER_MEGABYTE) ? "MB" : "KB";
	double blockMemorySize = (blockMemoryUnit == "MB") ? estimatedBlockCacheMemory.load() / static_cast<double>(BYTES_PER_MEGABYTE) : estimatedBlockCacheMemory.load() / static_cast<double>(BYTES_PER_KILOBYTE);

	// Log block cache length and estimated size
	tools->logEvent(
		tools->getColoredString("[Blockchain Cache]: ", eColor::blue) +
		std::to_string(currentBlockCacheLength.load()) + " blocks, " +
		tools->to_string_with_precision(blockMemorySize, 3) + " " + blockMemoryUnit,
		eLogEntryCategory::localSystem, 5
	);

	if (cacheReceipts)
	{
		// Compute human-readable receipts cache size
		std::string receiptsMemoryUnit = (estimatedReceiptsCacheMemory.load() >= BYTES_PER_MEGABYTE) ? "MB" : "KB";
		double receiptsMemorySize = (receiptsMemoryUnit == "MB") ? estimatedReceiptsCacheMemory.load() / static_cast<double>(BYTES_PER_MEGABYTE) : estimatedReceiptsCacheMemory.load() / static_cast<double>(BYTES_PER_KILOBYTE);

		// Log receipts cache count and estimated size
		tools->logEvent(
			tools->getColoredString("[Receipts Cache]: ", eColor::lightCyan) +
			std::to_string(currentReceiptsCacheSize) + " bytes, " +
			tools->to_string_with_precision(receiptsMemorySize, 3) + " " + receiptsMemoryUnit,
			eLogEntryCategory::localSystem, 5
		);
	}

	// Verification Test (optional, governed by preprocessor flag)
#if ENABLE_INTER_BATCH_CACHE_VERIFICATION_TEST==1
	{
		// Verify that the number of blocks in cache corresponds to the actual traversable chain of blocks
		size_t traversedBlocks = 0;
		std::shared_ptr<CBlock> current = leaderBlock; // reuse the same block established earlier as leader
		std::set<std::vector<uint8_t>> visitedBlockHashes; // To detect loops and prevent infinite traversal

		while (current != nullptr)
		{
			// Get the block's hash
			std::vector<uint8_t> currentHash = current->getID();

#if ENABLE_CACHE_VERIFICATION_LOOP_DETECTION_TEST==1
			// Check for loops
			if (visitedBlockHashes.find(currentHash) != visitedBlockHashes.end())
			{
				// Detected a loop in the chain
				tools->logEvent("Detected a loop in the cached block chain during verification test", eLogEntryCategory::localSystem, 10, eLogEntryType::failure);
				break;
			}
#endif

			// Add the block's hash to the visited set
			visitedBlockHashes.insert(currentHash);

			traversedBlocks++;

			// Move to the parent block
			current = current->getHeader()->getParentPtr();

			// Stop traversal if we've reached the maximum number of blocks in cache
			if (traversedBlocks >= currentBlockCacheLength.load())
			{
				break;
			}
		}

		// Compare the number of traversed blocks with the cached block count
		if (traversedBlocks != currentBlockCacheLength.load())
		{
			tools->logEvent(
				"Cache verification test failed: traversed blocks (" + std::to_string(traversedBlocks) +
				") do not match cached block count (" + std::to_string(currentBlockCacheLength.load()) + ")",
				eLogEntryCategory::localSystem, 5, eLogEntryType::warning
			);
		}
		else
		{
			tools->logEvent(
				"Cache verification test passed: traversed blocks match cached block count (" +
				std::to_string(currentBlockCacheLength.load()) + " blocks)",
				eLogEntryCategory::localSystem, 5
			);
		}
	}
#endif

	// Set Deepest Block - BEGIN
	/*
	 The vector blocks accumulates all the blocks that have been cached during Phase 1. This vector is populated incrementally after each batch is processed.
	 Therefore, after the while loop that processes all batches in Phase 1, the last element in the blocks vector (blocks.back())
	 represents the deepest block that ended up in the cache.
	*/
	if (!blocks.empty())
	{
		setDeepestBlockInCache(blocks.back());
	}
	else
	{
		tools->logEvent("No blocks were cached during Phase 1; cannot set deepest block in cache.", "Cache Preparation", eLogEntryCategory::localSystem, 10, eLogEntryType::warning);
	}
	// Set Deepest Block - END

	// If we created our own thread pool, wait for all tasks and clean up
	if (ownThreadPool) {
		threadPool->waitAll();
		// ThreadPool destructor will clean up resources
	}

	return true;
}


// Stats - BEGIN


BigInt CBlockchainManager::getRecentTotalReward(uint64_t seconds, bool allowCache) {
	// Check cache if allowed
	if (allowCache) {
		std::shared_lock<std::shared_mutex> statLock(mStatsDataGuardian);
		uint64_t currentTime = std::time(nullptr);
		if (currentTime - mRecentTotalRewardTimestamp < CACHE_VALIDITY_PERIOD) {
			return mRecentTotalRewardCache;
		}
	}

	// Cache miss or cache disabled, compute value
	std::lock_guard<ExclusiveWorkerMutex> lock(mChainGuardian);

	// Local variables - BEGIN
	BigInt totalReward = 0;
	uint64_t currentTime = std::time(nullptr);
	uint64_t startTime = currentTime - seconds;
	std::shared_ptr<CBlock> currentBlock = mLeader;
	// Local variables - END

	// Input validation - BEGIN
	if (!currentBlock) {
		mTools->logEvent("Cannot calculate recent total reward: Leader block unavailable",
			"BlockchainStats", eLogEntryCategory::localSystem, 3, eLogEntryType::warning);
		return totalReward;
	}
	// Input validation - END

	// Operational Logic - BEGIN
	while (currentBlock && currentBlock->getHeader()->getSolvedAtTime() >= startTime) {
		// Use block description if available for efficiency
		if (currentBlock->hasDescription()) {
			auto desc = currentBlock->getDescription();
			totalReward += desc->getTotalReward();
		}
		else {
			// Fallback if description not available
			totalReward += currentBlock->getHeader()->getTotalBlockReward();
		}

		currentBlock = currentBlock->getParentPtr();
	}
	// Operational Logic - END

	// Update cache
	{
		std::unique_lock<std::shared_mutex> statLock(mStatsDataGuardian);
		mRecentTotalRewardCache = totalReward;
		mRecentTotalRewardTimestamp = currentTime;
	}

	return totalReward;
}


double CBlockchainManager::getNetworkUtilization(bool allowCache) {
	// Check cache if allowed
	if (allowCache) {
		std::shared_lock<std::shared_mutex> statLock(mStatsDataGuardian);
		uint64_t currentTime = std::time(nullptr);
		if (currentTime - mNetworkUtilizationTimestamp < CACHE_VALIDITY_PERIOD) {
			return mNetworkUtilizationCache;
		}
	}

	// Cache miss or cache disabled, compute value
	std::lock_guard<ExclusiveWorkerMutex> lock(mChainGuardian);

	// Generate random number between 0.01 and 0.05
	std::random_device rd;
	std::mt19937 gen(rd());
	std::uniform_real_distribution<> dis(0.01, 0.05);
	double utilization = dis(gen);

	// Update cache
	{
		std::unique_lock<std::shared_mutex> statLock(mStatsDataGuardian);
		mNetworkUtilizationCache = utilization;
		mNetworkUtilizationTimestamp = std::time(nullptr);
	}

	return utilization;
}


uint64_t CBlockchainManager::getBlockSize(uint64_t seconds, bool allowCache ) {
	// Check cache if allowed
	if (allowCache) {
		std::shared_lock<std::shared_mutex> statLock(mStatsDataGuardian);
		uint64_t currentTime = std::time(nullptr);
		if (currentTime - mBlockSizeTimestamp < CACHE_VALIDITY_PERIOD) {
			return mBlockSizeCache;
		}
	}

	// Cache miss or cache disabled, compute value
	std::lock_guard<ExclusiveWorkerMutex> lock(mChainGuardian);

	// Local variables - BEGIN
	uint64_t totalSize = 0;
	uint64_t blockCount = 0;
	uint64_t currentTime = std::time(nullptr);
	uint64_t startTime = currentTime - seconds;
	std::shared_ptr<CBlock> currentBlock = mLeader;
	const uint64_t BASE_BLOCK_SIZE = 500;      // Base block size in bytes
	const uint64_t TRANSACTION_SIZE = 300;     // Average transaction size in bytes
	// Local variables - END

	// Input validation - BEGIN
	if (!currentBlock) {
		mTools->logEvent("Cannot calculate average block size: Leader block unavailable",
			"BlockchainStats", eLogEntryCategory::localSystem, 3, eLogEntryType::warning);
		return 0;
	}
	// Input validation - END

	// Operational Logic - BEGIN
	while (currentBlock && currentBlock->getHeader()->getSolvedAtTime() >= startTime) {
		// Calculate block size: base size + transactions size
		uint64_t blockSize = BASE_BLOCK_SIZE +
			(currentBlock->getHeader()->getNrOfTransactions() * TRANSACTION_SIZE);

		totalSize += blockSize;
		blockCount++;

		currentBlock = currentBlock->getParentPtr();
	}
	// Operational Logic - END

	// Calculate average size
	uint64_t averageSize = (blockCount > 0) ? (totalSize / blockCount) : 0;

	// Update cache
	{
		std::unique_lock<std::shared_mutex> statLock(mStatsDataGuardian);
		mBlockSizeCache = averageSize;
		mBlockSizeTimestamp = currentTime;
	}

	return averageSize;
}


uint64_t CBlockchainManager::getAverageBlockTime(uint64_t seconds, bool onlyKey, bool allowCache) {
	// Check cache if allowed
	if (allowCache) {
		std::shared_lock<std::shared_mutex> statLock(mStatsDataGuardian);
		uint64_t currentTime = std::time(nullptr);

		if (onlyKey && currentTime - mAverageKeyBlockTimeTimestamp < CACHE_VALIDITY_PERIOD) {
			return mAverageKeyBlockTimeCache;
		}
		else if (!onlyKey && currentTime - mAverageBlockTimeTimestamp < CACHE_VALIDITY_PERIOD) {
			return mAverageBlockTimeCache;
		}
	}

	// Cache miss or cache disabled, compute value
	std::lock_guard<ExclusiveWorkerMutex> lock(mChainGuardian);

	// Local variables - BEGIN
	std::vector<uint64_t> blockTimes;
	uint64_t currentTime = std::time(nullptr);
	uint64_t startTime = currentTime - seconds;
	std::shared_ptr<CBlock> currentBlock = mLeader;
	// Local variables - END

	// Input validation - BEGIN
	if (!currentBlock) {
		mTools->logEvent("Cannot calculate average block time: Leader block unavailable",
			"BlockchainStats", eLogEntryCategory::localSystem, 3, eLogEntryType::warning);
		return 0;
	}
	// Input validation - END

	// Operational Logic - BEGIN
	while (currentBlock && currentBlock->getHeader()->getSolvedAtTime() >= startTime) {
		// Skip if we're only interested in key blocks and this isn't one
		if (onlyKey && !currentBlock->getHeader()->isKeyBlock()) {
			currentBlock = currentBlock->getParentPtr();
			continue;
		}

		blockTimes.push_back(currentBlock->getHeader()->getSolvedAtTime());
		currentBlock = currentBlock->getParentPtr();
	}

	// Calculate average time between blocks
	double totalTimeDiff = 0.0;
	uint64_t diffCount = 0;

	if (blockTimes.size() <= 1) {
		// Not enough blocks to calculate average time
		return 0;
	}

	// Sort block times in ascending order (oldest first)
	std::sort(blockTimes.begin(), blockTimes.end());

	for (size_t i = 1; i < blockTimes.size(); i++) {
		uint64_t timeDiff = blockTimes[i] - blockTimes[i - 1];
		totalTimeDiff += timeDiff;
		diffCount++;
	}
	// Operational Logic - END

	// Calculate average time
	double averageTime = (diffCount > 0) ? (totalTimeDiff / diffCount) : 0.0;

	// Update cache
	{
		std::unique_lock<std::shared_mutex> statLock(mStatsDataGuardian);
		if (onlyKey) {
			mAverageKeyBlockTimeCache = averageTime;
			mAverageKeyBlockTimeTimestamp = currentTime;
		}
		else {
			mAverageBlockTimeCache = averageTime;
			mAverageBlockTimeTimestamp = currentTime;
		}
	}

	return static_cast<uint64_t>(averageTime);
}

// Stats - END



bool CBlockchainManager::prepareInitialBlockchainSecurityAnalysis()
{
	// Lock guardians to ensure thread safety for shared resources
	std::lock_guard<ExclusiveWorkerMutex> lock1(mChainGuardian);
	std::lock_guard<std::recursive_mutex> lock2(mLeaderGuardian);

	// Pre-Flight Checks - BEGIN
	std::shared_ptr<CTools> tools = getTools();
	if (!mLeader) {
		tools->logEvent("Leader is unavailable, can't perform security analysis",
			"Security Analysis", eLogEntryCategory::localSystem, 10, eLogEntryType::failure);
		return false;
	}

	uint64_t totalBlocks = mLeader->getHeader()->getHeight() + 1;  // Including genesis
	if (totalBlocks == 0) {
		tools->logEvent("No blocks available for security analysis",
			"Security Analysis", eLogEntryCategory::localSystem, 10, eLogEntryType::failure);
		return false;
	}
	// Pre-Flight Checks - END

	// Initialize progress tracking variables - BEGIN
	std::shared_ptr<CStatusBarHub> barHub = CStatusBarHub::getInstance();
	eBlockchainMode::eBlockchainMode mode = getMode();
	uint64_t barID = getCacheBarID();
	uint64_t blocksProcessed = 0;
	uint64_t lastProgressUpdate = 0;
	auto startTime = std::chrono::steady_clock::now();
	double emaBlocksPerSecond = 0.0;
	bool isFirstEstimation = true;
	constexpr uint64_t PROGRESS_UPDATE_INTERVAL = 100;  // Update every 100 blocks
	// Initialize progress tracking variables - END

	// Log the start of security analysis
	tools->logEvent("Starting comprehensive blockchain security analysis...",
		"Security Analysis", eLogEntryCategory::localSystem, 5, eLogEntryType::notification, eColor::lightCyan);

	// Operational Logic - BEGIN
	try {
		for (uint64_t height = 0; height <= mLeader->getHeader()->getHeight(); ++height) {
			// Block Retrieval and Processing - BEGIN
			std::shared_ptr<CBlock> block = getBlockAtHeight(height, false, eChainProof::verifiedCached);
			if (!block) {
				std::string errorMsg = "Failed to retrieve block at height " + std::to_string(height);
				tools->logEvent(errorMsg, "Security Analysis",
					eLogEntryCategory::localSystem, 10, eLogEntryType::failure, eColor::cyborgBlood);
				barHub->invalidateCustomStatusBar(mode, barID);
				return false;
			}

			// Perform security analysis
			updateSecAnalysis(block);
			blocksProcessed++;
			// Block Retrieval and Processing - END

			// Progress Reporting - BEGIN
			if (blocksProcessed - lastProgressUpdate >= PROGRESS_UPDATE_INTERVAL) {
				auto currentTime = std::chrono::steady_clock::now();
				double timeSinceStart = std::chrono::duration<double>(currentTime - startTime).count();

				// Update EMA for blocks per second
				double currentBlocksPerSecond = static_cast<double>(PROGRESS_UPDATE_INTERVAL) /
					std::chrono::duration<double>(currentTime - startTime).count();

				if (isFirstEstimation) {
					emaBlocksPerSecond = currentBlocksPerSecond;
					isFirstEstimation = false;
				}
				else {
					emaBlocksPerSecond = (emaBlocksPerSecond * 0.7) + (currentBlocksPerSecond * 0.3);
				}

				// Calculate estimated time remaining
				uint64_t remainingBlocks = totalBlocks - blocksProcessed;
				std::string timeLeftStr;
				if (emaBlocksPerSecond > 0) {
					double estimatedRemainingSeconds = remainingBlocks / emaBlocksPerSecond;
					timeLeftStr = tools->secondsToFormattedString(static_cast<uint64_t>(estimatedRemainingSeconds));
				}
				else {
					timeLeftStr = "Calculating...";
				}

				// Calculate progress percentage
				double progress = (static_cast<double>(blocksProcessed) / totalBlocks) * 100.0;

				// Prepare and display progress text
				std::string progressText =
					tools->getColoredString("Blockchain Security Analysis: ", eColor::blue) +
					tools->getColoredString(tools->to_string_with_precision(progress, 2) + "% ", eColor::lightGreen) +
					tools->getColoredString("Block: " + std::to_string(height) + "/" +
						std::to_string(totalBlocks - 1), eColor::lightCyan) +
					tools->getColoredString(" ETA: " + timeLeftStr, eColor::orange);

				barHub->setCustomStatusBarText(mode, barID, progressText);
				lastProgressUpdate = blocksProcessed;
				startTime = currentTime;
			}
			// Progress Reporting - END
		}
	}
	catch (const std::exception& e) {
		std::string errorMsg = "Error during security analysis: " + std::string(e.what());
		tools->logEvent(errorMsg, "Security Analysis",
			eLogEntryCategory::localSystem, 10, eLogEntryType::failure, eColor::cyborgBlood);
		barHub->invalidateCustomStatusBar(mode, barID);
		return false;
	}
	// Operational Logic - END

	// Cleanup and Final Reporting - BEGIN
	barHub->invalidateCustomStatusBar(mode, barID);

	// Log completion statistics
	std::string completionMsg =
		tools->getColoredString("[Security Analysis Complete]: ", eColor::blue) +
		tools->getColoredString(std::to_string(blocksProcessed) + " blocks analyzed", eColor::lightGreen);
	tools->logEvent(completionMsg, eLogEntryCategory::localSystem, 5, eLogEntryType::notification, eColor::lightGreen);
	// Cleanup and Final Reporting - END

	return true;
}


void CBlockchainManager::clearBlockCache() {



	// Use MemoryOrdered policy to prevent deadlocks - ensures all threads
	// acquire these locks in the same order (by memory address)
	// Note: mBlockIDMapGuardian removed - clearBlockIDHeightMap() acquires it separately
	// to avoid recursive locking issues (std::shared_mutex doesn't support recursion)
	sync::SynchronizedLocker lock(sync::LockingPolicy::MemoryOrdered, mChainGuardian, mLeaderGuardian, mBlockCacheFlatGuardian);


	//Local Variables - BEGIN
	eBlockInstantiationResult::eBlockInstantiationResult result;
	std::shared_ptr<CTools> tools = getTools();
	//Local Variables - BEGIN


	// Check if the leader is available
	if (mLeader == nullptr) {
		tools->writeLine("Leader is unavailable; cannot clear the block cache.");
		return;
	}

	mLeader->freePath(false, getTools());
	clearFlatCache(true);
	clearBlockIDHeightMap();

}



void CBlockchainManager::getHuntedBlockIDs(std::vector < std::vector<uint8_t>>& data)
{
	std::lock_guard<std::recursive_mutex> lock(mHuntedBlocksGuardian);
	for (uint64_t i = 0; i < mHuntedBlocks.size(); i++)
	{
		data.push_back(std::get<0>(mHuntedBlocks[i]));
	}
}

void CBlockchainManager::getHuntedBlocks(std::vector<std::tuple<std::vector<uint8_t>, std::shared_ptr<CBlockHeader>>>& blockData)
{
	std::lock_guard<std::recursive_mutex> lock(mHuntedBlocksGuardian);
	std::shared_ptr<CBlockHeader> bh;


	for (uint64_t i = 0; i < mHuntedBlocks.size(); i++)
	{
		blockData.push_back(std::make_tuple(std::get<0>(mHuntedBlocks[i]), std::get<1>(mHuntedBlocks[i])));
	}

}

bool  CBlockchainManager::setPerspective(std::vector<uint8_t> perspectiveID)
{
	std::lock_guard<std::recursive_mutex> lock(mGuardian);
	return mLiveStateDB->setPerspective(perspectiveID);
}

bool CBlockchainManager::getLocalNodeIsLeaderCached()
{
	std::lock_guard<std::mutex> lock(mFieldsGuardian);
	return mLocalNodeIsLeaderCached;
}
void  CBlockchainManager::setLocalNodeIsLeaderCached(bool isIt)
{
	std::lock_guard<std::mutex> lock(mFieldsGuardian);
	mLocalNodeIsLeaderCached = isIt;

}

// ============================================================================
// Phantom Leader Mode Implementation - BEGIN
// ============================================================================
// [ Implementation Notes ]:
// These methods provide the runtime interface for Phantom Leader Mode.
// The mode enables transaction processing simulation without affecting
// the actual blockchain state or broadcasting blocks to the network.
// Primarily used for debugging transaction withholding issues.
// ============================================================================

/// @brief Checks if Phantom Leader Mode is currently enabled.
/// @return true if Phantom Leader Mode is active, false otherwise.
bool CBlockchainManager::getIsPhantomLeaderModeEnabled()
{
	std::lock_guard<std::mutex> lock(mPhantomLeaderModeGuardian);
	return mPhantomLeaderModeEnabled;
}

/// @brief Enables or disables Phantom Leader Mode.
/// @param enable Set to true to enable, false to disable.
void CBlockchainManager::setPhantomLeaderModeEnabled(bool enable)
{
	std::lock_guard<std::mutex> lock(mPhantomLeaderModeGuardian);

	// Log state transition for audit trail
	if (enable != mPhantomLeaderModeEnabled)
	{
		std::string stateStr = enable ? "ENABLED" : "DISABLED";
		mTools->logEvent(
			"Phantom Leader Mode " + stateStr + ". " +
			(enable ? "Node will simulate leader operations without broadcasting blocks."
			        : "Returning to normal operation mode."),
			"Phantom Mode",
			eLogEntryCategory::localSystem,
			10,
			enable ? eLogEntryType::warning : eLogEntryType::notification,
			enable ? eColor::orange : eColor::lightGreen
		);

		// Reset stats when enabling
		if (enable)
		{
			mPhantomBlocksFormedCount = 0;
			mPhantomTransactionsProcessedCount = 0;
			mLastPhantomBlockFormationTime = 0;
		}
	}

	mPhantomLeaderModeEnabled = enable;
}

/// @brief Returns the count of phantom blocks formed during this session.
/// @return Number of phantom blocks formed since mode was enabled.
uint64_t CBlockchainManager::getPhantomBlocksFormedCount()
{
	std::lock_guard<std::mutex> lock(mPhantomLeaderModeGuardian);
	return mPhantomBlocksFormedCount;
}

/// @brief Increments the phantom blocks formed counter.
void CBlockchainManager::incPhantomBlocksFormedCount()
{
	std::lock_guard<std::mutex> lock(mPhantomLeaderModeGuardian);
	mPhantomBlocksFormedCount++;
}

/// @brief Returns the count of transactions processed in phantom mode.
/// @return Number of transactions processed in phantom blocks.
uint64_t CBlockchainManager::getPhantomTransactionsProcessedCount()
{
	std::lock_guard<std::mutex> lock(mPhantomLeaderModeGuardian);
	return mPhantomTransactionsProcessedCount;
}

/// @brief Adds to the phantom transactions processed counter.
/// @param count Number of transactions to add.
void CBlockchainManager::addPhantomTransactionsProcessedCount(uint64_t count)
{
	std::lock_guard<std::mutex> lock(mPhantomLeaderModeGuardian);
	mPhantomTransactionsProcessedCount += count;
}

/// @brief Resets all phantom mode statistics.
void CBlockchainManager::resetPhantomModeStats()
{
	std::lock_guard<std::mutex> lock(mPhantomLeaderModeGuardian);
	mPhantomBlocksFormedCount = 0;
	mPhantomTransactionsProcessedCount = 0;
	mLastPhantomBlockFormationTime = 0;

	mTools->logEvent(
		"Phantom Mode statistics have been reset.",
		"Phantom Mode",
		eLogEntryCategory::localSystem,
		5,
		eLogEntryType::notification,
		eColor::lightCyan
	);
}

/// @brief Gets the timestamp of the last phantom block formation.
/// @return Unix timestamp of last phantom block, 0 if none formed.
uint64_t CBlockchainManager::getLastPhantomBlockFormationTime()
{
	std::lock_guard<std::mutex> lock(mPhantomLeaderModeGuardian);
	return mLastPhantomBlockFormationTime;
}

/// @brief Updates the last phantom block formation timestamp.
void CBlockchainManager::pingLastPhantomBlockFormationTime()
{
	std::lock_guard<std::mutex> lock(mPhantomLeaderModeGuardian);
	mLastPhantomBlockFormationTime = std::time(0);
}

/// @brief Generates a detailed report of the last phantom block formation.
/// @param block The phantom block that was formed.
/// @param receipts Vector of receipts from processing.
/// @param processingTimeMs Time taken to process in milliseconds.
/// @return Formatted string report suitable for terminal display.
std::string CBlockchainManager::generatePhantomBlockReport(
	std::shared_ptr<CBlock> block,
	const std::vector<CReceipt>& receipts,
	uint64_t processingTimeMs)
{
	std::stringstream report;
	std::string newLine = "\n";
	std::shared_ptr<CTools> tools = getTools();

	// Header Section
	report << newLine;
	report << tools->getColoredString(u8"╔══════════════════════════════════════════════════════════════════╗", eColor::orange) << newLine;
	report << tools->getColoredString(u8"║           PHANTOM LEADER MODE - BLOCK FORMATION REPORT           ║", eColor::orange) << newLine;
	report << tools->getColoredString(u8"╚══════════════════════════════════════════════════════════════════╝", eColor::orange) << newLine;
	report << newLine;

	// Warning Banner
	report << tools->getColoredString("[ WARNING ]: This block was NOT broadcasted to the network!", eColor::lightPink) << newLine;
	report << tools->getColoredString("             This is a simulation for debugging purposes only.", eColor::lightPink) << newLine;
	report << newLine;

	// Block Information Section
	report << tools->getColoredString("[ Block Information ]", eColor::blue) << newLine;
	report << u8"─────────────────────────────────────────────────────────────────────" << newLine;

	if (block && block->getHeader())
	{
		std::shared_ptr<CBlockHeader> header = block->getHeader();

		report << tools->getColoredString("Block ID:        ", eColor::lightCyan)
		       << tools->base58CheckEncode(block->getID()) << newLine;
		report << tools->getColoredString("Block Type:      ", eColor::lightCyan)
		       << (header->isKeyBlock() ? "Key Block" : "Data Block") << newLine;
		report << tools->getColoredString("Height:          ", eColor::lightCyan)
		       << header->getHeight() << newLine;
		report << tools->getColoredString("Key Height:      ", eColor::lightCyan)
		       << header->getKeyHeight() << newLine;
		report << tools->getColoredString("Parent ID:       ", eColor::lightCyan)
		       << tools->base58CheckEncode(header->getParentID()) << newLine;
		report << tools->getColoredString("Timestamp:       ", eColor::lightCyan)
		       << tools->timeToString(header->getSolvedAtTime()) << newLine;
		report << tools->getColoredString("Miner ID:        ", eColor::lightCyan)
		       << tools->bytesToString(header->getMinersID()) << newLine;
		report << tools->getColoredString("Transactions:    ", eColor::lightCyan)
		       << header->getNrOfTransactions() << newLine;
		report << tools->getColoredString("Perspective:     ", eColor::lightCyan)
		       << tools->base58CheckEncode(header->getPerspective(eTrieID::state)) << newLine;
	}
	else
	{
		report << tools->getColoredString("ERROR: Block or header is null!", eColor::cyborgBlood) << newLine;
	}
	report << newLine;

	// Processing Statistics Section
	report << tools->getColoredString("[ Processing Statistics ]", eColor::blue) << newLine;
	report << u8"─────────────────────────────────────────────────────────────────────" << newLine;
	report << tools->getColoredString("Processing Time: ", eColor::lightCyan)
	       << processingTimeMs << " ms" << newLine;
	report << tools->getColoredString("Receipts Count:  ", eColor::lightCyan)
	       << receipts.size() << newLine;
	report << newLine;

	// Receipts Summary Section
	if (!receipts.empty())
	{
		report << tools->getColoredString("[ Transaction Receipts Summary ]", eColor::blue) << newLine;
		report << u8"─────────────────────────────────────────────────────────────────────" << newLine;

		uint64_t successCount = 0;
		uint64_t failureCount = 0;
		BigInt totalERGUsed = 0;

		for (size_t i = 0; i < receipts.size() && i < 20; i++) // Limit to first 20 for readability
		{
			const CReceipt& receipt = receipts[i];
			bool isSuccess = (receipt.getResult() == eTransactionValidationResult::valid);

			if (isSuccess) successCount++;
			else failureCount++;

			totalERGUsed += receipt.getERGUsed();

			std::string statusStr = isSuccess ?
				tools->getColoredString("SUCCESS", eColor::lightGreen) :
				tools->getColoredString("FAILED", eColor::lightPink);

			report << "[" << (i + 1) << "] "
			       << tools->base58CheckEncode(receipt.getGUID()).substr(0, 12) << "... "
			       << statusStr << " | ERG: " << receipt.getERGUsed() << newLine;
		}

		if (receipts.size() > 20)
		{
			report << "... and " << (receipts.size() - 20) << " more receipts" << newLine;
		}

		report << newLine;
		report << tools->getColoredString("[ Results Tally ]", eColor::blue) << newLine;
		report << u8"─────────────────────────────────────────────────────────────────────" << newLine;
		report << tools->getColoredString("Successful:      ", eColor::lightGreen) << successCount << newLine;
		report << tools->getColoredString("Failed:          ", eColor::lightPink) << failureCount << newLine;
		report << tools->getColoredString("Total ERG Used:  ", eColor::lightCyan) << totalERGUsed.str() << newLine;
	}
	else
	{
		report << tools->getColoredString("No receipts generated (empty block or key block).", eColor::greyWhiteBox) << newLine;
	}

	report << newLine;

	// Session Statistics Section
	report << tools->getColoredString("[ Phantom Mode Session Statistics ]", eColor::blue) << newLine;
	report << u8"─────────────────────────────────────────────────────────────────────" << newLine;
	report << tools->getColoredString("Phantom Blocks Formed:   ", eColor::lightCyan)
	       << getPhantomBlocksFormedCount() << newLine;
	report << tools->getColoredString("Phantom TXs Processed:   ", eColor::lightCyan)
	       << getPhantomTransactionsProcessedCount() << newLine;
	report << newLine;

	// Footer
	report << tools->getColoredString(u8"══════════════════════════════════════════════════════════════════════", eColor::orange) << newLine;
	report << tools->getColoredString("Use 'chain -phantom off' to disable Phantom Leader Mode.", eColor::greyWhiteBox) << newLine;
	report << newLine;

	return report.str();
}

// Phantom Leader Mode Implementation - END
// ============================================================================

// ============================================================================
// Transaction Withholding Detection Implementation - BEGIN
// ============================================================================
//
// [ Overview ]:
//   These methods implement the "Liveness Monitoring" feature that detects
//   potential transaction withholding attacks - a situation where malicious
//   leaders produce key blocks but refuse to process pending transactions.
//
// [ Architecture ]:
//   ┌─────────────────────────────────────────────────────────────────────┐
//   │              mVitalsMonitoringThreadF() [Background Thread]         │
//   │                              │                                      │
//   │                              ▼                                      │
//   │    getMemPoolWithholdingStats() ─── Gets oldest TX time & count    │
//   │                              │                                      │
//   │                              ▼                                      │
//   │    Calculate key blocks elapsed since oldest TX arrived            │
//   │                              │                                      │
//   │                              ▼                                      │
//   │    checkForTransactionWithholding() ─── Threshold & cooldown check │
//   │                              │                                      │
//   │                              ▼                                      │
//   │    logEvent() with WARNING if threshold exceeded                   │
//   └─────────────────────────────────────────────────────────────────────┘
//
// [ Constants ]:
//   - TX_WITHHOLDING_KEY_BLOCK_THRESHOLD (3) : Key blocks before warning
//   - TX_WITHHOLDING_WARNING_COOLDOWN_SEC (60): Seconds between warnings
//
// [ State Variables ]:
//   - mTxWithholdingDetectionGuardian : Mutex for thread safety
//   - mKeyHeightAtLastTxWithholdingCheck : Last checked key height
//   - mLastTxWithholdingWarningTime : Timestamp of last warning (cooldown)
//   - mTxWithholdingWarningCount : Session warning counter
//
// [ Methods ]:
//   - checkForTransactionWithholding() : Main detection logic
//   - getTxWithholdingWarningCount()   : Get warning count for diagnostics
//   - resetTxWithholdingDetection()    : Reset state (used by phantom mode)
//
// ============================================================================

/// @brief Performs the core transaction withholding detection check.
/// @details This method is called by the Vitals Monitoring thread when it
///          detects that transactions have been waiting in the mem-pool for
///          an extended period. It implements:
///            1. Early exit checks (no TXs, invalid data)
///            2. Key block threshold comparison (>= 3 key blocks)
///            3. Warning cooldown enforcement (60 seconds between warnings)
///            4. Detailed warning message generation with diagnostic advice
///
///          The warning message suggests possible causes:
///            - Malicious leaders withholding transactions
///            - Network packet filtering / connectivity issues
///            - Software bugs preventing TX processing
///
///          And recommends enabling Phantom Leader Mode for debugging.
///
/// @param currentKeyHeight The current key block height from the leader.
/// @param memPoolTxCount Number of unprocessed transactions in mem-pool.
/// @param oldestTxKeyHeight Estimated key height when oldest TX was added.
/// @return true if a warning was issued, false otherwise.
///
/// @see mVitalsMonitoringThreadF() - Caller of this method
/// @see getMemPoolWithholdingStats() - Provides input data
bool CBlockchainManager::checkForTransactionWithholding(
	uint64_t currentKeyHeight,
	uint64_t memPoolTxCount,
	uint64_t oldestTxKeyHeight)
{
	std::lock_guard<std::mutex> lock(mTxWithholdingDetectionGuardian);

	// Early exit if no transactions in mem-pool
	if (memPoolTxCount == 0)
	{
		return false;
	}

	// Early exit if oldest transaction key height is invalid (0 means unknown)
	if (oldestTxKeyHeight == 0)
	{
		return false;
	}

	// Calculate how many key blocks have passed since the oldest transaction
	uint64_t keyBlocksWaited = 0;
	if (currentKeyHeight > oldestTxKeyHeight)
	{
		keyBlocksWaited = currentKeyHeight - oldestTxKeyHeight;
	}

	// Check if threshold exceeded
	if (keyBlocksWaited >= TX_WITHHOLDING_KEY_BLOCK_THRESHOLD)
	{
		uint64_t now = std::time(0);

		// Respect cooldown period to avoid flooding logs
		if ((now - mLastTxWithholdingWarningTime) >= TX_WITHHOLDING_WARNING_COOLDOWN_SEC)
		{
			mLastTxWithholdingWarningTime = now;
			mTxWithholdingWarningCount++;

			// Build detailed warning message
			std::stringstream warningMsg;
			warningMsg << "POTENTIAL TRANSACTION WITHHOLDING DETECTED! "
			           << memPoolTxCount << " transaction(s) have been waiting in mem-pool for "
			           << keyBlocksWaited << " key block(s). "
			           << "Oldest TX added at key height " << oldestTxKeyHeight
			           << ", current key height is " << currentKeyHeight << ". "
			           << "This may indicate: (1) Malicious leaders withholding transactions, "
			           << "(2) Network packet filtering, (3) A software bug preventing TX processing. "
			           << "Consider enabling Phantom Leader Mode ('chain -phantom on') for debugging.";

			mTools->logEvent(
				warningMsg.str(),
				"Liveness Monitor",
				eLogEntryCategory::localSystem,
				10,
				eLogEntryType::warning,
				eColor::cyborgBlood
			);

			return true;
		}
	}

	// Update tracking state
	mKeyHeightAtLastTxWithholdingCheck = currentKeyHeight;

	return false;
}

/// @brief Gets the count of transaction withholding warnings issued this session.
/// @details This counter is incremented each time checkForTransactionWithholding()
///          issues a warning. It can be used for:
///            - Diagnostics (displayed in 'chain -phantom status')
///            - Alerting systems to escalate if warnings are frequent
///            - Testing to verify detection is working
///          The counter is reset when resetTxWithholdingDetection() is called.
/// @return Number of warnings issued since node startup or last reset.
uint64_t CBlockchainManager::getTxWithholdingWarningCount()
{
	std::lock_guard<std::mutex> lock(mTxWithholdingDetectionGuardian);
	return mTxWithholdingWarningCount;
}

/// @brief Resets all transaction withholding detection state to initial values.
/// @details Clears all tracking state including:
///            - mKeyHeightAtLastTxWithholdingCheck → 0
///            - mLastTxWithholdingWarningTime → 0
///            - mTxWithholdingWarningCount → 0
///
///          This is typically called when:
///            - Phantom Leader Mode statistics are reset ('chain -phantom reset')
///            - A major chain reorganization occurs
///            - User wants fresh detection state after resolving issues
///
///          A notification is logged to confirm the reset action.
void CBlockchainManager::resetTxWithholdingDetection()
{
	std::lock_guard<std::mutex> lock(mTxWithholdingDetectionGuardian);
	mKeyHeightAtLastTxWithholdingCheck = 0;
	mLastTxWithholdingWarningTime = 0;
	mTxWithholdingWarningCount = 0;

	mTools->logEvent(
		"Transaction withholding detection state has been reset.",
		"Liveness Monitor",
		eLogEntryCategory::localSystem,
		5,
		eLogEntryType::notification,
		eColor::lightCyan
	);
}

// Transaction Withholding Detection Implementation - END
// ============================================================================

void  CBlockchainManager::incLocalTotalRewardBy(BigInt value)
{
	std::lock_guard<std::mutex> lock(mFieldsGuardian);
	mTotalLocalReward += value;
}

BigInt  CBlockchainManager::getLocalTotalReward()
{
	std::lock_guard<std::mutex> lock(mFieldsGuardian);
	return mTotalLocalReward;
}
uint64_t CBlockchainManager::getLocallyMinedDataBlocks()
{
	std::lock_guard<std::mutex> lock(mFieldsGuardian);
	return mLocallyMinedDataBlocks;
}

void CBlockchainManager::incLocallyMinedDataBlocks()
{
	std::lock_guard<std::mutex> lock(mFieldsGuardian);
	mLocallyMinedDataBlocks++;
}
uint64_t CBlockchainManager::getLocallyMinedKeyBlocks()
{
	std::lock_guard<std::mutex> lock(mFieldsGuardian);
	return mLocallyMinedKeyBlocks;
}

void CBlockchainManager::incLocallyMinedKeyBlocks()
{
	std::lock_guard<std::mutex> lock(mFieldsGuardian);
	mLocallyMinedKeyBlocks++;
}

/**
 * @brief Retrieves recent warnings.
 *
 * This function returns all warnings from the internal warnings map
 * which are not older than the timeout defined in `CGlobalSecSettings::getWarningsTimeout()`.
 * All older warnings are automatically removed from the map.
 *
 * @return std::vector<WarningInfo> A list of warnings along with their details such as text, source, and timestamp.
 */
std::vector<WarningInfo> CBlockchainManager::getWarnings() {
	std::lock_guard<std::mutex> lock(mWarningsGuardian);
	std::vector<WarningInfo> recentWarnings;
	uint64_t currentTime = std::time(0);
	uint64_t warningsTimeout = CGlobalSecSettings::getWarningsTimeout();

	for (auto it = mWarnings.begin(); it != mWarnings.end();) {
		if ((currentTime - it->second.timestamp) <= warningsTimeout) {
			recentWarnings.push_back(it->second);
			++it;
		}
		else {
			it = mWarnings.erase(it);
		}
	}
	return recentWarnings;
}

void CBlockchainManager::missionAbort()
{
	std::lock_guard<std::mutex> lock(sFieldsGuardian);
	sMissionAbort = true;
}

bool CBlockchainManager::getIsMissionAbort()
{
	std::lock_guard<std::mutex> lock(sFieldsGuardian);
	return sMissionAbort;
}

/**
 * @brief Logs a warning into the Blockchain Manager's warnings map.
 *
 * This function logs a warning, along with its source, to the internal warnings map
 * with the current timestamp. It is used to keep track of all the warnings
 * generated during the application's runtime.
 *
 * @param text The warning message.
 * @param source The source or context of the warning.
 *
 * @return void
 */
void CBlockchainManager::logWarning(const std::string& text, const std::string& source) {
	std::lock_guard<std::mutex> lock(mWarningsGuardian);
	uint64_t currentTime = std::time(0);
	WarningInfo info = { text, source, currentTime };
	mWarnings[currentTime] = info;
}

void CBlockchainManager::clearWarnings() {
	std::lock_guard<std::mutex> lock(mWarningsGuardian);
	mWarnings.clear();
}
uint64_t  CBlockchainManager::getTXProcessedLocally()
{
	std::lock_guard<std::mutex> lock(mFieldsGuardian);
	return mTXProcessedLocally;
}




void  CBlockchainManager::incTXProcessedLocally(uint64_t by)
{
	std::lock_guard<std::mutex> lock(mFieldsGuardian);
	mTXProcessedLocally += by;
}

uint64_t CBlockchainManager::getReportedDifficulty()
{

	if (getMode() != eBlockchainMode::TestNet)
	{
		return 0;
	}
	bool ok = false;
	uint64_t EMAInterval = 0;
	uint64_t SMAInterval = 0;
	if (!getIsReady())
		return 0;
	return static_cast<uint64_t>(getMinDIfficultyForBlock(nullptr, ((getSyncPercentage() == 100 || getIsForkingAlternativeHistory()) ? std::time(0) : 0),
		true, false, ok, nullptr, EMAInterval, SMAInterval));
}
uint64_t CBlockchainManager::getLastSpottedCoreVersion() {
	std::shared_lock lock(mSharedGuardian);
	return mLastSpottedCoreVersion;
}

void CBlockchainManager::setLastSpottedCoreVersion(uint64_t version) {
	std::unique_lock lock(mSharedGuardian);
	mLastSpottedCoreVersion = version;
}

/// <summary>
/// Independent Vitals Monitoring Thread - Continuous Health Check for All Sub-Systems
///
/// ============================================================================
/// PURPOSE
/// ============================================================================
/// This background thread continuously monitors the health and liveness of all
/// critical GRIDNET OS sub-systems. It runs independently from the main blockchain
/// processing loop to ensure issues are detected even if other components hang.
///
/// ============================================================================
/// MONITORED SUB-SYSTEMS
/// ============================================================================
/// 1. Formation Flow Manager    - Block formation thread liveness
/// 2. Verification Flow Manager - Block verification thread liveness
/// 3. Blockchain Controller     - Main processing loop responsiveness
/// 4. Network Manager           - Network communication health
/// 5. UDT Server                - UDP transport layer status
/// 6. DTI Server                - Data transport interface health
/// 7. WWW Server (Mongoose)     - HTTP API responsiveness
/// 8. Live Transaction Manager  - Domain cache refresh status
/// 9. State Domain Manager      - Persistent state availability
/// 10. Mem-Pool Health          - Transaction withholding detection
///
/// ============================================================================
/// TRANSACTION WITHHOLDING DETECTION (Liveness Monitoring)
/// ============================================================================
/// A key security feature that detects potential transaction withholding attacks:
///
/// [ Attack Scenario ]:
///   Malicious leaders produce key blocks but refuse to include pending
///   transactions in data blocks, causing transactions to remain stuck
///   in mem-pools network-wide while the blockchain appears to progress.
///
/// [ Detection Mechanism ]:
///   1. Queries mem-pool for oldest unprocessed transaction timestamp
///   2. Calculates how many key block intervals have elapsed since TX arrival
///   3. If TX has waited >= TX_WITHHOLDING_KEY_BLOCK_THRESHOLD (3) key blocks:
///      - Issues warning via logEvent() with eLogEntryType::warning
///      - Suggests enabling Phantom Leader Mode for debugging
///   4. Respects TX_WITHHOLDING_WARNING_COOLDOWN_SEC (60s) between warnings
///
/// [ Related Methods ]:
///   - getMemPoolWithholdingStats()      : Gets oldest TX time and count
///   - checkForTransactionWithholding()  : Performs threshold check and warning
///   - getAverageSMAKeyBlockInterval()   : Gets average key block timing
///
/// [ Integration with Phantom Leader Mode ]:
///   When withholding is detected, users are advised to enable Phantom Mode
///   via 'chain -phantom on' to simulate transaction processing locally and
///   verify whether transactions CAN be processed (ruling out TX validity issues).
///
/// ============================================================================
/// EXECUTION INTERVAL
/// ============================================================================
/// Vitals are checked every 10 seconds (monitorVitalsEverySec = 10).
/// Each check updates the allVitalsLookingGood flag and logs any anomalies.
///
/// ============================================================================
/// WARNING CATEGORIES
/// ============================================================================
/// All warnings are logged with:
///   - Category: eLogEntryCategory::localSystem
///   - Type: eLogEntryType::warning
///   - Color: eColor::cyborgBlood (critical) or appropriate severity color
///   - Source: "Vitals Monitoring" or "Liveness Monitor"
///
/// </summary>
void CBlockchainManager::mVitalsMonitoringThreadF()
{
	//Local Variables - BEGIN
	uint64_t now = std::time(0);
	std::shared_ptr<CTools> tools = getTools();
	uint64_t lastVitalsCheck = 0;
	uint64_t monitorVitalsEverySec = 10;
	uint64_t lastDTIServerLoopRun = 0;
	uint64_t lastDSMSync = 0;
	uint64_t lastNetworkLoop = 0;
	bool allVitalsLookingGood = true;
	std::shared_ptr<CUDTConversationsServer> udtS;
	std::shared_ptr<CDTIServer>  dtis;
	std::shared_ptr<CTransactionManager> verficationFlowManager = getVerificationFlowManager();
	std::shared_ptr<CTransactionManager> formationFlowManager = getFormationFlowManager();
	std::shared_ptr<CNetworkManager> nm;
	std::shared_ptr<CWWWServer> wwwServer;
	uint64_t lastControllerLoopRun = 0;
	CKeyChain chain(false);
	CKeyChain localLeaderChain(false);
	uint64_t lasVFMLoopRun = 0;
	uint64_t lastNewVersionNotificationAtVersion = 0;
	uint64_t lasFFMLoopRun = 0;
	uint64_t lastMongooseEvent = 0;
	uint64_t ABPM = 0;
	std::shared_ptr<CSettings> settings = getSettings();
	uint64_t syncPercentage = 0;
	uint64_t lastTimeValidBlockProcessed = 0;
	bool syncStuck = false;
	std::shared_ptr<CBlockHeader>  heaviestChainproofLeader = getHeaviestChainProofLeader();
	eBlockchainMode::eBlockchainMode bmMode = getMode();
	double currentDiff = 0;
	bool ok = false;
	std::stringstream diffReport;
	std::shared_ptr<CStatusBarHub> barHub = CStatusBarHub::getInstance();
	uint64_t EMAInterval = 0;
	uint64_t SMAInterval = 0;
	std::stringstream miningBarReport, syncBarReport, hardwareBarReport;
	bool localNodeIsLeader = false;
	uint64_t lastTimeLocalLeaderCheck = 0;
	uint64_t requiredTX = 0;
	bool lowOnMemory = false;
	uint64_t lastDSMIdleReport = 0;
	bool lowOnCPU = false;
	uint64_t lastAlternativeForkReport = 0;
	size_t RAMavailable = tools->getFreeHotStorage();
	size_t RAMused = tools->getUsedHotStorage();
	double CPUGlobalLoadPerc = tools->getCPUUsagePercentage();
	double CPULocalLoadPerc = tools->getAppCPUUsagePercentage();
	double RAMGBavailable = (double)RAMavailable / (double)1000000000;
	double RAMGBused = (double)RAMused / (double)1000000000;
	uint64_t pendingTX = 0;
	uint64_t currentBPM = 0;
	uint64_t currentHeight = 0;
	uint64_t hph = 0;
	bool isConnectivityOptimal = false;
	std::shared_ptr<CBlockHeader> hpl;
	std::shared_ptr<CTransactionManager> flowTM = getVerificationFlowManager();
	bool GRIDAnalysisModeActive = false;
	//Local Variables - END

	//Monitor Status of external vital components - BEGIN
	while (getIsVitalsMonitorToBeRunning())
	{
		//Refresh Variables - BEGIN
		if (!flowTM)
		{
			flowTM = getVerificationFlowManager();
		}

		lowOnMemory = false;
		hardwareBarReport.str("");
		diffReport.str("");
		syncBarReport.str("");
		miningBarReport.str("");

		//Hardware Stats - BEGIN
		RAMused = tools->getUsedHotStorage();
		RAMavailable = tools->getFreeHotStorage();
		RAMGBused = (double)RAMused / (double)1000000000;
		RAMGBavailable = (double)RAMavailable / (double)1000000000;
		//Hardware Stats - END

		//Refresh Variables - END
		Sleep(500);
		now = std::time(0);
		syncStuck = false;
		setIsVitalsMonitorRunning(true);
		if (getIsReady())
		{
			if (heaviestChainproofLeader)
			{
				diffReport << "[Difficulty]:";

				//whenever we are fully synced OR attempting to produce an alternative history of events (as opposed to the global heaviest best known)
				//we are to report difficulty relative to the current moment.
				currentDiff = getMinDIfficultyForBlock(nullptr, ((getSyncPercentage() == 100 || getIsForkingAlternativeHistory()) ? std::time(0) : 0),
					true, false, ok, nullptr, EMAInterval, SMAInterval);


				if (ok)
				{
					std::string cleaned = tools->cleanDoubleStr(std::to_string(currentDiff), 3);
					diffReport << cleaned;
				}
				else
				{
					diffReport << "0";
				}

				diffReport << " [SMA]:" + tools->cleanDoubleStr(std::to_string(SMAInterval ? ((double)SMAInterval / (double)60) : 0), 1) + " min";
				diffReport << " [EMA]:" + tools->cleanDoubleStr(std::to_string(EMAInterval ? ((double)EMAInterval / (double)60) : 0), 1) + " min";
				barHub->setCustomStatusBarText(bmMode, DIFFICULTY_DIAL_BAR_ID, diffReport.str());
			}

		}

		//time


		if ((now - lastVitalsCheck) > monitorVitalsEverySec)
		{
			//Refresh Variables - BEGIN
			CPUGlobalLoadPerc = tools->getCPUUsagePercentage();
			CPULocalLoadPerc = tools->getAppCPUUsagePercentage();
			if (CPULocalLoadPerc > CPUGlobalLoadPerc)
			{
				CPUGlobalLoadPerc = max(100, CPULocalLoadPerc + tools->genRandomNumber(5, 15) + 0.3);
			}
			RAMused = tools->getUsedHotStorage();
			RAMavailable = tools->getFreeHotStorage();
			ABPM = getAPM();
			syncPercentage = getSyncPercentage();
			lastControllerLoopRun = getLastControllerLoopRun();
			lastVitalsCheck = now;
			allVitalsLookingGood = true;//YES, set to true in each loop iteration. Member field set based on it by the end.
			lastTimeValidBlockProcessed = getLastTimeValidBlockProcessed();
			settings->getCurrentKeyChain(chain, false, false);
			//check up on network manager
			verficationFlowManager = getVerificationFlowManager();
			formationFlowManager = getFormationFlowManager();
			nm = getNetworkManager();
			if (nm)
			{
				GRIDAnalysisModeActive = nm->getIsNetworkTestMode();
			}
			//Refresh Variables - END

			//Operational Logic - BEGIN




			//Forking an alternative history - BEGIN

			if (getIsForkingAlternativeHistory())
			{
				allVitalsLookingGood = false;

				if ((now > lastAlternativeForkReport) && ((now - lastAlternativeForkReport) > 5))
				{
					lastAlternativeForkReport = now;
					tools->logEvent("Forking an alternative history of events!", "Vitals Monitoring", eLogEntryCategory::localSystem, 1,
						eLogEntryType::warning, eColor::lightPink);
				}

			}
			//Forking an alternative history - END

			//Hardware Bar - BEGIN ---
			if (GRIDAnalysisModeActive == false)
			{
				//RAM Usage - BEGIN
				if (RAMused > ((double)RAMavailable) * ((double)RAMavailable * 0.9))
				{
					//low on memory
					lowOnMemory = true;
				}

				hardwareBarReport << tools->getColoredString("[RAM available]:", eColor::blue) << WS <<
					tools->getColoredString(tools->cleanDoubleStr(std::to_string(RAMGBavailable)), RAMGBavailable >= EASY_RAM_GB_REQUIRED ? eColor::lightGreen : eColor::lightPink) << " GB";

				if (RAMGBavailable <= 2)
				{
					allVitalsLookingGood = false;

					tools->logEvent("You are running out of RAM!", "Vitals Monitoring", eLogEntryCategory::localSystem, 1,
						eLogEntryType::warning, eColor::lightPink);
				}

				hardwareBarReport << WS << tools->getColoredString("[RAM used]:", eColor::blue) << WS <<
					tools->getColoredString(tools->cleanDoubleStr(std::to_string(RAMGBused)), (lowOnMemory == false ? eColor::lightGreen : eColor::lightPink)) << " GB";

				//RAM Usage - END

				//CPU Usage - BEGIN

				if (CPUGlobalLoadPerc > 90)
				{
					lowOnCPU = true;
					allVitalsLookingGood = false;

					tools->logEvent("Your CPU is running HOT!", "Vitals Monitoring", eLogEntryCategory::localSystem, 1,
						eLogEntryType::warning, eColor::lightPink);
				}

				hardwareBarReport << WS << tools->getColoredString("[CPU]:", eColor::blue) << WS <<
					tools->getColoredString(tools->cleanDoubleStr(std::to_string(CPUGlobalLoadPerc)), (!lowOnCPU ? eColor::lightGreen : eColor::lightPink)) << " %";

				hardwareBarReport << WS << tools->getColoredString("[Local CPU]:", eColor::blue) << WS <<
					tools->cleanDoubleStr(std::to_string(CPULocalLoadPerc)) << " %";


				//CPU Usage - END

				barHub->setCustomStatusBarText(bmMode, HARDWARE_BAR_ID, hardwareBarReport.str());
			}
			//Hardware Bar - END ---

			// Still Bootstrapping - BEGIN

			if (!getIsReady() || CSettings::getIsGlobalAutoConfigInProgress())
			{
				tools->logEvent("Skipping Vitals' analysis - node still in a bootstrap sequence..", "Vitals Monitoring", eLogEntryCategory::localSystem, 1,
					eLogEntryType::notification);
				continue;
			}

			// Still Bootstrapping - END

			// Sync State - BEGIN
			currentHeight = getCachedHeight();
			hpl = getHeaviestChainProofLeader();
			currentBPM = getAPM();
			hph = 0;

			if (hpl)
			{
				hph = hpl->getHeight();
			}

			if (hpl && currentHeight < hph && ((hph - currentHeight) > 10))
			{
				std::string timeLeftStr;

				if (currentBPM != 0)
				{
					double minLeft = (((double)(hph - currentHeight)) / (double)currentBPM);
					timeLeftStr = tools->secondsToFormattedString(max(minLeft * 60, 1.0));
				}
				else
				{
					// Handle the case where currentBPM is 0.
					timeLeftStr = tools->getColoredString("Unknown", eColor::lightPink);
				}
				isConnectivityOptimal = nm->getIsConnectivityOptimal();

				if (!isConnectivityOptimal)
				{
					allVitalsLookingGood = false;
				}
				syncBarReport << tools->getColoredString("[Sync Time Left]:", eColor::lightCyan) << timeLeftStr;

				syncBarReport << WS << "[Connectivity]: "
					<< (isConnectivityOptimal
						? tools->getColoredString("Good", eColor::lightGreen)
						: tools->getColoredString("Poor", eColor::lightPink));				//syncBarReport << WS << "[Active]: " << nm->getUDTServer()->getMaxSessionsCount() ? tools->getColoredString("Good", eColor::lightGreen) : tools->getColoredString("Poor", eColor::lightPink);

				barHub->setCustomStatusBarText(bmMode, SYNC_BAR_ID, syncBarReport.str());
			}
			// Sync State - END


			//Mining Bar - BEGIN

			//Earnings - BEGIN
			if (!GRIDAnalysisModeActive)
			{
				miningBarReport << WS << "[Earned]: " << tools->getColoredString(tools->attoToGNCStr(getLocalTotalReward()), eColor::orange) << " GNC";
			}
			//Earnings - END

			//Local Leader Checks - BEGIN

			//Am I the Leader?
			if ((now - lastTimeLocalLeaderCheck) > 5)
			{
				lastTimeLocalLeaderCheck = now;
				if (amITheLeader(chain, localLeaderChain))
				{
					localNodeIsLeader = true;
					setLocalNodeIsLeaderCached(true);
				}
				else
				{
					localNodeIsLeader = false;
					setLocalNodeIsLeaderCached(false);
				}
			}

			miningBarReport << " [Leading]: " << (localNodeIsLeader ? tools->getColoredString("YES", eColor::orange) : tools->getColoredString("no", eColor::greyWhiteBox));

			//Local Leader Checks - END

			//locally mined blocks - BEGIN
			// key blocks
			miningBarReport << WS << "Mined [KB]:" << tools->getColoredString(std::to_string(getLocallyMinedKeyBlocks()), eColor::orange);
			//data blocks
			miningBarReport << WS << "[DB]:" << std::to_string(getLocallyMinedDataBlocks());
			//locally mined blocks - END

			//Processed TX - BEGIN
			// locally
			miningBarReport << WS << "[LTX]:" << std::to_string(getTXProcessedLocally());
			// globally
			miningBarReport << WS << "[GTX]:" << std::to_string(flowTM->getTransactionsCounter());
			//Processed TX - END

			//Mem Pool - BEGIN
			requiredTX = flowTM->getReqMemPoolObjectsCached();
			pendingTX = flowTM->getTXInMemPoolCached();
			// pending TXs
			miningBarReport << WS << "[PTX]:" << std::to_string(pendingTX);

			// pending TXs
			miningBarReport << WS << "[RTX]:" << tools->getColoredString(std::to_string(requiredTX), (requiredTX > 1 && (requiredTX > pendingTX)) ? eColor::lightPink : eColor::lightGreen);

			//Mem Pool - END

			barHub->setCustomStatusBarText(bmMode, MINING_DIAL_BAR_ID, miningBarReport.str());
			//Mining Bar - END


			//Automated Feedback Loop Checks - BEGIN

			if (getIsSynchronizationPaused())
			{
				tools->logEvent("Synchronization is deliberately paused.", "Vitals Monitoring", eLogEntryCategory::localSystem, 10,
					eLogEntryType::warning, eColor::cyborgBlood);
			}
			else
			{
				//Block Acceptance - BEGIN
				if (getTimeSinceOperational() > (60 * 15) && ABPM == 0 && (syncPercentage <= 99 || syncPercentage > 100))
				{
					allVitalsLookingGood = false;
					setSyncIsStuck(true);
					tools->logEvent("Synchronization seems stuck.", "Vitals Monitoring", eLogEntryCategory::localSystem, 10,
						eLogEntryType::warning, eColor::cyborgBlood);
					syncStuck = true;

				}

				//Block Acceptance - END
			}

			// Core Version Check - BEGIN
			if (verficationFlowManager)
			{
				uint64_t localVersion = CGlobalSecSettings::getVersionNumber();
				uint64_t lastSpottedVersion = getLastSpottedCoreVersion();

				if (lastSpottedVersion != localVersion && (lastSpottedVersion > lastNewVersionNotificationAtVersion))
				{
					lastNewVersionNotificationAtVersion = lastSpottedVersion;
					allVitalsLookingGood = false;
					tools->logEvent(
						"New GRIDNET Core version detected (local: " +
						CGlobalSecSettings::coreVersionToString(localVersion) +
						", detected: " + CGlobalSecSettings::coreVersionToString(lastSpottedVersion) + ")",
						"Vitals Monitoring",
						eLogEntryCategory::localSystem,
						10,
						eLogEntryType::warning,
						eColor::cyborgBlood
					);
				}
			}
			// Core Version Check - END
		
			//Verification Flow - BEGIN
			if (verficationFlowManager)
			{
				lasVFMLoopRun = verficationFlowManager->getLastControllerLoopRun();

				//Flow Loop
				if (now > lasVFMLoopRun && (now - lasVFMLoopRun) > 60)
				{
					allVitalsLookingGood = false;
					tools->logEvent("Verification Flow Thread seems dead.", "Vitals Monitoring", eLogEntryCategory::localSystem, 10,
						eLogEntryType::warning, eColor::cyborgBlood);
				}
			}
			//Verification Flow - END

			// LIVE Transaction Manager - BEGIN
			std::shared_ptr<CTransactionManager> ltm = getLiveTransactionsManager();

			if (!ltm)
			{
				allVitalsLookingGood = false;
				tools->logEvent("Live Transaction Manager is not available.", "Vitals Monitoring", eLogEntryCategory::localSystem, 10,
					eLogEntryType::warning, eColor::cyborgBlood);
			}
			else
			{
				if (ltm->getKeepPersistentDB() == false)
				{
					allVitalsLookingGood = false;
					tools->logEvent("Persistent Meta Data Cache is not being maintained.", "Vitals Monitoring", eLogEntryCategory::localSystem, 10,
						eLogEntryType::warning, eColor::cyborgBlood);
				}
				std::shared_ptr<CStateDomainManager> pSDM = ltm->getPersistentStateDomainManager();

				// Persistent State Domain Manager Checks - BEGIN
				if (pSDM  == nullptr)
				{
					allVitalsLookingGood = false;
					tools->logEvent("Persistent Meta Data State Domain Manager is not available.", "Vitals Monitoring", eLogEntryCategory::localSystem, 10,
						eLogEntryType::warning, eColor::cyborgBlood);
				}
				else
				{
					if (!pSDM->getAllCachedDomainMetadataCount())
					{
						allVitalsLookingGood = false;
						tools->logEvent("No State Domain Meta Data is available", "Vitals Monitoring", eLogEntryCategory::localSystem, 10,
							eLogEntryType::warning, eColor::cyborgBlood);
					}
				}
				// Persistent State Domain Manager Checks - END
				uint64_t lastRun = ltm->getLastControllerLoopRun();
				if (lastRun && (now > lastRun) && ((lastRun - now) > (15*60)))
				{
					allVitalsLookingGood = false;
					tools->logEvent("Live Transaction Manager is not active. Domain Cache is not being refreshed.", "Vitals Monitoring", eLogEntryCategory::localSystem, 10,
						eLogEntryType::warning, eColor::cyborgBlood);
				}
			}

			// LIVE Transaction Manager - END

			// ============================================================================
			// Transaction Withholding Detection - BEGIN
			// ============================================================================
			// [ Purpose ]: Detects when transactions are stuck in the mem-pool while
			//              key blocks continue to be produced. This may indicate a
			//              transaction withholding attack or software bug.
			// [ Mechanism ]: Compares the timestamp of the oldest unprocessed TX with
			//                key block production timestamps. Issues warning if TX has
			//                been waiting for >= 3 key blocks.
			// ============================================================================
			if (ltm && formationFlowManager)
			{
				// Get mem-pool statistics for withholding detection
				uint64_t oldestTxTime = 0;
				uint64_t memPoolTxCount = 0;

				if (ltm->getMemPoolWithholdingStats(oldestTxTime, memPoolTxCount))
				{
					// Only check if there are transactions waiting
					if (memPoolTxCount > 0 && oldestTxTime > 0)
					{
						// Get the current key block info
						std::shared_ptr<CBlock> keyLeader = getLeader(true); // true = key block only
						if (keyLeader && keyLeader->getHeader())
						{
							uint64_t currentKeyHeight = keyLeader->getHeader()->getKeyHeight();

							// Calculate how many seconds the oldest TX has been waiting
							uint64_t waitingSeconds = 0;
							if (now > oldestTxTime)
							{
								waitingSeconds = now - oldestTxTime;
							}

							// Estimate key blocks passed based on average interval
							// Use 30 minutes (1800 seconds) as conservative key block interval
							uint64_t avgKeyBlockInterval = getAverageSMAKeyBlockInterval();
							if (avgKeyBlockInterval == 0) avgKeyBlockInterval = 1800; // Default 30 min

							uint64_t estimatedKeyBlocksWaited = waitingSeconds / avgKeyBlockInterval;

							// Check for potential withholding
							if (estimatedKeyBlocksWaited >= TX_WITHHOLDING_KEY_BLOCK_THRESHOLD)
							{
								// Use the centralized check method which handles cooldowns
								if (checkForTransactionWithholding(
									currentKeyHeight,
									memPoolTxCount,
									currentKeyHeight - estimatedKeyBlocksWaited))
								{
									allVitalsLookingGood = false;
								}
							}
						}
					}
				}
			}
			// Transaction Withholding Detection - END
			// ============================================================================

			//Formation Flow - BEGIN

			if (formationFlowManager)
			{
				lasFFMLoopRun = formationFlowManager->getLastControllerLoopRun();

				//Flow Loop
				if (now > lasFFMLoopRun && (now - lasFFMLoopRun) > 60)
				{
					allVitalsLookingGood = false;
					tools->logEvent("Formation Flow Thread seems dead.", "Vitals Monitoring", eLogEntryCategory::localSystem, 10,
						eLogEntryType::warning, eColor::cyborgBlood);
				}
			}

			//Formation Flow - END

			//Blockchain Manager's Main Loop - BEGIN
			if ((now > lastControllerLoopRun) && (now - lastControllerLoopRun) > 60)
			{
				allVitalsLookingGood = false;
				tools->logEvent("Blockchain Controller seems dead.", "Vitals Monitoring", eLogEntryCategory::localSystem, 10,
					eLogEntryType::warning, eColor::cyborgBlood);
			}

			//Blockchain Manager's Main Loop - END

			//Network Manager - BEGIN
			if (nm)
			{

				if (!wwwServer)
				{
					wwwServer = nm->getWWWServer();
				}

				udtS = nm->getUDTServer();
				dtis = nm->getDTIServer();

				lastNetworkLoop = nm->getLastTimeControllerThreadRun();

				//is Network Manager stuck?
				if ((now > lastNetworkLoop) && (now - lastNetworkLoop) > 60)
				{
					allVitalsLookingGood = false;
					tools->logEvent("Network Manager seems dead.", "Vitals Monitoring", eLogEntryCategory::localSystem, 10,
						eLogEntryType::warning, eColor::cyborgBlood);
				}
				//is internal WWW server stuck?
				if (wwwServer)
				{
					lastMongooseEvent = wwwServer->getLastMongooseEvent();
					if (now > lastMongooseEvent && (now - lastMongooseEvent) > 10)
					{
						allVitalsLookingGood = false;
						tools->logEvent("HTTTP and Web-Socket system seems frozen.", "Vitals Monitoring", eLogEntryCategory::localSystem, 10,
							eLogEntryType::warning, eColor::cyborgBlood);
					}
				}
				//is block processing stuck?
				if (getTimeSinceOperational() > (60 * 15) && (now > lastTimeValidBlockProcessed) && (now - lastTimeValidBlockProcessed) > (60 * 30))
				{
					syncStuck = true;
					setSyncIsStuck(true);//this will affect the frequency at which long chains-proofs are requested.
					allVitalsLookingGood = false;

					if ((now - lastDSMIdleReport) > (60 * 10))
					{
						lastDSMIdleReport = now;
						tools->logEvent("DSM idle for too long.", "Vitals Monitoring", eLogEntryCategory::localSystem, 10,
							eLogEntryType::warning, eColor::cyborgBlood);
					}
				}

				lastDSMSync = nm->getLastTimeDSMControllerThreadRun();

				//how about DSM synchronization loop?
				if ((now > lastDSMSync) && (now - lastDSMSync) > 60)
				{
					allVitalsLookingGood = false;
					tools->logEvent("DSM synchronization seems dead.", "Vitals Monitoring", eLogEntryCategory::localSystem, 10,
						eLogEntryType::warning, eColor::cyborgBlood);
				}

				if (dtis)
				{
					lastDTIServerLoopRun = dtis->getLastControllerLoopRun();

					//DTI Server's main loop
					if ((now > lastDTIServerLoopRun) && (now - lastDTIServerLoopRun) > 60)
					{
						allVitalsLookingGood = false;
						tools->logEvent("DTI Server seems dead.", "Vitals Monitoring", eLogEntryCategory::localSystem, 10,
							eLogEntryType::warning, eColor::cyborgBlood);
					}

				}

				//Network Manager's overall status

				//is running check
				if (nm->getStatus() != eManagerStatus::running)
				{
					allVitalsLookingGood = false;
					tools->logEvent("Network Manager not Operational.", "Vitals Monitoring", eLogEntryCategory::localSystem, 10,
						eLogEntryType::warning, eColor::cyborgBlood);
				}

				//DTI sub-system
				if (nm->getInitializeDTIServer() && (!dtis || nm->getDTIServer()->getStatus() != eManagerStatus::running))
				{
					allVitalsLookingGood = false;
					tools->logEvent("DTI System not Operational.", "Vitals Monitoring", eLogEntryCategory::localSystem, 10,
						eLogEntryType::warning, eColor::cyborgBlood);
				}

				//UDT sub-system - BEGIN
				if (nm->getInitializeUDTServer() && (!udtS || nm->getUDTServer()->getStatus() != eManagerStatus::running))
				{
					allVitalsLookingGood = false;
					tools->logEvent("UDT System not Operational.", "Vitals Monitoring", eLogEntryCategory::localSystem, 10,
						eLogEntryType::warning, eColor::cyborgBlood);
				}

				if (udtS)
				{
					// UDT Conversations' Cleanup Mechanics - BEGIN
					uint64_t lastUDTConvCleanup = udtS->getLastTimeCleanedUp();
					if ((lastUDTConvCleanup < now) && (now - lastUDTConvCleanup) > (60 * 10))
					{
						allVitalsLookingGood = false;

						tools->logEvent("UDT conversations' cleanup mechanics seem stuck.", "Vitals Monitoring", eLogEntryCategory::localSystem, 10,
							eLogEntryType::warning, eColor::cyborgBlood);
					}
					// UDT Conversations' Cleanup Mechanics - END
				}

				//UDT sub-system - END

				//Kademlia sub-system
				if (!nm->getIsKademliaOperational())
				{
					allVitalsLookingGood = false;
					tools->logEvent("Kademlia not Operational.", "Vitals Monitoring", eLogEntryCategory::localSystem, 10,
						eLogEntryType::warning, eColor::cyborgBlood);
				}

				//Messages' Exchange
				if ((now - nm->getLastTimeChatMsgsRouted()) > 10)
				{
					{
						allVitalsLookingGood = false;
						tools->logEvent("Chat Messages' Distribution Service seems down.", "Vitals Monitoring", eLogEntryCategory::localSystem, 10, eLogEntryType::warning, eColor::cyborgBlood);
					}
				}


			}

			//Network Manager - END

			//Automated Feedback Loop Checks - END

			if (!syncStuck)
			{
				setSyncIsStuck(false);
			}

			if (allVitalsLookingGood)
			{
				clearWarnings();
				setVitalsGood(true);
				tools->logEvent("All looking Good.", "Vitals Monitoring", eLogEntryCategory::localSystem, 1, eLogEntryType::notification, eColor::lightGreen);
			}
			else
			{
				setVitalsGood(false);
			}


		}

	}
	setIsVitalsMonitorRunning(false);
}
/**
 * @brief Processes block breakpoints
 *
 * Handles both pre-execution and post-execution breakpoint states for blocks,
 * providing comprehensive block state information at each stage.
 *
 * @param block Block being processed
 * @param state Execution stage (pre/post)
 * @return bool True if processing should continue
 */
bool CBlockchainManager::processBreakpoints(
	std::shared_ptr< CBlock> block,
	eBreakpointState::eBreakpointState stage)
{
	// Preliminaries - BEGIN
	std::shared_ptr<CTools> tools = getTools();
	if (!tools) return false;

	std::shared_ptr<CBreakpointFactory> bf = getBreakpointFactory();
	if (!bf) return false;

	// Early return if no active breakpoints for this block
	if (!bf->getBlockBreakpointCount(true) && !bf->hasActiveBreakpoints(block->getID(), eBreakpointState::none)) {
		return true;
	}

	// Preliminaries - END

	// Local Variables - BEGIN
	std::stringstream ss;
	std::string newLine = "\n";
	std::vector<std::shared_ptr<CBreakpoint>> hitBreakpoints;
	// Local Variables - END

	// Operational Logic - BEGIN

	// Gather block information
	const std::shared_ptr<CBlockHeader>& header = block->getHeader();
	if (!header) return false;

	// Check active breakpoints and gather hit breakpoints
	auto checkBreakpoints = [&](const std::vector<std::shared_ptr<CBreakpoint>>& bps) {
		for (const auto& bp : bps) {
			if (bp->isActive()) {

				hitBreakpoints.push_back(bp);
				bp->setState(stage, header->getHash()); // transition breakpoint state to current stage
				bp->hit(); // increment hit counter
			}
		}
		};

	// Check height breakpoints
	auto heightBreakpoints = bf->getBreakpointsAtHeight(header->getHeight());
	checkBreakpoints(heightBreakpoints);

	// Check key height breakpoints
	auto keyHeightBreakpoints = bf->getBreakpointsAtKeyHeight(header->getKeyHeight());
	checkBreakpoints(keyHeightBreakpoints);

	// Check block ID breakpoints
	auto blockIDBreakpoints = bf->getBreakpointsForBlock(header->getHash());
	checkBreakpoints(blockIDBreakpoints);

	if (!hitBreakpoints.empty()) {
		tools->activateView(eViewState::eventView);
		Sleep(1000);
		// Build header based on state
		ss << newLine << tools->getColoredString(
			stage == eBreakpointState::preExecution ?
			"[ Block Pre-Execution Breakpoint Hit ]" :
			"[ Block Post-Execution Breakpoint Hit ]",
			eColor::orange) << newLine;

		// Get current state trie perspective
		std::vector<uint8_t> currentPerspective = mLiveStateDB->getPerspective();
		std::string perspectiveStr = tools->base58CheckEncode(currentPerspective);

		ss << tools->getColoredString("System State: ", eColor::lightCyan)
			<< perspectiveStr << newLine;

		// Block Identification
		ss << newLine << tools->getColoredString("[ Block Identification ]", eColor::blue) << newLine;
		ss << tools->getColoredString("Block ID: ", eColor::lightCyan)
			<< tools->base58CheckEncode(header->getHash()) << newLine;
		ss << tools->getColoredString("Block Height: ", eColor::lightCyan)
			<< header->getHeight() << newLine;
		ss << tools->getColoredString("Key Block Height: ", eColor::lightCyan)
			<< header->getKeyHeight() << newLine;
		ss << tools->getColoredString("Block Type: ", eColor::lightCyan)
			<< (header->isKeyBlock() ? "Key Block" : "Data Block") << newLine;
		ss << tools->getColoredString("Miner ID: ", eColor::lightCyan)
			<< tools->bytesToString(header->getMinersID()) << newLine;
		ss << tools->getColoredString("Timestamp: ", eColor::lightCyan)
			<< tools->timeToString(header->getSolvedAtTime()) << newLine;
		ss << tools->getColoredString("Parent Block: ", eColor::lightCyan)
			<< tools->base58CheckEncode(header->getParentID()) << newLine;
		ss << tools->getColoredString("Transactions: ", eColor::lightCyan)
			<< header->getNrOfTransactions() << newLine;

		// Execution State Information - BEGIN
		if (stage == eBreakpointState::postExecution) {
			ss << newLine << tools->getColoredString("[ Execution Information ]", eColor::blue) << newLine;
			//ss << tools->getColoredString("Processing Result: ", eColor::lightCyan)
			//	<< translateVerificationResult(mLastBlockVerificationResult.getStatus()) << newLine;
			//ss << tools->getColoredString("Leader: ", eColor::lightCyan)
			//	<< (mLastBlockVerificationResult.isLeader() ? "Yes" : "No") << newLine;
			//ss << tools->getColoredString("Stored: ", eColor::lightCyan)
			//	<< (mLastBlockWasStored ? "Yes" : "No") << newLine;
		}
		// Execution State Information - END

		// Add breakpoint statistics
		ss << newLine << tools->getColoredString("[ Breakpoint Details ]", eColor::blue) << newLine;

		// Number breakpoints for reference
		for (size_t i = 0; i < hitBreakpoints.size(); ++i) {


			const auto& bp = hitBreakpoints[i];

			if (bp->isActive() == false)
			{
				// notice: user might have disable all breakpoint or unitary ones during breakpoints' traversal
				continue;
			}

			ss << tools->getColoredString("[Breakpoint " + std::to_string(i + 1) + "]", eColor::orange) << newLine;
			ss << tools->getColoredString("Type: ", eColor::lightCyan)
				<< (bp->getType() == eBreakpointType::block ? "Block" : "Unknown") << newLine;
			ss << tools->getColoredString("Hit Count: ", eColor::lightCyan)
				<< bp->getHitCount() << newLine;
			ss << tools->getColoredString("Condition: ", eColor::lightCyan);
			switch (bp->getCondition()) {
			case eBreakpointCondition::height:
				ss << "Block Height (" << bp->getValueString() << ")";
				break;
			case eBreakpointCondition::keyHeight:
				ss << "Key Block Height (" << bp->getValueString() << ")";
				break;
			case eBreakpointCondition::blockID:
				ss << "Block ID (" << bp->getValueString() << ")";
				break;
			default:
				ss << "Unknown";
			}
			ss << newLine << "---" << newLine;
		}

		// State Change Information (only in post-execution) - BEGIN
		if (stage == eBreakpointState::postExecution) {
			ss << newLine << tools->getColoredString("[ State Changes ]", eColor::blue) << newLine;
			bool stateChanged = false;

			// Compare with pre-execution state if available
			std::vector<uint8_t> preExecPerspective;
			for (const auto& bp : hitBreakpoints) {
				// Retrieve pre-execution perspective stored during pre-execution
				if (!bp->getPreExecutionPerspective().empty()) {
					preExecPerspective = bp->getPreExecutionPerspective();
					break;
				}
			}

			std::vector<uint8_t> currentPerspective = mLiveStateDB->getPerspective();

			if (!preExecPerspective.empty()) {
				if (preExecPerspective != currentPerspective) {
					stateChanged = true;
				}
			}

			ss << tools->getColoredString("State Change: ", eColor::lightCyan)
				<< (stateChanged ?
					tools->getColoredString("Yes", eColor::lightGreen) :
					tools->getColoredString("No", eColor::orange)) << newLine;
		}
		// State Change Information - END

		// Command Help - BEGIN
		ss << newLine << tools->getColoredString("Commands:", eColor::blue) << newLine;
		ss << tools->getColoredString("continue", eColor::lightCyan) << " - Continue execution" << newLine;
		ss << tools->getColoredString("skip N", eColor::lightCyan) << " - Disable breakpoint N (e.g., 'skip 1')" << newLine;
		ss << tools->getColoredString("(s)kip all", eColor::lightCyan) << " - Disable all hit breakpoints" << newLine;
		ss << "                Hit " << tools->getColoredString("Enter", eColor::lightCyan) << " to Continue" << newLine;
		ss << "Choose option ";
		// Command Help - END

		//tools->writeLine(ss.str(), true, false, eViewState::eventView, "Debugging", false , false);
		//Sleep(500);
		// For pre-execution, store the current perspective in the breakpoint for later comparison

		if (stage == eBreakpointState::preExecution) {
			for (const auto& bp : hitBreakpoints) {

				if (bp->getState() == eBreakpointState::preExecution || bp->getState() == eBreakpointState::none)
				{
					bp->setPreExecutionPerspective(currentPerspective);
				}
			}
		}

		// User Interaction Loop - BEGIN
		bool continueExecution = false;
		while (!continueExecution) {
			std::string response = tools->askString(ss.str(), "continue", "Debugger", true, true, 0);
			response = tools->trim(response);

			if (response.empty() || tools->iequals(response, "continue")) {
				continueExecution = true;
			}
			else if (tools->iequals(response, "skip all") || tools->iequals(response, "s")) {
				for (const auto& bp : hitBreakpoints) {
					bp->deactivate();
					tools->logEvent("Deactivated breakpoint of type " + std::to_string(static_cast<int>(bp->getCondition())),
						"Breakpoint", eLogEntryCategory::localSystem, 5, eLogEntryType::notification);
				}
				continueExecution = true;
			}
			else if (response.substr(0, 5) == "skip ") {
				std::string numStr = response.substr(5);
				uint64_t num;
				if (tools->stringToUint(numStr, num) && num >= 1 && num <= hitBreakpoints.size()) {
					hitBreakpoints[num - 1]->deactivate();
					tools->logEvent("Deactivated breakpoint " + std::to_string(num),
						"Breakpoint", eLogEntryCategory::localSystem, 5, eLogEntryType::notification);

					// Ask for confirmation to continue
					std::string confirmMsg = tools->getColoredString(
						"Breakpoint " + std::to_string(num) + " disabled. Continue execution? (yes/no)",
						eColor::lightCyan
					) + newLine;

					if (tools->askYesNo(confirmMsg, true, "Debugger", true, true)) {
						continueExecution = true;
					}
				}
				else {
					ss.str(""); // Clear stringstream
					ss << tools->getColoredString("Invalid breakpoint number. Use 1 to " +
						std::to_string(hitBreakpoints.size()), eColor::lightPink) << newLine;
					tools->writeLine(ss.str());
				}
			}
			else {
				ss.str(""); // Clear stringstream
				ss << tools->getColoredString("Invalid command. Use 'continue', 'skip N', or 'skip all'",
					eColor::lightPink) << newLine;
				tools->writeLine(ss.str());
			}
		}
		// User Interaction Loop - END

		// Clean up breakpoint states if we're in post-execution
		if (stage == eBreakpointState::postExecution) {
			for (const auto& bp : hitBreakpoints) {
				bp->clear();
			}
		}

		// Return true to continue execution
		return true;
	}

	// Return true if no breakpoints were hit
	return true;
}

// This function syncs the verified chain proof with cold storage. 
// The sync is only done if certain conditions are met to optimize performance and minimize 
// the number of cold storage writes and BER encoded vectors' preparations.
bool CBlockchainManager::syncChainProofsWithColdStorage(bool forceIt)
{



	//only verified chain proof needs to be 'synced'.
	//recall that it is allowed to stay behind the center of the Events' Horizon for performance reasons
	//to lower the amount of cold storage writes (and more of BER encoded vectors' preparations).
	bool res = false;
	uint64_t now = std::time(0);

	if (!getIsReady())
	{// prevent these mechanics from overwriting chain proofs during the initial Bootstrap sequence.
		return false;
	}
	std::shared_ptr<CNetworkManager> nm = getNetworkManager();

	if (nm->getIsNetworkTestMode() || getIsRestartNeeded())
	{
		return false;
	}

	// Check if the cached height is greater than the height at which the verified chain was synced with cold storage
	if (forceIt || (getCachedHeight() > getVerifiedSyncedWithCSAtHeight()))
	{
		// Check if the time since the last sync of verified chain proof with cold storage
		// is less than the maximum allowed interval for syncing verified chain proof
		if (forceIt || ((now - getChainProofCSSyncTime(eChainProof::verified)) > CGlobalSecSettings::getSyncVerifiedChainProofMaxInterval()))
		{

			clearVPInColdStorageBehindCount();
			// Sync the verified chain proof with cold storage
			syncChainProofToColdStorage(eChainProof::verified);
			return true;
		}
	}

	if (forceIt || ((now - getChainProofCSSyncTime(eChainProof::heaviest)) > CGlobalSecSettings::getSyncHeaviestChainProofMaxInterval()))
	{
		clearVPInColdStorageBehindCount();
		// Sync the verified chain proof with cold storage
		syncChainProofToColdStorage(eChainProof::heaviest);
		return true;
	}

	return res;
}


void CBlockchainManager::mControllerThreadF()
{
	if (CGRIDNET::getInstance()->getIsShuttingDown())
	{
		return;
	}
	//Local Variables - BEGIN
	std::string tName = "Blockchain Manager (" + getTools()->blockchainmodeToString(getMode()) + ")";
	getTools()->SetThreadName(tName.data());
	setStatus(eManagerStatus::eManagerStatus::running);
	
	bool wasPaused = false;
	if (getStatus() != eManagerStatus::eManagerStatus::running)
		setStatus(eManagerStatus::eManagerStatus::running);
	uint64_t justPushedFromHeaviestChainProof = 0;
	uint64_t blocksScheduleForDownload = 0;
	std::vector<std::shared_ptr<CConversation>> conversations;
	std::shared_ptr<SE::CScriptEngine> thread;

	//Local Variables - END

	/*
	* [DOCUMENTATION]
	* The system aims to construct the 'heaviest', in terms of both the cumulative proof-of-work and the amount of data, history of events.
	* Chain-Proof is an ordered sequence of block headers.
	* Nodes deliver (possibly partial) chain-proofs which are compared against the heaviest chain-proof available locally.
	* In either case, the heaviest chain-proof is always reconstructed locally.
	*
	* Blocks from within of the heaviest chain-proof are scheduled for download and enqueued for processing immediately upon arrival.
	* IMPORTANT: it is up to the Blockchain Manager whether a block gets saved, discarded, or EVEN whether it is marked as available locally upon arrival.
	*
	* There are two ways a block can make its way into the processing queue:
	* 1) each block is ensued immediately upon arrival.
	* 2) WHEN, and only if, the processing queue is EMPTY, the system attempts to proceed with commitHeaviestChainProofBlocks() which attempts
	* to enqueue all blocks referenced within of the heaviest chain-proof. Missing blocks are thus scheduled for download. Those available are enqueued
	* for processing immediately. The function check whether processing of every block resulted in a valid Perspective, which is required to be available locally.
	* If any of the above factors is not met, the block is either re-processed or re-scheduled for download. The function is state full and employs various optimizations
	* to keep track of which blocks have been made available locally (through a Robin Hood cache) and caches the index up-to-which blocks from within of the Heaviest Chain-Proof have
	* been already successfully processed.
	*
	* Network Manager takes care of scheduling of blocks' downloads and individual downloads once scheduled.
	* Download of any given block is scheduled only through a single (random) node at a time, until the Network Tasks either completes or times out.
	* Block exchange takes place only through UDT (crypto-incentivization) conversations, that have been marked for participation in the Decentralized State-Machine Synchronization sub-protocol.
	*
	* The Heaviest Chain-Proof usually remains in contrast with the Verified Chain-Proof.
	* IMPORTANT: The latter can be modified ONLY during a Flow.
	* It represents the locally verified and available history of events.

	*/

	// Thread Local Variables - BEGIN
	std::shared_ptr<CNetworkManager> networkManager = getNetworkManager();
	std::shared_ptr<CTools> tools = getTools();
	eBlockchainMode::eBlockchainMode mode = getMode();

	size_t lastVitalsCheck = 0;
	size_t now = 0;
	bool isSandbox = (mode == eBlockchainMode::LIVESandBox || mode == eBlockchainMode::TestNetSandBox);
	uint64_t lastNot = 0;
	CSolidStorage* ss = getSolidStorage();
	size_t lastUIUpdateCheck = 0;
	bool firstUIUpdateCheck = true;
	uint64_t lastTimeThrottlingWarningIssued = 0;
	uint64_t lastTimeThrottlingWarning = 0;
	bool uiDataAvailable = false;
	bool enteredMaintenance = false;
	bool uiUpdatePackageAvailable = false;
	uint64_t lastBootstrapStatusUpdate = 0;
	std::shared_ptr<CWWWServer> wwwServer;
	std::shared_ptr<CGRIDNET> gridnet = CGRIDNET::getInstance();
	std::string lastBoostrapDesc, currentBoostrapDesc;
	std::shared_ptr<CStatusBarHub> barHub = CStatusBarHub::getInstance();
	// Thread Local Variables - END

	//Operational Logic - BEGIN
	while (getStatus() != eManagerStatus::eManagerStatus::stopped)
	{
		barHub->cleanStatusBars(getMode());
		if (mode == eBlockchainMode::TestNet || mode == eBlockchainMode::LIVE)
		{
			syncChainProofsWithColdStorage();
		}
		pingtLastControllerLoopRun();
		//cleanBlockStats(); <- no need, we are now using a moving average with buckets.
		if (CSettings::getIsGlobalAutoConfigInProgress())
		{
			currentBoostrapDesc = CSettings::getGlobalAutoConfigStepDescription();

			if ((now - lastBootstrapStatusUpdate) > 5 || !tools->doStringsMatch(lastBoostrapDesc, currentBoostrapDesc))
			{
				lastBootstrapStatusUpdate = now;
				lastBoostrapDesc = currentBoostrapDesc;
				tools->logEvent(tools->getColoredString(currentBoostrapDesc, eColor::lightCyan), "Bootstrap Stage", eLogEntryCategory::localSystem, 1, eLogEntryType::notification, eColor::orange);

			}
		}
		//Prevent Windows Machine from falling asleep - BEGIN
		// The following sets the appropriate flags to prevent system to go into sleep mode.
		SetThreadExecutionState(ES_CONTINUOUS | ES_SYSTEM_REQUIRED | ES_AWAYMODE_REQUIRED);

		// This clears the flags and allows the system to sleep normally.
		SetThreadExecutionState(ES_CONTINUOUS);
		//Prevent Windows Machine from falling asleep - END

		//reset variables - begin
		now = std::time(0);
		blocksScheduleForDownload = 0;
		justPushedFromHeaviestChainProof = 0;
		networkManager = getNetworkManager();
		if (networkManager)
		{
			wwwServer = networkManager->getWWWServer();
		}
		//reset variables - end

		//Chain Proof Cold Storage Sync - BEGIN



		//Chain Proof Cold Storage Sync - END

		// Solid Storage Cleanup - BEGIN
		if (mSolidStorage->isCleanupNeeded()) {
			mSolidStorage->performCleanup();
		}
		// Solid Storage Cleanup - END
	

		//UI update - BEGIN
		if (wwwServer && mode == eBlockchainMode::TestNet)
		{
			ss = getSolidStorage();
			if ((now - lastUIUpdateCheck) > 360)
			{
				if (ss)
				{
					uiDataAvailable = ss->checkUIDataAvailable();
					tools->logEvent("Checking for local UI update package..", "Local Update", eLogEntryCategory::localSystem, 10, eLogEntryType::notification);

					uiUpdatePackageAvailable = ss->updateUIPackage(firstUIUpdateCheck, true);
					if (uiUpdatePackageAvailable)
					{
						tools->logEvent("New UI update package available..", "Local Update", eLogEntryCategory::localSystem, 10, eLogEntryType::notification, eColor::lightGreen);

						if (uiDataAvailable)
						{
							enteredMaintenance = true;
							wwwServer->setIsMaintenanceMode(true);
							//getNetworkManager()->main
							//enterMaintenanceMode(); DO NOT enter maintenance mode of BM  from within of the THREAD!!!!!
						}
						ss->updateUIPackage(firstUIUpdateCheck);
						firstUIUpdateCheck = false;
						if (enteredMaintenance)
						{
							wwwServer->setIsMaintenanceMode(false);
							//exitMaintenanceMode();  DO NOT enter maintenance mode of BM from within of the THREAD!!!!!
						}
					}
					else
					{
						tools->logEvent("No UI update package available..", "Local Update", eLogEntryCategory::localSystem, 10, eLogEntryType::notification);
					}

				}
				lastUIUpdateCheck = now;
			}
		}

		//UI update - END
		if (!CGRIDNET::getInstance()->getIsShuttingDown())
		{
			if (mode == eBlockchainMode::TestNet || mode == eBlockchainMode::LIVE)
			{
				if (gridnet->getIsModeToBeOperational(mode))
				{
					updateStatysticsToFile();
				}

			}
			std::this_thread::sleep_for(std::chrono::milliseconds(5));
			wasPaused = false;
		}
		else
		{

		}
		if (getStatusChange() == eManagerStatus::eManagerStatus::paused)
		{
			setStatus(eManagerStatus::eManagerStatus::paused);
			setStatusChange(eManagerStatus::eManagerStatus::initial);

			while (getStatusChange() == eManagerStatus::eManagerStatus::initial)
			{

				if (!wasPaused)
				{
					tools->writeLine("My thread operations were friezed. Halting..");
					wasPaused = true;
				}
				std::this_thread::sleep_for(std::chrono::milliseconds(100));
			}
		}
		//TESTS - heaviest chain-proof reset - BEGIN
		if (isHeaviestChainProofResetToBeMade())
		{
			assertGN(resetHeaviestChainProof());
		}
		//TESTS - heaviest chain-proof reset - END


		//clean-up - BEGIN
		cleanUpRecentlyProcessedChainProofs();
		//clean-up - END

		std::shared_ptr<CBlock> block;
		uint64_t processedBlocks = 0;
		bool isProcessingLongChainProof = getIsProcessingLongChainProof();
		bool isAutoConfigInProgress = CSettings::getIsGlobalAutoConfigInProgress();
		uint64_t activeCheckpoints = 0;
		bool throttleCPU = false;

		if (!(isAutoConfigInProgress || isProcessingLongChainProof) && !getInNetworkTestingMode())
		{

			//CPU Throttling if stuck - BEGIN
			if (getIsSyncStuck())
			{
				if ((now - lastTimeThrottlingWarning) > 10)
				{
					lastTimeThrottlingWarning = now;
					getTools()->logEvent("Synchronization is stuck. Throttling down CPU usage..", eLogEntryCategory::localSystem, 1, eLogEntryType::warning, eColor::lightPink);
				}

				throttleCPU = true;
			}
			else
			{
				throttleCPU == false;
			}

			//CPU Throttling if stuck - END

			//await till ready

			if (!getIsReady())
			{
				if ((std::time(0) - lastNot) > 10)
				{
					getTools()->logEvent("Postponing blocks' processing until ready..", eLogEntryCategory::localSystem, 2, eLogEntryType::notification, eColor::orange);
					lastNot = std::time(0);
				}
			}
			else
			{

				while (isSandbox == false && (block = popBlock()) != nullptr)
					//Process the immediate pending Block(s) - BEGIN
				{
					if (throttleCPU)
					{
						if ((now - lastTimeThrottlingWarningIssued) > (15 * 60000))
						{
							logWarning("Throttling down CPU usage due to synchronization being stuck.");
							lastTimeThrottlingWarningIssued = now;
						}
						Sleep(2000);
					}

#if ENABLE_FLOW_DETAILED_LOGS_BM == 1
					std::stringstream debugLog;
					CProcessVerifiablesRAII loggerRAII(debugLog, tools);
#endif
					//setBlockProcessingStatus(eBlockProcessingStatus::eBlockProcessingStatus::preProcessing);

					//support of a case in which the locally verified chain-proof is actually better than the global heaviest chain-proof
					//this might happen at the early stage of bootstrapping of the network

					//cleanBlockStats(); //not needed as we now rely on a moving average.
					block->setIsCheckpointed(isCheckpointed(block->getHeader()));


					//Processing - the block has a chance to become a leader which is when scheduled by the local scheduler.
					//Validating - the block has no chance to become a leader during this processing. It was just received from the network.

					getTools()->logEvent(block->getScheduledByLocalScheduler() ? tools->getColoredString("Processing", eColor::orange) : tools->getColoredString("Pre-Validating", eColor::none)
						+ " block for height:" + std::to_string(block->getHeader()->getHeight()), "Block Scheduler", eLogEntryCategory::localSystem, 5, eLogEntryType::notification, eColor::orange);

					// Pre-execution breakpoint processing - BEGIN
					/*
					if (!processBreakpoints(block, eBreakpointState::preExecution)) {
						mTools->logEvent("Breakpoint pre-processing for block " + mTools->base58CheckEncode(block->getID()) + mTools->getColoredString(" failed", eColor::cyborgBlood),
							"Debugging", eLogEntryCategory::localSystem, 10, eLogEntryType::failure);
					}
					// Pre-execution breakpoint processing - END
					*/
					std::vector<std::string> log;
					volatile  bool wasScheduledByLocalScheduler = block->getScheduledByLocalScheduler();

			
					CBlockchainManager::eBlockProcessingResult result = processBlock(block, log);
					block->setDoTurboFlow(false);

					// Post-execution breakpoint processing
					/*
					if (!processBreakpoints(block, eBreakpointState::postExecution)) {
						mTools->logEvent("Breakpoint post-processing for block " + mTools->base58CheckEncode(block->getID()) + mTools->getColoredString(" failed", eColor::cyborgBlood),
							"Debugging", eLogEntryCategory::localSystem, 10, eLogEntryType::failure);
					}
					*/
					activeCheckpoints = getActiveCheckpointsCount();
		
			
					getTools()->logEvent(std::to_string(activeCheckpoints) + " checkpoints remain.", eLogEntryCategory::localSystem, 2, eLogEntryType::notification, eColor::orange);
					updateStatysticsToFile();
					addBlockToProcessedBlocks(block->getID());
					setBlockProcessingStatus(eBlockProcessingStatus::PostProcessing);

					std::vector<CTransaction> blockTransactions;

					//BLOCK POST-PROCESSING - BEGIN
					CReceipt rec;
					std::string sourceCode;
					BigInt txValue = 0;
					std::string recipient;
					std::shared_ptr<CBlockHeader> header = block->getHeader();

					// Block Meta Data - BEGIN

					std::shared_ptr<CBlockDesc> blockDesc = block->getDescription();// attempt to re-use existing block meta-data
					// notice that meta-data might be present due to a recent fork.

					switch (result)
					{
					case CBlockchainManager::eBlockProcessingResult::appended: // block was appended to the chain.

						// Transactions' Meta-Data Cache Support - BEGIN

						if (!blockDesc)
						{// only if not available generate block meta-data
							blockDesc = createBlockDescription(block, true, true);
							//											^	 ^---- does global TX meta-data registration
							//											\__ generates TX advanced meta data (decompiles byte-code and 
							//												infers high-level meta-data from source code).
							// 
							// [Important] : a dedicated Receipts Cache is populated by the end of Flow so to reuse already instantiated Receipts.
							block->setDescription(blockDesc);
						}

#if ENABLE_FLOW_DETAILED_LOGS_BM == 1
						debugLog << "[ Meta-Data Total Effective Reward ]: " << tools->formatGNCValue(blockDesc->getTotalReward(true)) << "\n";
						debugLog << "[ Meta-Data Paid Effective Reward ]: " << tools->formatGNCValue(blockDesc->getTotalPaid(true)) << "\n";
					
#endif
						if (blockDesc->getTotalReward(true) != block->getHeader()->getTotalBlockReward(true) || 
							blockDesc->getTotalPaid(true) != block->getHeader()->getPaidToMiner(true))
						{
							assertGN(false);
						}


						// Block Meta Data - END
							// Transactions' Meta-Data Cache Support - END



						// Global Blockchain Incremental Security Analysis - BEGIN
						updateSecAnalysis(block);

						// Global Blockchain Incremental Security Analysis - END

						// Block Cache Cleanup - BEGIN
						if (block->getHeader()->isKeyBlock()) {
							uint64_t currentTime = std::time(0);
							uint64_t lastCleanTime = getLastTimeBlockCacheCleaned();

							// Since we're using uint64_t, we need to handle wraparound case
							if (currentTime >= lastCleanTime &&
								(currentTime - lastCleanTime) >= CGlobalSecSettings::getMinBlockCacheCleanupInterval()) {
								cleanCache();
								pingLastTimeBlockCacheCleaned();
							}
						}
						// Block Cache Cleanup - END
						//Hard-Fork Procedure (final stage) - BEGIN
						if (block->getIsLeadingAHardFork())
						{
							tools->writeLine(tools->getColoredString(u8"✅", eColor::lightGreen) + tools->getColoredString(" A Hard-Fork succeeded!\a\a\a", eColor::lightCyan), true, true, eViewState::GridScriptConsole, "Hard Fork");

							if (getIsOperatorLeadingAHardFork())
							{
								std::ostringstream ss;

								ss << "[Height]:" << WS << std::to_string(block->getHeader()->getHeight()) << WS << "[ID]:" << WS << tools->base58CheckEncode(block->getID());
								tools->writeLine(ss.str(), true, true, eViewState::GridScriptConsole, "Hard Fork Lead");
								tools->writeLine(tools->getColoredString("Operator, remember to include the above Checkpoint in Source.", eColor::orange), true, true, eViewState::GridScriptConsole, "Hard Fork", false);
								uint64_t winnningPoW = 0;

								tools->writeLine(tools->getColoredString("Updating Heaviest Chain Proof with Verified Chain Proof..", eColor::orange), true, true, eViewState::GridScriptConsole, "Hard Fork", false);
								eChainProofValidationResult::eChainProofValidationResult cpValRes = eChainProofValidationResult::invalidGeneral;
								eChainProofUpdateResult::eChainProofUpdateResult overRes = analyzeAndUpdateChainProof(mVerifiedChainProof, cpValRes, mHeaviestChainProof, winnningPoW);// todo: this fails. investigate.
								std::string test = std::to_string(overRes);


								if (overRes != eChainProofUpdateResult::updatedLocalBestKnown)
								{
									tools->writeLine(tools->getColoredString("Failed to update Heaviest Chain-Proof with Verified Chain Proof.", eColor::lightPink), true, true, eViewState::GridScriptConsole, "Hard Fork", false);

								}
								else
								{
									tools->writeLine(tools->getColoredString("Heaviest Chain-Proof update succeeded.", eColor::lightGreen), true, true, eViewState::GridScriptConsole, "Hard Fork", false);

								}

								if (syncChainProofsWithColdStorage(true))
								{
									tools->writeLine(tools->getColoredString("Chain Proofs were flushed to Cold-Storage.", eColor::orange), true, true, eViewState::GridScriptConsole, "Hard Fork", false);
								}
								else
								{
									tools->writeLine(tools->getColoredString("Error flushing chain proofs to Cold-Storage.", eColor::lightPink), true, true, eViewState::GridScriptConsole, "Hard Fork", false);
								}
								setIsOperatorLeadingAHardFork(false);// DISABLE the Hard-Fork Leading Mode now.

							}
						}
						//Hard-Fork Procedure (final stage) - END


						tools->writeLine(tools->getColoredString(u8"✅", eColor::lightGreen) + " Blockchain Manager chose to append the new block");
						tools->writeLine(tools->getColoredString("\n\nNew blockchain height: ", eColor::blue) + tools->getColoredString(std::to_string(block->getHeader()->getHeight()), eColor::lightCyan));
						tools->writeLine(tools->getColoredString("New Live Perspective: ", eColor::blue) + tools->getColoredString(tools->base58CheckEncode(mLiveStateDB->getPerspective()), eColor::lightCyan));
						tools->writeLine("Number of known State Domains:" + std::to_string(getKnownStateDomainsCount()));

						//Notify All the Conversations - BEGIN
						if (networkManager)
						{
							conversations = networkManager->getAllConversations(true, false, false);
						}
						else
						{
							tools->logEvent("network manager unavailable during block commitment!", "Blockchain Manager", eLogEntryCategory::network, 1000, eLogEntryType::failure, eColor::cyborgBlood);
						}

						for (uint64_t i = 0; i < conversations.size(); i++)
						{
							thread = conversations[i]->getSystemThread();

							if (thread)
							{
								//the below is performed *asynchronously( (false) i.e. non-blocking
								SE::vmFlags vf = thread->getFlags();
								conversations[i]->notifyVMStatus(eVMStatus::newPerspectiveAvailable, vf, 0, thread->getID(), std::vector<uint8_t>(), conversations[i]->getID(), false, 0);
							}
						}
						if (networkManager && !networkManager->notifyAboutNewBlock(block->getHeader()))//DSM-sync protocol
						{
							tools->logEvent("Couldn't dispatch network notifications about block.", eLogEntryCategory::network, 10, eLogEntryType::failure, eColor::cyborgBlood);
						}
						//Notify All the Conversations - END

						break;
					case CBlockchainManager::eBlockProcessingResult::discarded:
						if (block->getIsLeadingAHardFork())
						{
							tools->writeLine(tools->getColoredString(u8"❎", eColor::cyborgBlood) + tools->getColoredString("Hard-Fork FAILED!\a\a\a", eColor::lightPink), 
								true, true, eViewState::GridScriptConsole, "Hard Fork");

						}
						tools->writeLine(tools->getColoredString(u8"❎", eColor::cyborgBlood) + " Blockchain Manager chose to discard the block.");

						

						break;
					case justSaved:
						tools->writeLine(tools->getColoredString("The block was just saved to Cold Storage.", eColor::orange));

						break;

					}

					processedBlocks++;


					if (processedBlocks % 10 == 0)
					{
						if (!getIsSynchronizationPaused())
						{
							processHeaviestChainProof(mode, justPushedFromHeaviestChainProof, blocksScheduleForDownload, tools);// so that blocks are still being scheduled for download while the blocks'
						}
					}
					//queue is being processed

					if (processedBlocks > 30)
					{
						tools->logEvent("Taking a break from block-processing ..", "Blockchain Manager", eLogEntryCategory::localSystem, 1, eLogEntryType::notification, eColor::orange);
						break;// so that the rest of the controller's logic has a chance to execute.
					}

				}//Process the immediate pending Block - END
			}
			if (!getIsSynchronizationPaused())
			{
				processHeaviestChainProof(mode, justPushedFromHeaviestChainProof, blocksScheduleForDownload, tools);
			}
		}
		else
		{
			if (lastVitalsCheck == now)
			{
				if (isProcessingLongChainProof)
				{
					tools->logEvent("Postponing block-processing, node is still bootstrapping..", "Blockchain Manager", eLogEntryCategory::localSystem, 1, eLogEntryType::notification, eColor::orange);
				}
				else if (isProcessingLongChainProof)
				{
					tools->logEvent("Postponing block-processing, node is processing a long Chain-Proof..", "Blockchain Manager", eLogEntryCategory::localSystem, 1, eLogEntryType::notification, eColor::orange);
				}
			}
		}
		setBlockProcessingStatus(eBlockProcessingStatus::idle);

		if (wasPaused)
		{
			tools->writeLine("My thread operations are now resumed. Commencing further..");
			setStatus(eManagerStatus::eManagerStatus::running);
		}


		if (getStatusChange() == eManagerStatus::eManagerStatus::stopped)
		{
			setStatusChange(eManagerStatus::eManagerStatus::initial);
			setStatus(eManagerStatus::eManagerStatus::stopped);


		}

	}
	//Operational Logic - END
	setStatus(eManagerStatus::eManagerStatus::stopped);
}

void CBlockchainManager::processHeaviestChainProof(eBlockchainMode::eBlockchainMode mode, uint64_t& justPushedFromHeaviestChainProof, uint64_t& blocksScheduleForDownload, std::shared_ptr<CTools>& tools)
{
	if (mode == eBlockchainMode::TestNet)
	{
		{//only if no immediate block pending..i.e. when block processing queue is empty..
		 //TRY TO TO COMMIT BLOCKS FROM THE HEAVIEST CHAIN-PROOF - BEGIN

			eChainProofCommitResult::eChainProofCommitResult  res = commitHeaviestChainProofBlocks(justPushedFromHeaviestChainProof, blocksScheduleForDownload);


			switch (res)
			{
			case eChainProofCommitResult::blocksEnqued:
				tools->logEvent("Enqueued " + std::to_string(justPushedFromHeaviestChainProof) + " blocks from the Heaviest chain-proof."
					+ (blocksScheduleForDownload ? " Scheduled " + tools->getColoredString(std::to_string(blocksScheduleForDownload), eColor::lightCyan) + " for download." : ""), eLogEntryCategory::localSystem, 1, eLogEntryType::notification);
				break;
			case eChainProofCommitResult::idle:
				tools->logEvent("Processing of the Heaviest Chain-Proof had no effect." + (blocksScheduleForDownload ? " Scheduled " + tools->getColoredString(std::to_string(blocksScheduleForDownload), eColor::lightCyan) + " for download." : ""), eLogEntryCategory::localSystem, 0, eLogEntryType::notification);
				break;

			case eChainProofCommitResult::empty:
				tools->logEvent(tools->getColoredString("Local heaviest chain-proof is empty.", eColor::lightPink), eLogEntryCategory::localSystem, 1, eLogEntryType::notification);
				break;

			case eChainProofCommitResult::error:
				tools->logEvent(mTools->getColoredString("There was an error while processing the Heaviest Chain-Proof.", eColor::cyborgBlood), eLogEntryCategory::localSystem, 1, eLogEntryType::failure);
				break;

			default:
				break;
			}
			//TRY TO TO COMMIT BLOCKS FROM THE HEAVIEST CHAIN-PROOF - END

		}
	}
}

eManagerStatus::eManagerStatus CBlockchainManager::getStatusChange()
{
	std::lock_guard<std::recursive_mutex> lock(mStatusGuardian);
	return mStatusChange;
}

void CBlockchainManager::setStatusChange(eManagerStatus::eManagerStatus status)
{
	std::lock_guard<std::recursive_mutex> lock(mStatusGuardian);
	mStatusChange = status;
}
/// <summary>
/// Updates only the Core version information to a statistics file.
/// This is a lightweight alternative to the full updateStatysticsToFile method.
/// </summary>
void CBlockchainManager::updateVersionToFile()
{
	
	// Get tools instance
	std::shared_ptr<CTools> tools = CTools::getInstance();
	if (!tools) return; // Cannot proceed without tools

	// Get storage to access data directory
	CSolidStorage* storage = getSolidStorage();
	if (!storage) return; // Cannot get dataDir without storage


	tools->writeToFileSS("CoreVersion.txt", CGlobalSecSettings::getVersionStr(), true, storage);
}

/// <summary>
/// Updates statistics files with raw data values for external monitoring (e.g., LARS).
/// Writes simple numeric values or strings to standardized filenames using the original tools->writeToFile pattern.
/// Includes Core version.
/// </summary>
/// <param name="memPoolStatsOnly">If true, only updates mempool usage stats.</param>
void CBlockchainManager::updateStatysticsToFile(bool memPoolStatsOnly)
{

	std::shared_ptr<CTools> tools = getTools();
	//pre-validations - BEGIN
	uint64_t lastTime = getLastTimeStatsToFile();
	uint64_t now = tools->getTime();
	if (lastTime > now || (now - lastTime) < 700)
		return;
	//std::lock_guard<std::recursive_mutex> lock(blockQueueGuardian);
	//std::lock_guard<std::recursive_mutex> lock2(mHeaviestPathGuardian);
	pingLastTimeStatsToFile();
	//pre-validations - END

	//Local Variables - BEGIN
	std::shared_ptr<CBlock> leader = getLeader();
	std::shared_ptr<CBlock> keyLeader = getLeader(true);
	std::shared_ptr<CTransactionManager> flowTM = getVerificationFlowManager();
	std::shared_ptr<CStateDomainManager> sdm = getStateDomainManager();
	uint64_t effectiveKH = 0;
	std::string dataDir = getSolidStorage()->getMainDataDir();
	bool dataDirAvailable = dataDir.size() > 0 ? true : false;
	dataDir += "\\";
	double effectiveDF = 1;
	//Local Variables - END
	std::string filePath;
	if (dataDirAvailable)
	{
		if (!memPoolStatsOnly)
		{
			filePath = ("BCHeight.txt");
			if (!tools->writeToFile(filePath, "Blockchain Height:" + std::to_string(getDepth() + 1), true))
				return;
			if (sdm)
			{
				filePath = ("KnownDomainsCount.txt");
				tools->writeToFile(filePath, "State-Domains Count: " + std::to_string(sdm->getKnownDomainsCount()), true);
			}
			filePath = ("ForksCount.txt");
			tools->writeToFile(filePath, "Forks: " + std::to_string(getForksCount()), true);

			if (flowTM)
			{
				filePath = ("TProcessed.txt");
				tools->writeToFile(filePath, "Transactions:" + std::to_string(flowTM->getTransactionsCounter()), true);
				filePath = ("VProcessed.txt");
				tools->writeToFile(filePath, "Verifiables:" + std::to_string(flowTM->getVerifiablesCounter()), true);
				filePath = ("FraudsOrdered.txt");
				tools->writeToFile(filePath, "Frauds Requested:" + std::to_string(flowTM->getFraudulantDataBlocksOrdered()), true);
				filePath = ("FraudsProcessed.txt");
				tools->writeToFile(filePath, "Frauds Processed:" + std::to_string(flowTM->getProofsOfFraudProcessed()), true);
				filePath = ("PoFPenatliesTotalValue.txt");
				tools->writeToFile(filePath, "Total Fraud-Penalties Value:" + flowTM->getTotalValueOfFraudPenalties().str(), true);
				filePath = ("PoFRewardsTotalValue.txt");
				tools->writeToFile(filePath, "Total Fraud-Rewards Value:" + flowTM->getTotalValueOfPoFRewards().str(), true);
				filePath = ("newPoFsCount.txt");
				tools->writeToFile(filePath, "New Frauds detected:" + std::to_string(flowTM->getNewFraudsDetected()), true);
				filePath = ("oldPoFsCount.txt");
				tools->writeToFile(filePath, "Old Frauds spotted:" + std::to_string(flowTM->getFraudsDetectedButAlreadyRewarded()), true);
				filePath = ("failedDueToInsifficientAssets.txt");
				tools->writeToFile(filePath, "Transactions with insufficient funds:" + std::to_string(flowTM->getNrOfTimesTransactionsFailedDueToInsufficientFunds()), true);
				filePath = ("failedDueToLockedAssets.txt");
				tools->writeToFile(filePath, "Attempts to spend locked assets:" + std::to_string(flowTM->getNrOfAttemptsToSpendLockedAssets()), true);
				//
				filePath = ("failedDueToOutOfERG.txt");
				tools->writeToFile(filePath, "Transactions out of ERG:" + std::to_string(flowTM->getNrOfTransactionsFailesDueToOutofERG()), true);
				filePath = ("failedDueToNotProcessable.txt");
				tools->writeToFile(filePath, "Non-processable (not included in block):" + std::to_string(flowTM->getNrOfTransactionsFailesDueToNotIncludedInBlock()), true);
				filePath = ("failedDueToInvalidEnvSig.txt");
				tools->writeToFile(filePath, "Invalid Envelope Sig:" + std::to_string(flowTM->getNrOfTransactionsFailesDueToInvalidEnvelopeSig()), true);
				filePath = ("failedDueToUnknownIssuer.txt");
				tools->writeToFile(filePath, "Unknown Issuer:" + std::to_string(flowTM->getNrOfTransactionsFailesDueToUnknownIssuer()), true);
				//
				filePath = ("failedDueToInvalidNonceValues.txt");
				tools->writeToFile(filePath, "Transactions with invalid Nonce:" + std::to_string(flowTM->getNrOfTransactionsWithInvalidNonceValues()), true);
				filePath = ("assetsReleased.txt");
				tools->writeToFile(filePath, "Frozen-assets unlocks:" + std::to_string(flowTM->getNrOfTimesDeferredAssetsReleased()), true);
			}
			filePath = ("encVerifiecChainProofSize.txt");
			tools->writeToFile(filePath, "Encoded VERIFIED ChainProof size:" + std::to_string(getChainProofSizeInBytes(eChainProof::verified) / BYTES_PER_KILOBYTE) + "kB", true);
			filePath = ("encHeaviestChainProofSize.txt");
			tools->writeToFile(filePath, "Encoded HEAVIEST ChainProof size:" + std::to_string(getChainProofSizeInBytes(eChainProof::heaviest) / BYTES_PER_KILOBYTE) + "kB", true);

			if (keyLeader != nullptr)
			{
				effectiveDF = keyLeader->getHeader()->getDifficulty();
				filePath = ("difficulty.txt");
				tools->writeToFile(filePath, "Difficulty:" + std::to_string(effectiveDF), true);
				effectiveKH = keyLeader->getHeader()->getKeyHeight() + 1;
			}
			filePath = ("KeyHeight.txt");
			tools->writeToFile(filePath, "Key-Blocks Count:" + std::to_string(effectiveKH), true);
			filePath = ("avrDInterval.txt");
			tools->writeToFile(filePath, "Avr. Data-Block Interval:" + std::to_string(getAverageSMADataBlockInterval()) + "sec", true);
			filePath = ("avrKInterval.txt");
			tools->writeToFile(filePath, "Avr. Key-Block Interval:" + std::to_string(getAverageSMAKeyBlockInterval()) + "sec", true);
			filePath = ("rejectedKeyBlocks.txt");
			tools->writeToFile(filePath, "Discarded key-blocks:" + std::to_string(getDiscardedKeyBlocksCount()), true);
			filePath = ("rejectedDataBlocks.txt");
			tools->writeToFile(filePath, "Discarded data-blocks:" + std::to_string(getDiscardedDataBlocksCount()), true);
			filePath = ("acceptedDataBlocks.txt");
			tools->writeToFile(filePath, "Data-blocks acc. as leaders:" + std::to_string(getAssumedAsLeaderDataBlocksCount()), true);
			filePath = ("acceptedKeyBlocks.txt");
			tools->writeToFile(filePath, "Key-blocks acc. as leaders:" + std::to_string(getAssumedAsLeaderKeyBlocksCount()), true);
			filePath = ("juttSavedDataBlocks.txt");
			tools->writeToFile(filePath, "just-saved Data-blocks:" + std::to_string(getJustSavedDataBlocksCount()), true);
			filePath = ("justSavedKeyBlocks.txt");
			tools->writeToFile(filePath, "just-saved Key-blocks:" + std::to_string(getJustSavedKeyBlocksCount()), true);

			filePath = ("queueLength.txt");
			uint64_t bql = 0;
			getBlockQueueLength(bql, false);
			tools->writeToFile(filePath, "Queue Length:" + std::to_string(bql), true);


		}
		if (flowTM)
		{
			filePath = ("memPoolUsage.txt");
			tools->writeToFile(filePath, "Mem-Pool usage:" + std::to_string((uint64_t)(((double)flowTM->getMemPoolSize() / (double)CGlobalSecSettings::getMaxMempoolSize()) * 100)) + "%", true);
		}
	}
}

// Block ID -> Block Height Cache - BEGIN
void CBlockchainManager::setIsBlockMetaDataAvailable(bool isIt)
{
	std::unique_lock lock(mSharedGuardian);
	if (mBlockMetaDataAvailable != isIt)
	{
		if (isIt)
		{
			mTools->logEvent("Block Meta Data is now available",
				"Cache",
				eLogEntryCategory::localSystem, 10, eLogEntryType::notification, eColor::lightGreen);
		}
		else
		{
			mTools->logEvent("Block Meta Data is now unavailable",
				"Cache",
				eLogEntryCategory::localSystem, 10, eLogEntryType::notification, eColor::lightPink);
		}
		mBlockMetaDataAvailable = isIt;

	}
}

void CBlockchainManager::setIsTXMetaDataAvailable(bool isIt)
{
	std::unique_lock lock(mSharedGuardian);
	if (mTXMetaDataAvailable != isIt)
	{
		if (isIt)
		{
			mTools->logEvent("Transaction Meta Data is now available",
				"Cache",
				eLogEntryCategory::localSystem, 10, eLogEntryType::notification, eColor::lightGreen);
		}
		else
		{
			mTools->logEvent("Transaction Meta Data is now unavailable",
				"Cache",
				eLogEntryCategory::localSystem, 10, eLogEntryType::notification, eColor::lightPink);
		}
		mTXMetaDataAvailable = isIt;
	}
}


bool CBlockchainManager::getIsBlockMetaDataAvailable()
{
	std::shared_lock lock(mSharedGuardian);

	return mBlockMetaDataAvailable;
}

bool CBlockchainManager::getIsTXMetaDataAvailable()
{
	std::shared_lock lock(mSharedGuardian);

	return mTXMetaDataAvailable;
}

bool CBlockchainManager::addToBlockIDHeightMap(const std::vector<uint8_t>& blockID, uint64_t height) {
	// Local Variables - BEGIN
	bool success = false;
	// Local Variables - END

	// Operational Logic - BEGIN
	if (blockID.size() == VALID_BLOCK_ID_LENGTH) {
		std::unique_lock<std::shared_mutex> lock(mBlockIDMapGuardian);
		mBlockID_BlockHeightMap[blockID] = height;
		success = true;
	}
	// Operational Logic - END

	return success;
}

bool CBlockchainManager::removeFromBlockIDHeightMap(const std::vector<uint8_t>& blockID) {
	// Local Variables - BEGIN
	bool removed = false;
	// Local Variables - END

	// Operational Logic - BEGIN
	if (blockID.size() == VALID_BLOCK_ID_LENGTH) {
		std::unique_lock<std::shared_mutex> lock(mBlockIDMapGuardian);
		removed = mBlockID_BlockHeightMap.erase(blockID) > 0;
	}
	// Operational Logic - END

	return removed;
}

bool CBlockchainManager::getBlockHeightFromBlockIDCache(const std::vector<uint8_t>& blockID, uint64_t& blockHeight) const {
	// Local Variables - BEGIN
	blockHeight = 0;
	// Local Variables - END

	// Operational Logic - BEGIN
	if (blockID.size() == VALID_BLOCK_ID_LENGTH) {
		std::shared_lock<std::shared_mutex> lock(mBlockIDMapGuardian);
		auto it = mBlockID_BlockHeightMap.find(blockID);
		if (it != mBlockID_BlockHeightMap.end()) {
			blockHeight = it->second;
			return true;
		}
	}
	// Operational Logic - END

	return false;
}


void CBlockchainManager::syncBlockIDHeightMap()
{
	// Local Variables - BEGIN
	std::shared_ptr<CTools> tools = getTools();
	std::shared_ptr<CStatusBarHub> barHub = CStatusBarHub::getInstance();
	eBlockchainMode::eBlockchainMode mode = getMode();
	size_t totalBlocks = mBlockCacheFlat.size();
	int progress = 0;
	// Local Variables - END

	// Operational Logic - BEGIN
	tools->logEvent("Starting BlockID to Height map synchronization",
		eLogEntryCategory::localSystem, 1, eLogEntryType::notification);

	sync::SynchronizedLocker lock(mBlockIDMapGuardian, mBlockCacheFlatGuardian);


	mBlockID_BlockHeightMap.clear();
	for (size_t i = 0; i < totalBlocks; ++i)
	{
		if (auto block = mBlockCacheFlat[i].lock())
		{
			mBlockID_BlockHeightMap[block->getID()] = i;
		}

		// Update progress every 5%
		int currentProgress = static_cast<int>((static_cast<double>(i + 1) / totalBlocks) * 100);
		if (currentProgress % 5 == 0 && currentProgress != progress)
		{
			progress = currentProgress;
			tools->logEvent("BlockID map sync progress: " + std::to_string(progress) + "%",
				eLogEntryCategory::localSystem, 1, eLogEntryType::notification);
			barHub->setCustomStatusBarText(mode, getCacheBarID(), std::to_string(progress) + "% completed..");
		}
	}

	tools->logEvent("BlockID to Height map synchronization completed",
		eLogEntryCategory::localSystem, 3, eLogEntryType::notification);
	barHub->setCustomStatusBarText(mode, getCacheBarID(), "100% completed");
	// Operational Logic - END
}

bool CBlockchainManager::updateBlockIDHeightMapOnNewBlock(const std::shared_ptr<CBlock>& block) {
	// Local Variables - BEGIN
	bool success = false;
	// Local Variables - END

	// Operational Logic - BEGIN
	if (block) {
		const auto& blockID = block->getID();
		if (blockID.size() == VALID_BLOCK_ID_LENGTH) {
			success = addToBlockIDHeightMap(blockID, block->getHeader()->getHeight());
		}
	}
	// Operational Logic - END

	return success;
}
void  CBlockchainManager::clearBlockIDHeightMap()
{
	std::unique_lock<std::shared_mutex> mapLock(mBlockIDMapGuardian);
	mBlockID_BlockHeightMap.clear();
}
void CBlockchainManager::updateBlockIDHeightMapOnReorg(const std::shared_ptr<CBlock>& newChainTip)
{
	// Local Variables - BEGIN
	std::shared_ptr<CTools> tools = getTools();
	std::shared_ptr<CStatusBarHub> barHub = CStatusBarHub::getInstance();
	eBlockchainMode::eBlockchainMode mode = getMode();
	int progress = 0;
	size_t processedBlocks = 0;
	size_t estimatedChainLength = 0; // We'll estimate this based on the current tip's height
	// Local Variables - END

	// Operational Logic - BEGIN
	if (!newChainTip)
	{
		tools->logEvent("Invalid new chain tip provided for BlockID map update",
			eLogEntryCategory::localSystem, 10, eLogEntryType::failure);
		return;
	}

	tools->logEvent("Starting BlockID to Height map update on reorganization",
		eLogEntryCategory::localSystem, 1, eLogEntryType::notification);

	sync::SynchronizedLocker lock(mBlockIDMapGuardian, mBlockCacheFlatGuardian);


	mBlockID_BlockHeightMap.clear();
	std::shared_ptr<CBlock> currentBlock = newChainTip;
	estimatedChainLength = currentBlock->getHeader()->getHeight() + 1; // +1 because height is 0-based

	while (currentBlock)
	{
		mBlockID_BlockHeightMap[currentBlock->getID()] = currentBlock->getHeader()->getHeight();

		processedBlocks++;
		// Update progress every 5%
		int currentProgress = static_cast<int>((static_cast<double>(processedBlocks) / estimatedChainLength) * 100);
		if (currentProgress % 5 == 0 && currentProgress != progress)
		{
			progress = currentProgress;
			tools->logEvent("BlockID map update progress: " + std::to_string(progress) + "%",
				eLogEntryCategory::localSystem, 1, eLogEntryType::notification);
			barHub->setCustomStatusBarText(mode, getCacheBarID(), std::to_string(progress) + "% completed..");
		}

		currentBlock = currentBlock->getParentPtr();// do not build-up cache over here, external system is dedicated to that.
	}

	tools->logEvent("BlockID to Height map update on reorganization completed",
		eLogEntryCategory::localSystem, 1, eLogEntryType::notification);
	barHub->setCustomStatusBarText(mode, getCacheBarID(), "100% completed");
	// Operational Logic - END
}

// Block ID -> Block Height Cache - END

// Flat Block Cache - BEGIN

std::shared_ptr<CBlock> CBlockchainManager::getBlockFlatCache(
	size_t index,
	bool isDepth,
	bool isKeyHeight,
	eChainProof::eChainProof chain
) {
	std::lock_guard<std::recursive_mutex> lock(mBlockCacheFlatGuardian);

	const auto& targetCache = isKeyHeight ? mKeyBlockCacheFlat : mBlockCacheFlat;

	if (targetCache.empty()) {
		return nullptr;
	}

	size_t actualIndex = index;

	if (isDepth) {
		uint64_t chainLength = targetCache.size();//getChainProofLength(chain);
		if (index >= chainLength) {
			return nullptr;
		}
		actualIndex = chainLength - 1 - index;
	}

	if (actualIndex >= targetCache.size()) {
		return nullptr;
	}

	return targetCache[actualIndex].lock();
}

std::vector<std::shared_ptr<CBlock>> CBlockchainManager::getBlockRangeFlatCache(
	size_t start,
	size_t end,
	bool isDepth,
	bool isStartKeyHeight,
	bool isEndKeyHeight,
	eChainProof::eChainProof chain
) {
	std::lock_guard<std::recursive_mutex> lock(mBlockCacheFlatGuardian);

	if (mBlockCacheFlat.empty() || start > end) {
		return {};
	}

	// Local Variables - BEGIN
	uint64_t chainLength = getChainProofLength(chain);
	size_t startIndex = isDepth ? (start < chainLength ? chainLength - 1 - start : 0) : start;
	size_t endIndex = isDepth ? (end < chainLength ? chainLength - 1 - end : 0) : end;
	std::vector<std::shared_ptr<CBlock>> result;
	// Local Variables - END

	// Operational Logic - BEGIN
	if (isDepth && startIndex > endIndex) {
		std::swap(startIndex, endIndex);
	}


	// Handle start index
	if (isStartKeyHeight) {
		if (startIndex >= mKeyBlockCacheFlat.size()) {
			return {};
		}
		auto startKeyBlock = mKeyBlockCacheFlat[startIndex].lock();
		if (!startKeyBlock) {
			return {};
		}
		startIndex = startKeyBlock->getHeader()->getHeight();
	}

	// Handle end index
	if (isEndKeyHeight) {
		if (endIndex >= mKeyBlockCacheFlat.size()) {
			endIndex = mBlockCacheFlat.size() - 1;
		}
		else {
			auto endKeyBlock = mKeyBlockCacheFlat[endIndex].lock();
			if (!endKeyBlock) {
				return {};
			}
			endIndex = endKeyBlock->getHeader()->getHeight();
		}
	}

	// Adjust indices if out of range
	startIndex = min(startIndex, mBlockCacheFlat.size() - 1);
	endIndex = min(endIndex, mBlockCacheFlat.size() - 1);

	for (size_t i = startIndex; i <= endIndex; ++i) {
		if (auto block = mBlockCacheFlat[i].lock()) {
			result.push_back(block);
		}
	}
	// Operational Logic - END

	return result;
}


void CBlockchainManager::clearFlatCache(bool releaseMemory) {
	std::lock_guard<std::recursive_mutex> lock(mBlockCacheFlatGuardian);

	// Clear the regular block cache
	mBlockCacheFlat.clear();

	// Clear the key block cache
	mKeyBlockCacheFlat.clear();

	if (releaseMemory)
	{
		mBlockCacheFlat.shrink_to_fit();
		mKeyBlockCacheFlat.shrink_to_fit();
	}

}

eSetBlockCacheResult::eSetBlockCacheResult CBlockchainManager::setBlockFlatCache(std::shared_ptr<CBlock> block) {
	if (!block) {
		return eSetBlockCacheResult::NullBlock;  // Cannot set nullptr block
	}
	std::lock_guard<std::recursive_mutex> lock(mBlockCacheFlatGuardian);

	// Local Variables - BEGIN
	size_t height = block->getHeader()->getHeight();
	bool isKeyBlock = block->getHeader()->isKeyBlock();
	// Local Variables - END

	// Operational Logic - BEGIN
	auto setBlockInCache = [](std::vector<std::weak_ptr<CBlock>>& cache, std::shared_ptr<CBlock> block, bool isKeyBlockCache) -> eSetBlockCacheResult::eSetBlockCacheResult {
		size_t cacheSize = cache.size();
		size_t currRelativeHeight = isKeyBlockCache ? block->getHeader()->getKeyHeight() : block->getHeader()->getHeight();
		uint64_t index = 0;

		// Only key-blocks are allowed in key-index cache.
		if (isKeyBlockCache && !block->getHeader()->isKeyBlock()) {
			return eSetBlockCacheResult::InvalidKeyBlockInKeyCache;
		}

		// Assess Target Index - BEGIN
		// IMPORTANT: This depends on the context of insertion. A key-block would be inserted into both regular and key indexes.
		index = isKeyBlockCache ? block->getHeader()->getKeyHeight() : block->getHeader()->getHeight();
		// Assess Target Index - END

		// Case 1: Empty cache (allowed)
		if (cacheSize == 0) {
			cache.resize(index + 1);  // Ensure all preceding slots are filled up and ready to accommodate additional prior blocks, down to the Genesis Block.
			cache[index] = block;
			return eSetBlockCacheResult::EmptyCacheSuccess;
			// Note: In any further case, an inserted block would need to be an immediate neighbor of an existing block (either an immediate offspring or parent).
		}

		// Case 2: Inserting at the end (at the height of latest block + 1)
		if (index == cacheSize) {
			auto prevBlock = cache[cacheSize - 1].lock(); // Get latest block in cache
			if (!prevBlock) {
				return eSetBlockCacheResult::PreviousBlockExpired; // Previous block is expired, cannot insert
			}
			size_t prevRelativeHeight = isKeyBlockCache ? prevBlock->getHeader()->getKeyHeight() : prevBlock->getHeader()->getHeight();
			// In key-block index, regular block heights would not be contiguous.
			// In block index, all block heights are guaranteed to be contiguous.
			if (prevRelativeHeight != currRelativeHeight - 1) {
				return eSetBlockCacheResult::NonContiguousHeight; // Previous block's height (either key- or regular height) is not currHeight - 1
			}
			cache.push_back(block);
			return eSetBlockCacheResult::Success;
		}

		// Case 3: Inserting in the middle down to and including the Genesis Block (height 0).
		bool hasValidPrev = false;
		bool hasValidNext = false;

		if (index > 0 && index - 1 < cacheSize) {
			auto prevBlock = cache[index - 1].lock();
			if (prevBlock) {
				size_t prevHeight = isKeyBlockCache ? prevBlock->getHeader()->getKeyHeight() : prevBlock->getHeader()->getHeight();
				hasValidPrev = (prevHeight == currRelativeHeight - 1);
			}
		}

		if (index + 1 < cacheSize) {  // This would account for Genesis Block as well.
			auto nextBlock = cache[index + 1].lock();
			if (nextBlock) {
				size_t nextHeight = isKeyBlockCache ? nextBlock->getHeader()->getKeyHeight() : nextBlock->getHeader()->getHeight();
				hasValidNext = (nextHeight == currRelativeHeight + 1);
			}
		}

		if (!hasValidPrev && !hasValidNext) {
			return eSetBlockCacheResult::NoValidAdjacentBlocks; // No valid adjacent blocks
		}

		// Resize cache if necessary
		if (index >= cacheSize) {
			cache.resize(index + 1);
		}

		// Insert the block
		cache[index] = block;
		return eSetBlockCacheResult::Success;
		};

	// Set in mBlockCacheFlat
	eSetBlockCacheResult::eSetBlockCacheResult setInMainCache = setBlockInCache(mBlockCacheFlat, block, false);

	// If it's a key block, also set in mKeyBlockCacheFlat
	if (isKeyBlock) {
		eSetBlockCacheResult::eSetBlockCacheResult setInKeyCache = setBlockInCache(mKeyBlockCacheFlat, block, true);
		// If we couldn't set in key cache but set in main cache, revert main cache
		if (setInKeyCache != eSetBlockCacheResult::Success && setInKeyCache != eSetBlockCacheResult::EmptyCacheSuccess) {
			if (setInMainCache == eSetBlockCacheResult::Success || setInMainCache == eSetBlockCacheResult::EmptyCacheSuccess) {
				if (height < mBlockCacheFlat.size()) {
					mBlockCacheFlat[height] = std::weak_ptr<CBlock>(); // Reset the block
				}
			}
			return eSetBlockCacheResult::KeyCacheInsertionFailed;
		}
		return (setInKeyCache == eSetBlockCacheResult::Success || setInKeyCache == eSetBlockCacheResult::EmptyCacheSuccess) ?
			eSetBlockCacheResult::Success : setInKeyCache;
	}
	// Operational Logic - END

	return setInMainCache;
}
void CBlockchainManager::clearEntryFlatCache(
	size_t index,
	bool isDepth,
	bool isKeyHeight,
	eChainProof::eChainProof chain
) {
	std::lock_guard<std::recursive_mutex> lock(mBlockCacheFlatGuardian);

	auto& targetCache = isKeyHeight ? mKeyBlockCacheFlat : mBlockCacheFlat;

	if (targetCache.empty()) {
		return;
	}

	size_t actualIndex = index;
	if (isDepth) {
		uint64_t chainLength = getChainProofLength(chain);
		actualIndex = index < chainLength ? chainLength - 1 - index : 0;
	}

	if (actualIndex < targetCache.size()) {
		targetCache[actualIndex].reset();
	}
}

bool CBlockchainManager::validateFlatCache() const {
	std::lock_guard<std::recursive_mutex> lock(mBlockCacheFlatGuardian);

	// Lambda Helper - BEGIN
	auto validateSingleCache = [](const std::vector<std::weak_ptr<CBlock>>& cache) -> bool {
		if (cache.empty()) {
			return true;  // Empty cache is valid
		}

		// Check if first entry is invalid
		if (cache[0].expired()) {
			return false;  // First entry must be valid
		}

		// Find first valid block to start gap detection
		bool foundValidBlock = false;
		bool inGap = false;

		for (size_t i = 0; i < cache.size(); ++i) {
			if (!cache[i].expired()) {
				if (inGap) {
					// Found a valid block after a gap
					return false;
				}
				foundValidBlock = true;
			}
			else {
				// Current position is null/expired
				if (foundValidBlock) {
					// We've found a null after a valid block
					inGap = true;
				}
			}
		}

		return true;  // No gaps found
		};
	// Lambda Helper - END

	// Validate both regular and key block caches
	bool regularCacheValid = validateSingleCache(mBlockCacheFlat);
	bool keyCacheValid = validateSingleCache(mKeyBlockCacheFlat);
	bool lastBlockCachedCoherent = false;

	// Additional check: Ensure key blocks in mKeyBlockCacheFlat correspond to key blocks in mBlockCacheFlat
	if (regularCacheValid && keyCacheValid) {
		for (size_t i = 0; i < mKeyBlockCacheFlat.size(); ++i) {
			auto keyBlock = mKeyBlockCacheFlat[i].lock();
			if (keyBlock) {
				size_t blockHeight = keyBlock->getHeader()->getHeight(); // Retrieve regular height from key-block
				if (blockHeight >= mBlockCacheFlat.size() ||
					mBlockCacheFlat[blockHeight].expired() ||
					mBlockCacheFlat[blockHeight].lock() != keyBlock) {
					return false;  // Mismatch between key cache and regular cache
				}
			}
		}

		// Cache Cross-Validation Check - BEGIN
		// Get the deepest block from getDeepestBlockInCache()
		std::shared_ptr<CBlock> deepestBlock = getDeepestBlockInCache();

		// Get the deepest block in mBlockCacheFlat
		std::shared_ptr<CBlock> deepestBlockInCache;
		for (auto it = mBlockCacheFlat.begin(); it != mBlockCacheFlat.end(); ++it) {
			if (!it->expired()) {
				deepestBlockInCache = it->lock();
				break;
			}
		}

		// Compare the deepest blocks
		if (deepestBlock && deepestBlockInCache) {
			// Compare heights and hashes
			if (deepestBlock->getHeader()->getHeight() == deepestBlockInCache->getHeader()->getHeight() &&
				deepestBlock->getHeader()->getHash() == deepestBlockInCache->getHeader()->getHash()) {
				lastBlockCachedCoherent = true;
			}
		}
		else if (!deepestBlock && !deepestBlockInCache) {
			// Both are null; consider cache coherent
			lastBlockCachedCoherent = true;
		}
		else {
			// One is null and the other is not; cache is not coherent
			lastBlockCachedCoherent = false;
		}
		// Cache Cross-Validation Check - END
	}

	return regularCacheValid && keyCacheValid && lastBlockCachedCoherent;
}

/**
 * @brief Truncates both the main block cache and, optionally, the key-block cache.
 *
 * This method reduces the size of the flat caches (mBlockCacheFlat and optionally mKeyBlockCacheFlat)
 * to align with a new blockchain height limit. Specifically:
 * 1) Resizes mBlockCacheFlat to newSize (if newSize < current size).
 * 2) If truncateKeyCache is true, determines the key height of the last retained non-expired block
 *    in mBlockCacheFlat, and resizes mKeyBlockCacheFlat accordingly to remove any key blocks whose
 *    regular height is no longer valid.
 *
 * Edge cases:
 * - If newSize == 0, clears both caches outright.
 * - If no valid (non-expired) block is found in the truncated main cache, clears both caches.
 * - Otherwise, resizes mKeyBlockCacheFlat to lastRetainedKeyHeight + 1.
 *
 * @param newSize The new size (height limit) for mBlockCacheFlat.
 * @param truncateKeyCache Whether to also truncate mKeyBlockCacheFlat to match the truncated main cache.
 */
void CBlockchainManager::truncateFlatCache(size_t newSize, bool truncateKeyCache) {
	std::lock_guard<std::recursive_mutex> lock(mBlockCacheFlatGuardian);

	// Local Variables - BEGIN
	size_t oldMainCacheSize = mBlockCacheFlat.size();
	// Local Variables - END

	// Operational Logic - BEGIN

	// 1. If the requested size is 0, clear everything and return immediately.
	if (newSize == 0) {
		mBlockCacheFlat.clear();
		mKeyBlockCacheFlat.clear();
		return;
	}

	// 2. Truncate mBlockCacheFlat if necessary.
	if (newSize < oldMainCacheSize) {
		mBlockCacheFlat.resize(newSize);
	}

	// 3. If we are not truncating the key cache, we are done.
	if (!truncateKeyCache) {
		return;
	}

	// 4. Find the last retained (non-expired) block in the truncated main cache.
	std::shared_ptr<CBlock> lastRetainedBlock;
	{
		// Start from the highest index and move downward until we find a valid block or reach 0.
		size_t truncatedSize = mBlockCacheFlat.size();
		for (size_t i = truncatedSize; i > 0; /* decrement inside loop */) {
			--i; // Decrement first to avoid underflow issues with size_t
			auto blockPtr = mBlockCacheFlat[i].lock();
			if (blockPtr) {
				lastRetainedBlock = blockPtr;
				break;
			}
		}
	}

	// 5. If no valid block remains, clear both caches.
	if (!lastRetainedBlock) {
		mBlockCacheFlat.clear();
		mKeyBlockCacheFlat.clear();
		return;
	}

	// 6. Retrieve the key height of the last retained block (even data blocks have a valid key height).
	size_t lastRetainedKeyHeight = lastRetainedBlock->getHeader()->getKeyHeight();

	// 7. Truncate the key-block cache if necessary.
	if (lastRetainedKeyHeight < mKeyBlockCacheFlat.size()) {
		mKeyBlockCacheFlat.resize(lastRetainedKeyHeight + 1);
	}

	// Operational Logic - END
}


size_t CBlockchainManager::getFlatCacheSize(bool getKeyCache) const {
	std::lock_guard<std::recursive_mutex> lock(mBlockCacheFlatGuardian);
	return getKeyCache ? mKeyBlockCacheFlat.size() : mBlockCacheFlat.size();
}
// Flat Block Cache - END

/// <summary>
/// Gets length of a Chain-Proof.
/// </summary>
/// <param name="height"></param>
/// <param name="ommitOrphanedBlocks"></param>
/// <returns></returns>
uint64_t CBlockchainManager::getChainProofLength(eChainProof::eChainProof chain)

{	//Local Variables - BEGIN
	uint64_t toRet = 0;
	//Local Variables - END

	//Operational Logic - BEGIN
	switch (chain)
	{
	case eChainProof::verified:

		mVerifiedPathGuardian.lock();
		if (mVerifiedPath.size())
		{
			toRet = mVerifiedPath.size();

		}
		mVerifiedPathGuardian.unlock();

		break;
	case eChainProof::heaviest:
		mHeaviestPathGuardian.lock();
		if (mHeaviestPath.size())
		{
			toRet = mHeaviestPath.size();
		}
		mHeaviestPathGuardian.unlock();
		break;

	case eChainProof::verifiedCached:

		mVerifiedPathDoubleGuardian.lock();
		if (mVerifiedPathDouble.size())
		{
			toRet = mVerifiedPathDouble.size();

		}
		mVerifiedPathDoubleGuardian.unlock();

		break;


	case eChainProof::heaviestCached:

		mHeaviestPathDoubleGuardian.lock();
		if (mHeaviestPathDouble.size())
		{
			toRet = mHeaviestPathDouble.size();

		}
		mHeaviestPathDoubleGuardian.unlock();

		break;
	default:
		break;
	}
	//Operational Logic - END
	return toRet;
}

/// <summary>
/// Gets block at a given depth from the top of the chain.
/// </summary>
/// <param name="depth">The depth of the block to retrieve (0 is the top block).</param>
/// <param name="chain">The chain to query (verified, heaviest, etc.).</param>
/// <returns>Shared pointer to the CBlock at the specified depth, or nullptr if not found.</returns>
/// <remarks>
/// This method is the reverse of getBlockAtHeight. The lowest depth (0) corresponds
/// to the latest block, and increasing depths move towards the genesis block.
/// </remarks>
std::shared_ptr<CBlock> CBlockchainManager::getBlockAtDepthSSDirect(size_t depth, eChainProof::eChainProof chain, const bool& instantiateTrees, const uint64_t& bytesCount)
{
	// Local Variables - BEGIN
	std::shared_ptr<CBlock> block = nullptr;
	eBlockInstantiationResult::eBlockInstantiationResult iRes = eBlockInstantiationResult::blockDataUnavailableInCS;
	size_t chainSize = 0;
	std::vector<std::vector<uint8_t>>* targetPath = nullptr;
	ExclusiveWorkerMutex* targetMutex = nullptr;

	std::vector<uint8_t> blockHash;
	size_t height = 0;
	// Local Variables - END

	// Operational Logic - BEGIN
	switch (chain)
	{
	case eChainProof::verifiedCached:
		targetPath = &mVerifiedPathDouble;
		targetMutex = &mVerifiedPathDoubleGuardian;
		break;
	case eChainProof::heaviestCached:
		targetPath = &mHeaviestPathDouble;
		targetMutex = &mHeaviestPathDoubleGuardian;
		break;
	case eChainProof::verified:
		targetPath = &mVerifiedPath;
		targetMutex = &mVerifiedPathGuardian;
		break;
	case eChainProof::heaviest:
		targetPath = &mHeaviestPath;
		targetMutex = &mHeaviestPathGuardian;
		break;
	default:
		// Invalid chain type, return nullptr
		return nullptr;
	}

	{ // Critical Section - BEGIN
		// Lock the appropriate mutex
		std::lock_guard<ExclusiveWorkerMutex> lock(*targetMutex);

		chainSize = targetPath->size();

		// Check if the chain is empty or if the depth is out of bounds
		if (chainSize == 0 || depth >= chainSize)
		{
			// Either the chain is empty or the requested depth is beyond the chain length
			return nullptr;
		}

		// Calculate the corresponding height from depth
		height = chainSize - 1 - depth;

		// Retrieve the block hash at the calculated height
		blockHash = (*targetPath)[height];
	} // Critical Section - END

	// Get the block by its hash
	block = mSolidStorage->getBlockByHash(blockHash, iRes, instantiateTrees, bytesCount);

	// Operational Logic - END

	return block;
}

/// <summary>
/// Gets block at a given height from the bottom of the chain, directly from Cold Storage,
/// </summary>
/// <param name="height">The height of the block to retrieve (0 is the genesis block).</param>
/// <param name="chain">The chain to query (verified, heaviest, etc.).</param>
/// <param name="instantiateTrees">Whether to instantiate trees for the block.</param>
/// <param name="bytesCount">The number of bytes to read for the block.</param>
/// <returns>Shared pointer to the CBlock at the specified height, or nullptr if not found.</returns>
/// <remarks>
/// This method is the inverse of getBlockAtDepth. The lowest height (0) corresponds
/// to the genesis block, and increasing heights move towards the latest block.
/// </remarks>
std::shared_ptr<CBlock> CBlockchainManager::getBlockAtHeightSSDirect(size_t height, eChainProof::eChainProof chain, const bool& instantiateTrees, const uint64_t& bytesCount)
{
	// Local Variables - BEGIN
	std::shared_ptr<CBlock> block = nullptr;
	eBlockInstantiationResult::eBlockInstantiationResult iRes = eBlockInstantiationResult::blockDataUnavailableInCS;
	size_t chainSize = 0;
	std::vector<std::vector<uint8_t>>* targetPath = nullptr;
	ExclusiveWorkerMutex* targetMutex = nullptr;
	std::vector<uint8_t> blockHash;
	// Local Variables - END

	// Operational Logic - BEGIN
	switch (chain)
	{
	case eChainProof::verifiedCached:
		targetPath = &mVerifiedPathDouble;
		targetMutex = &mVerifiedPathDoubleGuardian;
		break;
	case eChainProof::heaviestCached:
		targetPath = &mHeaviestPathDouble;
		targetMutex = &mHeaviestPathDoubleGuardian;
		break;
	case eChainProof::verified:
		targetPath = &mVerifiedPath;
		targetMutex = &mVerifiedPathGuardian;
		break;
	case eChainProof::heaviest:
		targetPath = &mHeaviestPath;
		targetMutex = &mHeaviestPathGuardian;
		break;
	default:
		// Invalid chain type, return nullptr
		return nullptr;
	}

	{ // Critical Section - BEGIN
		// Lock the appropriate mutex
		std::lock_guard<ExclusiveWorkerMutex> lock(*targetMutex);
		chainSize = targetPath->size();
		// Check if the chain is empty or if the height is out of bounds
		if (chainSize == 0 || height >= chainSize)
		{
			// Either the chain is empty or the requested height is beyond the chain length
			return nullptr;
		}
		// Retrieve the block hash at the given height
		blockHash = (*targetPath)[height];
	} // Critical Section - END

	// Get the block by its hash
	block = mSolidStorage->getBlockByHash(blockHash, iRes, instantiateTrees, bytesCount);
	// Operational Logic - END

	return block;
}

/// <summary>
/// Gets Block-Header at a given height.
/// </summary>
/// <param name="height"></param>
/// <param name="ommitOrphanedBlocks"></param>
/// <returns></returns>
std::shared_ptr<CBlockHeader> CBlockchainManager::getHeaderAtHeight(size_t height, eChainProof::eChainProof chain)

{
	//Local Variables - BEGIN
	std::shared_ptr<CBlockHeader> header;
	CBlockHeader::eBlockHeaderInstantiationResult iRes = CBlockHeader::eBlockHeaderInstantiationResult::failure;
	std::string errorInfo;
	eBlockchainMode::eBlockchainMode mode = getMode();
	//Local Variables - END

	//Operational Logic - BEGIN
	switch (chain)
	{
	case eChainProof::verified:

		mVerifiedPathGuardian.lock();
		if (mVerifiedChainProof.size() && (height <= mVerifiedChainProof.size() - 1))
		{
			header = CBlockHeader::instantiate(mVerifiedChainProof[height], iRes, errorInfo, mode);
		}
		mVerifiedPathGuardian.unlock();

		break;
	case eChainProof::heaviest:
		mHeaviestPathGuardian.lock();
		if (mHeaviestChainProof.size() && (height <= mHeaviestChainProof.size() - 1))
		{
			header = CBlockHeader::instantiate(mHeaviestChainProof[height], iRes, errorInfo, mode);
		}
		mHeaviestPathGuardian.unlock();
		break;

	case eChainProof::verifiedCached:
		//Notice: CANNOT be used during a Flow. For informative purposes only.
		mVerifiedPathDoubleGuardian.lock();
		if (mVerifiedChainProofDouble.size() && (height <= mVerifiedChainProofDouble.size() - 1))
		{
			header = CBlockHeader::instantiate(mVerifiedChainProofDouble[height], iRes, errorInfo, mode);
		}
		mVerifiedPathDoubleGuardian.unlock();
		break;

	case eChainProof::heaviestCached:
		//Notice: CANNOT be used during a Flow. For informative purposes only.
		mHeaviestPathDoubleGuardian.lock();// todo: introduce double buffering of heaviest chain proof?
		if (mHeaviestChainProof.size() && (height <= mHeaviestChainProof.size() - 1))
		{
			header = CBlockHeader::instantiate(mHeaviestChainProof[height], iRes, errorInfo, mode);
		}
		mHeaviestPathDoubleGuardian.unlock();
		break;

	default:
		break;
	}

	//Operational Logic - END
	return header;
}

/// <summary>
/// Retrieved Block by a provided ID.
/// The function verifies integrity of the retrieved data.
/// </summary>
/// <param name="hash"></param>
/// <param name="result"></param>
/// <param name="instantiateTries"></param>
/// <returns></returns>
std::shared_ptr<CBlock> CBlockchainManager::getBlockByHash(std::vector<uint8_t> hash, eBlockInstantiationResult::eBlockInstantiationResult& result, bool instantiateTries,
	const uint64_t& bytesCount, bool enableFastCache)
{
	if (hash.size() != 32)
		return nullptr;

	std::shared_ptr<CBlock> toBeReturned;

	// Fast Cache Support - BEGIN
	if (enableFastCache)
	{
		/**
		 * Fast Cache Mechanism Explanation:
		 *
		 * 1. Purpose:
		 *    The Fast Cache is an in-memory lookup system designed to significantly speed up
		 *    block retrieval based on block hashes. It uses two main components:
		 *    a) A BlockID to Height map (mBlockID_BlockHeightMap)
		 *    b) A flat cache of blocks (mBlockCacheFlat)
		 *
		 * 2. Process Flow:
		 *    a) First, we attempt to find the block's height using its hash (BlockID) in the
		 *       BlockID to Height map. This map provides O(1) lookup time.
		 *    b) If the height is found, we then use this height to directly access the block
		 *       in the flat cache (mBlockCacheFlat), which is also an O(1) operation.
		 *
		 * 3. Advantages:
		 *    - Avoids traversing the blockchain or searching through a database.
		 *    - Provides near-instant access to blocks if they are in the cache.
		 *    - Significantly reduces load times for frequently accessed blocks.
		 *
		 * 4. Fallback:
		 *    If the block is not found in the Fast Cache (either its height isn't in the map
		 *    or the block isn't in the flat cache), the method will continue to the slower,
		 *    traditional block retrieval methods.
		 */

		uint64_t blockHeight = 0;

		if (getBlockHeightFromBlockIDCache(hash, blockHeight))
		{
			// Block height found in the BlockID to Height map
			// Now attempt to retrieve the block from the flat cache
			toBeReturned = getBlockAtHeight(blockHeight, false, eChainProof::verifiedCached);
		}

		if (toBeReturned)
		{
			// Block successfully retrieved from the Fast Cache
			// Return it immediately, bypassing slower retrieval methods
			return toBeReturned;
		}

		// If we reach here, it means:
		// 1. The block's height wasn't in the BlockID to Height map, or
		// 2. The block wasn't in the flat cache (possibly due to cache eviction)
		// In either case, we'll fall through to slower retrieval methods
	}
	// Fast Cache Support - END

	std::string error;
	toBeReturned = mSolidStorage->getBlockByHash(hash, result, instantiateTries, bytesCount);

	//check data integrity - BEGIN
	if (toBeReturned)
	{
		std::vector<uint8_t> verifiedID = toBeReturned->getID();

		if (verifiedID.size() != 32)
		{
			return nullptr;
		}

		if (!getTools()->compareByteVectors(verifiedID, hash))
		{
			return nullptr;
		}


	}
	//check data integrity - END
	return  toBeReturned;
}


bool CBlockchainManager::isBlockAvailableLocally(std::vector<uint8_t>& blockID, bool useCacheOnly, const bool& basedOnCache)
{
	//By default 'useCacheOnly' is set to FALSE, since cache does not prevail through software restarts.
	bool toRet = false;

	if (blockID.size() != 32)
		return toRet;
	std::lock_guard<std::recursive_mutex> lock(mLocalBlockAvailabilityGuardian);
	robin_hood::unordered_map<std::vector<uint8_t>, bool >::const_iterator got = mLocalBlockAvailability.find(blockID);
	if (got == mLocalBlockAvailability.end())
		toRet = false;
	else if (got->second == false)
		toRet = false;
	else toRet = true;

	if (toRet)
	{
		const_cast<bool&> (basedOnCache) = true;
		return true;
	}

	if (useCacheOnly)
	{
		const_cast<bool&> (basedOnCache) = true;
		return toRet;
	}

	if (mSolidStorage->getBlockDataByHash(blockID).size() > 0)
	{
		const_cast<bool&> (basedOnCache) = false;
		return true;
	}
	const_cast<bool&> (basedOnCache) = false;
	return false;
}

void CBlockchainManager::markBlockLocalAvailability(std::vector<uint8_t> blockID, bool available, bool report)
{
	if (blockID.size() != 32)
		return;
	if (report)
		getTools()->writeLine("Marking block " + getTools()->base58CheckEncode(blockID) + " as available");
	std::lock_guard<std::recursive_mutex> lock(mLocalBlockAvailabilityGuardian);
	mLocalBlockAvailability[blockID] = available;

	return;
}

/// <summary>
/// Retrieves a sequence representing the latest path with largest accumulated total difficulty.
/// Used by networked block synchronization mechanism.
/// </summary>
/// <returns></returns>
std::vector<std::vector<uint8_t>> CBlockchainManager::getPath(eChainProof::eChainProof whichOne, bool recalculate, bool muteConsole, bool forceReload)
{// the path can be recalculated based on available chainproof (not the other way around)

	std::shared_ptr<CTools> tools = getTools();

	if (whichOne == eChainProof::heaviest)
	{
		std::lock_guard<ExclusiveWorkerMutex> lock(mHeaviestPathGuardian);


		if (!recalculate)
		{
			if (mVerifiedPath.size() == 0 || forceReload)
			{
				mHeaviestPath = mSolidStorage->loadByteVectors("heaviestPath");
			}

		}
		else if (mHeaviestChainProof.size())
		{
			if (!muteConsole)
			{
				tools->logEvent("Recalculating Heaviest Path based on the Heaviest Chain Proof.", eLogEntryCategory::localSystem, 100, eLogEntryType::notification);
			}

			mHeaviestPath.clear();
			for (uint64_t i = 0; i < mHeaviestChainProof.size(); i++)
			{
				mHeaviestPath.push_back(mCryptoFactory->getSHA2_256Vec(mHeaviestChainProof[i]));
			}
		}
		else
		{
			if (!muteConsole)
			{
				tools->logEvent("Unable to recalculate the Heaviest Path since the Heaviest Chain Proof is not available.", eLogEntryCategory::localSystem, 100, eLogEntryType::warning);
			}

		}
		mHeaviestPathDoubleGuardian.lock();
		mHeaviestPathDouble = mHeaviestPath;
		mHeaviestPathDoubleGuardian.unlock();
		return mHeaviestPath;

	}
	else
	{
		// Use MemoryOrdered policy to prevent deadlocks - ensures all threads
		// acquire these locks in the same order (by memory address)
		sync::SynchronizedLocker lock(sync::LockingPolicy::MemoryOrdered, mChainGuardian, mVerifiedPathGuardian, mLeaderGuardian);

		size_t alreadyTraversed = 0;
		bool cut = false;

		if (!recalculate)
		{
			if (mVerifiedPath.size() == 0 || forceReload)
				mVerifiedPath = mSolidStorage->loadByteVectors("verifiedPath");
		}
		else if (mVerifiedChainProof.size())
		{
			if (!muteConsole)
			{
				tools->logEvent("Recalculating Verified Path based on the Verified Chain Proof.", eLogEntryCategory::localSystem, 100, eLogEntryType::notification);
			}
			mVerifiedPath.clear();
			for (uint64_t i = 0; i < mVerifiedChainProof.size(); i++)
			{
				mVerifiedPath.push_back(mCryptoFactory->getSHA2_256Vec(mVerifiedChainProof[i]));
			}
		}
		else
		{
			if (!muteConsole)
			{
				tools->logEvent("Unable to recalculate the Verified Path since the Verified Chain Proof is not available.", eLogEntryCategory::localSystem, 100, eLogEntryType::warning);
			}
		}
		return mVerifiedPath;
	}
	return std::vector<std::vector<uint8_t>>();
}



std::vector<std::vector<uint8_t>> CBlockchainManager::getChainProof(eChainProof::eChainProof whichOne, bool recalculate, bool forceReload)
{
	//for now, recalculation possibility is neglected
	//todo:consider adding the possibility of repairing the VERIFIED chain-proof based on the leader AND blocks available locally.
	if (whichOne == eChainProof::heaviest)
	{
		std::lock_guard<ExclusiveWorkerMutex> lock(mHeaviestPathGuardian);

		if (mHeaviestChainProof.size() == 0 || forceReload)
			mHeaviestChainProof = mSolidStorage->loadByteVectors("heaviestChainProof");

		return mHeaviestChainProof;
	}
	else
	{
		std::lock_guard<ExclusiveWorkerMutex> lock(mVerifiedPathGuardian);

		if (mVerifiedChainProof.size() == 0 || forceReload)
			mVerifiedChainProof = mSolidStorage->loadByteVectors("verifiedChainProof");

		if (mVerifiedChainProof.size() > 10000000)
		{
			throw "RocksDB main database is corrupted";
		}

		return mVerifiedChainProof;
	}
	return std::vector<std::vector<uint8_t>>();
}

/// <summary>
/// Retrieves RAW packed chain-proof as seen in Cold Storage. 
/// Does NOT perform any validations. Returns AS IS.
/// </summary>
/// <param name="whichOne"></param>
/// <returns></returns>
std::vector<uint8_t> CBlockchainManager::getChainProofPacked(eChainProof::eChainProof whichOne)
{
	//for now, recalculation possibility is neglected
	//todo:consider adding the possibility of repairing the VERIFIED chain-proof based on the leader AND blocks available locally.
	if (whichOne == eChainProof::heaviest)
	{

		return mSolidStorage->getValue("heaviestChainProof");

	}
	else
	{

		return mSolidStorage->getValue("verifiedChainProof");

	}
	return std::vector<uint8_t>();
}

/// <summary>
/// The function attempts to find a block by a given id within the selected chain-proof.
/// The function can also check if the block is proceeded by another block if the reverse traversal order selected (default).
/// 
/// If the proceeding block search is enabled (id provided), the function returns true only if both conditions hold true (block A and proceeding block B are found).
/// Otherwise, the function returns false.
/// 
/// When traverseFromEnd is true, it traverses the chain from end to start, looking for the given block ID. Once it finds the block, if proceededByBlock.size() is not 0, it then continues to search for a block with the proceededByBlock ID.
//When traverseFromEnd is false, it traverses the chain from start to end, looking for the block with the given ID, and it stops once it finds the block.
//Finally, it releases the lock on the path and returns whether or not the block was found(and if proceededByBlock was provided, whether the block proceeded by the given block was also found).
/// </summary>
/// <param name="blockID"></param>
/// <param name="chain"></param>
/// <param name="proceededByBlock"></param>
/// <param name="traverseFromEnd"></param>
/// <returns></returns>
bool CBlockchainManager::isBlockInChainProof(const std::vector<uint8_t>& blockID, eChainProof::eChainProof chain,
	const std::vector<uint8_t>& proceededByBlock, bool traverseFromEnd, bool allowForCache, const std::vector<std::vector<uint8_t>>& externalChainProof)
{

	if (blockID.size() != 32) return false;

	// Local Variables - BEGIN
	std::shared_ptr<CTools> tools = getTools();
	std::vector<std::vector<uint8_t>>* chainProof = nullptr; //sequence of serialized blocks
	std::vector<std::vector<uint8_t>>* path = nullptr; //sequence of images of serialized block (available only for Heaviest and Verified Local Chain proofs)
	std::unique_lock<ExclusiveWorkerMutex> lock; // RAII-based locking
	std::shared_ptr<CCryptoFactory> cf = CCryptoFactory::getInstance();
	// Local Variables - END

	// Preliminaries - BEGIN

	if (chain == eChainProof::heaviestCached)
	{
		chain = eChainProof::heaviest;
		allowForCache = true;
	}

	if (chain == eChainProof::heaviest)
	{
		if (!allowForCache)
		{
			lock = std::unique_lock<ExclusiveWorkerMutex>(mHeaviestPathGuardian);
			path = &mHeaviestPath;
		}
		else
		{
			lock = std::unique_lock<ExclusiveWorkerMutex>(mHeaviestPathDoubleGuardian);
			path = &mHeaviestPathDouble;

		}
	}
	else if (chain == eChainProof::verified)
	{
		lock = std::unique_lock<ExclusiveWorkerMutex>(mVerifiedPathGuardian);
		path = &mVerifiedPath;
		chainProof = &mVerifiedChainProof;
	}
	else if (chain == eChainProof::fullTemporary)
	{
		chainProof = &const_cast<std::vector<std::vector<uint8_t>>&>(externalChainProof);
		path = nullptr;
	}
	// Preliminaries - END


	//Pre-Flight - BEGIN

	if ((!path || path->empty()) &&
		(!chainProof || chainProof->empty())) return false;


	//Pre-Flight - END

	// Operational Logic - BEGIN
	if (traverseFromEnd)
	{
		if (proceededByBlock.empty())
		{
			for (auto i = (path ? path->rbegin() : chainProof->rbegin()); i != (path ? path->rend() : chainProof->rend()); ++i)
			{
				std::vector<uint8_t> compareAgainst = path ? *i : cf->getSHA2_256Vec(*i);
				if (tools->compareByteVectors(compareAgainst, blockID))
				{
					return true;
				}
			}
		}
		else
		{
			bool foundBlockID = false;
			for (auto i = (path ? path->rbegin() : chainProof->rbegin()); i != (path ? path->rend() : chainProof->rend()); ++i)
			{
				std::vector<uint8_t> compareAgainst = path ? *i : cf->getSHA2_256Vec(*i);
				if (!foundBlockID)
				{
					if (tools->compareByteVectors(compareAgainst, blockID))
						foundBlockID = true;
				}
				else
				{
					if (tools->compareByteVectors(compareAgainst, proceededByBlock))
						return true;
				}
			}
		}
	}
	else
	{
		if (proceededByBlock.empty())
		{
			for (auto& block : (path ? *path : *chainProof))
			{
				std::vector<uint8_t> compareAgainst = path ? block : cf->getSHA2_256Vec(block);
				if (tools->compareByteVectors(compareAgainst, blockID))
					return true;
			}
		}
		else
		{
			bool foundProceededByBlock = false;
			for (auto& block : (path ? *path : *chainProof))
			{
				std::vector<uint8_t> compareAgainst = path ? block : cf->getSHA2_256Vec(block);
				if (!foundProceededByBlock)
				{
					if (tools->compareByteVectors(compareAgainst, proceededByBlock))
						foundProceededByBlock = true;
				}
				else
				{
					if (tools->compareByteVectors(compareAgainst, blockID))
						return true;
				}
			}
		}
	}

	return false;
	// Operational Logic - END
}



/// <summary>
/// The function decided whether to dig on the current leader, or whether to wait for the node to synchronize
/// better with the external network.
/// </summary>
/// <returns></returns>
bool CBlockchainManager::shouldIDig()
{
	//We won't be deciding for users whether to mine on the current chain based on the available computation power.
	//Some users might accept low probability of winning.
	//Thus we'll be making a mining decision solely based on the state of synchronization of the node with the rest of the network.
	//If the synchronization drops below 90%, the node would prefere to download and validate blocks instead of digging.
	//double averageMhps = mWorkManager->getAverageMhps(); - we could access the computation power availabel locally easily though.
	bool decision = true;

	uint64_t totadlDiffInVerfiedPath = getVerifiedChainProofTotalDifficulty();
	uint64_t totalDiffInHeaviestPath = getHeaviestChainProofTotalDifficulty();

	if (totadlDiffInVerfiedPath >= totalDiffInHeaviestPath)
		return true;//that's obvious. we're at the very top of the history of events backed by total cumulative poW
	//actually this should almost never happen and positive value would be at least strange.

	//now we need to assess the difference (which is much more realistic)

	double percPoWCoverage = ((double)totadlDiffInVerfiedPath / (double)totalDiffInHeaviestPath) * 100;
	if (percPoWCoverage >= mSettings->getMinSynchronizationPerc())
		decision = true;
	else
		decision = false;

	return decision;
}


/// <summary>
/// Returns a chainProof for a given block.
/// This allows to prove validity of a certain PoW-sub-chain.
/// if no blockIDA is provided; the proof return all the blocks up to the Genesis block.
/// if no blockIDB is provided the Loader block is assumed.
/// NOTE: the function can provide chainproofs only for blocks that were fully verified.
/// 
/// If no blockIDs are provided, entire Global ChainProof is fetched.
/// If no starting block is provided, leader block is assumed.
/// By default it is assumed that a chain-proof MUST begin with at least a singel valid key-block
/// so that consecutive data-blocks could be verified.
/// </summary>
/// <param name="blockID"></param>
/// <param name="proof"></param>
/// <param name="upTo"></param>
/// <returns></returns>
bool CBlockchainManager::getChainProofForBlock(eChainProof::eChainProof whichChainProof, std::vector <std::vector<uint8_t>>& proof, std::vector<uint8_t> blockIDA, std::vector<uint8_t> blockIDB)
{
	//BlockIDA -> closer to Genesis 
	//BlockIDB -> closer to Leader 






	std::vector<std::vector<uint8_t>>* chosenPath;
	std::vector<std::vector<uint8_t>>* chosenChainProof;
	switch (whichChainProof)
	{
	case eChainProof::verified:
		mVerifiedPathGuardian.lock();
		chosenPath = &mVerifiedPath;
		chosenChainProof = &mVerifiedChainProof;
		break;
	case eChainProof::verifiedCached:
		mVerifiedPathDoubleGuardian.lock();
		chosenPath = &mVerifiedPathDouble;
		chosenChainProof = &mVerifiedChainProofDouble;
		break;
	case eChainProof::heaviest:
		mHeaviestPathGuardian.lock();
		chosenPath = &mHeaviestPath;
		chosenChainProof = &mHeaviestChainProof;
		break;
	default:
		break;
	}



	std::shared_ptr<CTools> tools = getTools();
	uint64_t blockAPosition = 0;
	uint64_t blockBPosition = 0;

	bool blockAFound = false;
	bool blockBFound = false;

	if (blockIDA.size() != 32)
	{
		blockAFound = true;
		blockAPosition = 0;//assume Genesis
	}
	if (blockIDB.size() != 32)
	{
		if (!(*chosenPath).empty())
		{
			blockBFound = true;
			blockBPosition = (*chosenPath).size() - 1;//assume current Leader
		}

	}


	if (blockAPosition == 0 && blockBPosition == 0)
	{
		proof = (*chosenChainProof);
		switch (whichChainProof)
		{
		case eChainProof::verified:
			mVerifiedPathGuardian.unlock();

			break;
		case eChainProof::verifiedCached:
			mVerifiedPathDoubleGuardian.unlock();

			break;
		case eChainProof::heaviest:
			mHeaviestPathGuardian.unlock();

			break;
		default:
			break;
		}
		return true;
	}

	std::vector <std::vector<uint8_t>> path;


	//checkpoints are ordered from the latest to oldest block  - as known by the other peer.


	if (!blockAFound || !blockBFound)
	{
		//searches need to begin from the end of the list since queries regarding latest blocks are most probable
		for (int64_t i = 0; i < (*chosenPath).size(); i++)
		{
			if (!blockBFound)//first we need to find the latest block; there's no point to compare against B if A is unknown (optimization)
			{
				if (tools->compareByteVectors(blockIDB, (*chosenPath)[i]))
				{
					blockBPosition = i;
					blockBFound = true;
				}
			}
			else
				if (!blockAFound)
				{
					if (tools->compareByteVectors(blockIDA, (*chosenPath)[i]))

					{
						blockAPosition = i;
						blockAFound = true;
						break;
					}
				}
				else
				{
					break;
				}

		}

	}

	if (blockAFound && blockBFound)
	{
		proof = std::vector < std::vector<uint8_t>>((*chosenChainProof).begin() + ((blockAPosition > 0) ? (blockAPosition - 1) : 0), (*chosenChainProof).begin() + blockBPosition + 1);//inclusive
	}
	else
	{
		switch (whichChainProof)
		{
		case eChainProof::verified:
			mVerifiedPathGuardian.unlock();

			break;
		case eChainProof::verifiedCached:
			mVerifiedPathDoubleGuardian.unlock();

			break;
		case eChainProof::heaviest:
			mHeaviestPathGuardian.unlock();

			break;
		default:
			break;
		}
		return false;
	}

	switch (whichChainProof)
	{
	case eChainProof::verified:
		mVerifiedPathGuardian.unlock();

		break;
	case eChainProof::verifiedCached:
		mVerifiedPathDoubleGuardian.unlock();

		break;
	case eChainProof::heaviest:
		mHeaviestPathGuardian.unlock();

		break;
	default:
		break;
	}
	return true;
}
/// <summary>
/// Updates the chosen Path, which is a sequence of block-identifiers (hashes).
/// Note the Chain Proof, which is a sequence of block-headers and can be used to prove validity of a given
/// blockchain-path. These are updated simultaneously.
/// 
/// Used for the Verified chain-proof. For mHeaviestChainproof - the function may be used ONLY during testing.
/// </summary>
/// <param name="block"></param>
/// <returns></returns>
bool CBlockchainManager::updatePathWithLeader(std::shared_ptr<CBlock> block, eChainProof::eChainProof which, bool updatePathInColdStorage)
{
	std::shared_ptr<CTools> tools = getTools();
	//Critical Sections Meta - BEGIN
	bool verifiedPathLocked = false;
	bool heaviestPathLocked = false;
	bool chainLocked = false;
	bool leaderLocked = false;
	//Critical Sections Meta - END

	//EXTREME warning: in this function mutexex are baing managed manually.
	if (block == nullptr || block->getHeader() == nullptr)
		return false;

	//The Genesis block is the first element in vector, newer blocks are appended (pushed_back)
	std::vector<std::vector<uint8_t>>* chosenPath;
	std::vector<std::vector<uint8_t>>* chosenChainProof;

	if (which == eChainProof::verified)
	{
		//Critical Sections Manual Mode - BEGIN
		mVerifiedPathGuardian.lock();//this mutex is to protect 2 data structures (longest-path and chain-proof) 
		verifiedPathLocked = true;
		mChainGuardian.lock();
		chainLocked = true;
		mLeaderGuardian.lock();
		leaderLocked = true;
		//Critical Sections Manual Mode - END

		chosenPath = &mVerifiedPath;
		chosenChainProof = &mVerifiedChainProof;

		if (block->getHeader()->getHeight() == 0)
		{
			mVerifiedPath.clear();
			mVerifiedChainProof.clear();
			mLeader = nullptr;
		}
	}
	else
	{
		mHeaviestPathGuardian.lock();
		heaviestPathLocked = true;

		chosenPath = &mHeaviestPath;
		chosenChainProof = &mHeaviestChainProof;
	}

	std::vector<uint8_t> id = block->getID();
	eBlockInstantiationResult::eBlockInstantiationResult res;
	std::vector<uint8_t> parentID = block->getHeader()->getParentID();
	uint64_t parentIndexAtVerifiedPath = 0;
	bool parentFound = false;

	//let us check if parent present so that we know where to cut
	if ((*chosenPath).size() > 0 && parentID.size() == 32)
	{
		for (uint64_t i = (*chosenPath).size() - 1; i >= 0; i--)
		{
			if (std::memcmp(mVerifiedPath[i].data(), parentID.data(), 32) == 0)
			{
				parentIndexAtVerifiedPath = i;
				parentFound = true;
				break;
			}

			if (i == 0)// that protects against an otherwise infinite loop
				break;
		}
	}

	if (!parentFound && (*chosenPath).size() != 0)
	{

		//Critical Sections Manual Mode - BEGIN
		if (verifiedPathLocked)
			mVerifiedPathGuardian.unlock();
		if (chainLocked)
			mChainGuardian.unlock();
		if (leaderLocked)
			mLeaderGuardian.unlock();
		if (heaviestPathLocked)
			mHeaviestPathGuardian.unlock();
		//Critical Sections Manual Mode - END

		return false;//EXTREME warning: in this function mutexex are baing managed manually.
		//assert(false);//this should hot happen
	}

	if (parentFound)//if found then cut away the rest
	{
		//delete posterior entries
		if (((*chosenPath).size() - 1) > (parentIndexAtVerifiedPath))//check if there are more elements i.e. if the largest indexable element in mVerifiedPath is >( parentIndexAtVerifiedPath)
		{
			(*chosenPath).erase((*chosenPath).begin() + (parentIndexAtVerifiedPath + 1), (*chosenPath).end());//delete starting from next element after parent of the new leader
			(*chosenChainProof).erase((*chosenChainProof).begin() + (parentIndexAtVerifiedPath + 1), (*chosenChainProof).end());
		}
		//todo: optimize so that the memory is not copied over. (use something different than a vector).


	}
	//push the new leader - begin with TESTS
	(*chosenPath).push_back(id);
	std::vector<uint8_t> temp;
	assertGN(block->getHeader()->getPackedData(temp));
	(*chosenChainProof).push_back(temp);
	temp = mCryptoFactory->getSHA2_256Vec(temp);
	assertGN(getTools()->compareByteVectors(temp, id));
	//push the new leader - end

	//Validation - BEGIN
	if (chosenChainProof->size() != chosenPath->size())
	{
		tools->logEvent("Data integrity error while processing block. Reverting.", eLogEntryCategory::localSystem, 100, eLogEntryType::failure, eColor::cyborgBlood);
		//Critical Sections Manual Mode - BEGIN
		if (verifiedPathLocked)
			mVerifiedPathGuardian.unlock();
		if (chainLocked)
			mChainGuardian.unlock();
		if (leaderLocked)
			mLeaderGuardian.unlock();
		if (heaviestPathLocked)
			mHeaviestPathGuardian.unlock();
		//Critical Sections Manual Mode - END
		return false;
	}
	//Validation - END

	if (updatePathInColdStorage)
	{
		setPath(*chosenPath, which, true);
		setChainProof(*chosenChainProof, which, true);
	}

	if (which == eChainProof::verified)
	{

	}
	else
	{
		if (block->getHeader()->isKeyBlock())
		{
			setHeaviestChainProofKeyLeader(block->getHeader());
		}


	}

	//Critical Sections Manual Mode - BEGIN
	if (verifiedPathLocked)
		mVerifiedPathGuardian.unlock();
	if (chainLocked)
		mChainGuardian.unlock();
	if (leaderLocked)
		mLeaderGuardian.unlock();
	if (heaviestPathLocked)
		mHeaviestPathGuardian.unlock();
	//Critical Sections Manual Mode - END
	return true;//EXTREME warning: in this function mutexes are being managed manually.
}

/// <summary>
/// This function can be used to update the UNVERIFIED versions of local chain-proof and longest-path ONLY.
/// Note: the verified version of the history of events can be updated only by providing a new verified leader.
/// </summary>
/// <param name="subProof"></param>
/// <param name="totalDiffOfNewChainProofe"></param>
/// <returns></returns>
eChainProofUpdateResult::eChainProofUpdateResult CBlockchainManager::updateHeaviestChainProof(std::vector<std::vector<uint8_t>> subProof, uint64_t& totalDiffOfNewChainProofe)
{
	eChainProofValidationResult::eChainProofValidationResult cpValRes = eChainProofValidationResult::invalidGeneral;
	return analyzeAndUpdateChainProof(mHeaviestChainProof, cpValRes,subProof, totalDiffOfNewChainProofe);
	//return false;
}



/// <summary>
/// The function attempts to schedule blocks described within of the Heaviest Chain-Proof for commitment.
/// Missing or otherwise invalid Blocks are scheduled for download.
/// The function is state-full and employs optimizations.
/// </summary>
/// <returns>The function returns eChainProofCommitResult::eChainProofCommitResult  and nrOfCommitedBlocks - the number of committed blocks</returns>
eChainProofCommitResult::eChainProofCommitResult CBlockchainManager::commitHeaviestChainProofBlocks(uint64_t& nrOfPushedBlocks, uint64_t& nrOfBlocksScheduleForDownload)
{
	std::lock_guard<std::recursive_mutex> lock(blockQueueGuardian);//needed since there's a call to isBlockInProcessingQueue below
	//and we want to lock the entire queue since multiple threads MAY be adding blocks to the processing queue.
	std::lock_guard<ExclusiveWorkerMutex> lock1(mHeaviestPathGuardian);
	//NOTE: other critical sections will be locked below WHEN NEEDED (i.e. verified chain-proof)
	if (mHeaviestChainProof.size() == 0)
		return eChainProofCommitResult::empty;

	//LOCAL VARIABLES - BEGIN

	uint64_t maxProcessingWindowSize = 150;
	uint64_t blocksProcessed = 0;
	nrOfPushedBlocks = 0;
	nrOfBlocksScheduleForDownload = 0;
	//CTrieDB test = CTrieDB(mSolidStorage, getPerspective()); //this CTrieDB will be used for testing of achievable perspectives.
	uint64_t verifiedUpTo = 0;// getAchievablePerspectiveAtIndex();//optimization; the variable would reset each time Heaviest Chain Proof gets modified.
	uint64_t keyBlocksAvailableUpUntil = 0;
	bool alreadyMissingSomeKeyBlocks = false;
	std::shared_ptr<CBlockHeader> header = nullptr;
	std::shared_ptr <CNetworkManager> networkManager = getNetworkManager();
	CBlockHeader::eBlockHeaderInstantiationResult hir = CBlockHeader::eBlockHeaderInstantiationResult::failure;
	eBlockInstantiationResult::eBlockInstantiationResult bir = eBlockInstantiationResult::Failure;
	std::string errorInfo;
	std::shared_ptr<CBlock> block;
	uint64_t maxNrOfBlockDownloadsScheduled = MAX_SCHEDULED_DOWNLOADS;
	bool genesisBlockAvailable = false;
	bool informedAboutDownloadLimitReached = false;
	std::shared_ptr<CTools> tools = getTools();
	eChainProofCommitResult::eChainProofCommitResult toRet = eChainProofCommitResult::idle;
	uint64_t currentLeaderAtPos = 0;
	bool leaderFound = false;
	std::vector<uint8_t> leaderID = getLeaderID();
	std::shared_ptr<CBlockHeader> hbl = getHeaviestChainProofLeader();// [WARNING]: any leading block, not necessarily a key-block.
	uint64_t currentHeaviestLeaderAtPos = 0;

	if (hbl)
	{
		currentHeaviestLeaderAtPos = hbl->getHeight();
	}

	uint64_t currentHeight = getHeight();
	bool previousBlockAvailable = false;
	bool commonPointFound = false;
	uint64_t blocksAvailableLocallyUntil = 0;//blocks of the Heaviest Chain-Proof available locally until
	uint64_t alreadyHuntedBlocks = getNumberOfHuntedBlocks();
	uint64_t commonBlockAtPos = 0;
	bool commonBlockFound = false;

	//LOCAL VARIABLES - END

	if (mHeaviestChainProof.size() > 0)
	{
		if (!(verifiedUpTo < mHeaviestChainProof.size()))
		{
			tools->logEvent("Critical data integrity error: verified-up-to index exceeds Heaviest Chain-Proof length. Shutting down.", eLogEntryCategory::localSystem, 100, eLogEntryType::failure, eColor::cyborgBlood);
			CGRIDNET::getInstance()->shutdown();
			return eChainProofCommitResult::error;
		}
	}
	//[Documentation]
	//Flow mechanics have the property of being able to retrieve all the proceeding data-blocks on sight of the latest one,
	//if data blocks available locally.
	// 
	// *****************************
	//[IMPORTANT Update]: the above is no longer true. We no longer rely on a recursion during Flow. That was decided to impose more overhead 
	// (the recursive retrieval of parent blocks) than an iterative approach occurring in this very function. So now we search for a point
	// in the heaviest chain-proof up to which we have BOTH all the blocks locally available for processing and whose directly proceeding block
	// is the current leader within the Verified Chain Proof.
	// *****************************
	// 
	// Thus below we verify up until which point on the Heaviest Chain-Proof processing resulted in 
	//a valid perspective. We cache that point for efficiency. Any points for which data is no available or for which processing
	//must have failed for whatever reason, are either re-processed (enqueued onto the Blockchain Manager for processing)
	//or are scheduled for (re)download from the Network. Note blocks are marked as having been successfully  scheduled for download
	//only if the process succeeded for at least one (active) Synchronization Link. Such tasks are scheduled on a per-connection basis.
	//Further notice, notice that a Robin Hood-based cache is used for verification of local data availability.
	//Only Blockchain Manager can mark a data-block as available locally ONLY after having done its preliminary analysis.
	//Blocks are NOT marked as available locally immediately upon their download from other peers.
	//This might cause an excessive network overhead if the block-processing queue is heavily occupied and the system
	//schedules blocks for re-download even though they have been already enqueued for local processing and data actually available.
	//That is likely to happen only during the initial synchronization and we thus limit the attack surface stemming from possible 
	//network eclipsing attacks.


	//Operational Logic - BEGIN

	//Find current leader within the chain-proof
	if (mHeaviestPath.size())
	{
		for (uint64_t i = mHeaviestPath.size() - 1; i > 0; i--)
		{
			if (tools->compareByteVectors(mHeaviestPath[i], leaderID))
			{
				currentLeaderAtPos = i;
				leaderFound = true;
				break;
			}
		}
	}

	if (leaderFound)
	{
		//verifiedUpTo = currentLeaderAtPos;
		//previousBlockAvailable = true;

	}
	else if (mHeaviestPath.size())
	{

		previousBlockAvailable = isBlockAvailableLocally(mHeaviestPath[0]);
	}
	mVerifiedPathGuardian.lock();
	if (mVerifiedChainProof.size() && mHeaviestChainProof.size())
	{//try to find recent blocks from heaviest path in verified path so that we know from where to begin enqueing blocks for processing.

		// Create a map to store hashed values of mHeaviestPath with their corresponding index
		std::unordered_map<std::vector<uint8_t>, uint64_t> hashedHeaviestPath;
		try {
			// Pre-reserve to reduce reallocations
			hashedHeaviestPath.reserve(mHeaviestPath.size());

			for (uint64_t y = mHeaviestPath.size(); y-- > 0;) {
				hashedHeaviestPath[mHeaviestPath[y]] = y;
			}
		}
		catch (const std::bad_alloc& e) {
			tools->logEvent("Failed to build heaviest path index: Out of memory. Path size: " +
				std::to_string(mHeaviestPath.size()),
				eLogEntryCategory::localSystem, 100, eLogEntryType::warning);

			// Clean up and return error
			return eChainProofCommitResult::error;
		}

		// Now iterate over mVerifiedPath in reverse and look for a match in the map
		for (uint64_t i = mVerifiedPath.size(); i-- > 0;) {
			auto it = hashedHeaviestPath.find(mVerifiedPath[i]);
			if (it != hashedHeaviestPath.end()) {
				commonBlockAtPos = it->second;
				verifiedUpTo = it->second;
				commonBlockFound = true;
				previousBlockAvailable = true;
				break;
			}
		}
	}


	mVerifiedPathGuardian.unlock();

	if (commonBlockAtPos > 0)
	{
		genesisBlockAvailable = true;
		blocksAvailableLocallyUntil = commonBlockAtPos;//since these have been verified already, prior blocks must be available locally as well.
		//keyBlocksAvailableUpUntil = commonBlockAtPos;
	}

	for (uint64_t i = (commonBlockAtPos == 0 ? 0 : (commonBlockAtPos + 1));
		(i < mHeaviestChainProof.size());
		i++)
	{

		++blocksProcessed;
		if (blocksProcessed >= maxProcessingWindowSize)
		{
			tools->logEvent("Max. Processing window size for heaviest chain-proof reached.", eLogEntryCategory::localSystem, 10, eLogEntryType::warning);
			break;//other sub-systems are waiting for mutexes locked here! Like network manager with its block downloads.
		}

		header = CBlockHeader::instantiate(mHeaviestChainProof[i], hir, errorInfo, false);

		if (header == nullptr)
		{
			tools->logEvent("Critical data integrity error: invalid block-header data within the Heaviest Chain-Proof. Shutting down.", eLogEntryCategory::localSystem, 100, eLogEntryType::failure, eColor::cyborgBlood);
			CGRIDNET::getInstance()->shutdown();
			return eChainProofCommitResult::error;
		}

		//look-up the latest (+1) key-block  available.
		//Rationale: We do NOT want to be downloading unverified data-blocks.
		//if Blockchain Manager sees a data-block WITHOUT a corresponding key-block, then the block would not even be considered for local storage.
		if (!alreadyMissingSomeKeyBlocks && header->isKeyBlock()) {
			keyBlocksAvailableUpUntil = header->getHeight();

			if (!isBlockAvailableLocally(mHeaviestPath[i]))
				alreadyMissingSomeKeyBlocks = true;
		}

		//The fact that the block is available locally does not mean that it's valid and or verified.
		//If we check the encapsulated 'perspective' though, we may see whether the block-path leading to it (and including it)
		//has been previously verified, meaning whether all previous blocks including it were previously processed. Under the assumption
		//that data-pruning is not enabled (and it is, enabled), thus the below would fail for distant 'realms'.

		//Thus, under the assumption that data pruning is enabled, we need to be checking for block availability starting from the Genesis Block, moving on towards
		/*newer entries within the Heaviest Chain-Proof, scheduling blocks for download the very same moment. THEN we enque for processing ONLY the last block up-until which
		* all of the proceeding blocks have been made available locally. The Flow mechanics would reconstruct the path on demand, seeing just the latest block.
		*
		* As an optimization we start processing from the next block after current leader, if found.
		*
		*/

		//Yet again, if a block is present within the Heaviest Chain-Proof, then perspective of each block needs to be 'reachable'.

		if (i == 0 && isBlockAvailableLocally(mHeaviestPath[i]))
		{
			genesisBlockAvailable = true;
		}


		if (previousBlockAvailable && isBlockAvailableLocally(mHeaviestPath[i]))
		{// assume that the block has not been processed yet. Push it for processing.
			blocksAvailableLocallyUntil = i;
		}
		else
		{
			previousBlockAvailable = false;
			// The block certainly is not available locally, schedule for download now.
			// Block is missing from Cold Storage. Fetch it.
			if ((alreadyHuntedBlocks + nrOfBlocksScheduleForDownload) < maxNrOfBlockDownloadsScheduled)
			{//schdule for download only if not in processing queue already
				if (networkManager && !isBlockInProcessingQeueue(mHeaviestPath[i]) && !networkManager->isBlockCurrentlyBeingFetched(mHeaviestPath[i]))
				{
					if (!(header->isKeyBlock() == false && header->getHeight() < keyBlocksAvailableUpUntil))
					{
						if ((currentHeight != 0 || genesisBlockAvailable) || header->getHeight() == 0)//if no blocks, focus on searching for the genesis block.
						{
							if (addBlockToHuntedList(mHeaviestPath[i], header))
							{
								nrOfBlocksScheduleForDownload++;
							}
						}

					}
				}
			}
			else if (!informedAboutDownloadLimitReached)
			{
				informedAboutDownloadLimitReached = true;
				tools->logEvent("Concurrent block download limit reached. Waiting.", eLogEntryCategory::localSystem, 0, eLogEntryType::warning, eColor::lightPink);
			}
		}


	}

	if (!genesisBlockAvailable)
	{
		getTools()->logEvent("Still searching for The Genesis Block. Can't proceed further.", eLogEntryCategory::localSystem, 10, eLogEntryType::notification, eColor::lightGreen);
	}

	//account for the special case in which the Genesis Block is available but it wasn't processed yet.
	bool processGenesis = false;
	if (genesisBlockAvailable && leaderID.size() == 0)
	{
		processGenesis = true;
	}
	//account for a special case in which the Genesis Block is available, it was processed, BUT - it differs from the Genesis Block already proclaimed.
	else if (genesisBlockAvailable && !commonBlockFound)//We know it differs because no common block was found, when comparing the Verified and Heaviest Chain Proofs.
	{
		processGenesis = true;
	}

	// Schedule Blocks - BEGIN

	// Schedule Blocks - BEGIN
	if (processGenesis || ((commonBlockAtPos < currentHeaviestLeaderAtPos) && currentLeaderAtPos != currentHeaviestLeaderAtPos))
	{
		// [Rationale]: We attempt to commit locally available blocks in sequence, maintaining chain continuity.
		// For non-genesis case, we must start at commonBlockAtPos+1 to ensure proper chain linking.
		// For genesis case, we start at height 0.
		// The scheduling is done for all consecutive blocks that are:
		// 1. Available locally (either in cache or storage)
		// 2. Form an unbroken sequence from start height
		// 3. Each block's height matches its expected position in chain

		uint64_t expectedStartHeight = processGenesis ? 0 : currentHeight + 1;
		uint64_t startIndex = processGenesis ? 0 : (commonBlockAtPos + 1);


		if (startIndex < expectedStartHeight)
		{
			expectedStartHeight = startIndex; // valid block candidate may have block height lower than that of currently proclaimed leader
		}

		bool sequenceBroken = false;

		volatile bool scheduledNextAfterCurrentLeader = false;
		// Validate sequence and schedule blocks
		for (uint64_t i = startIndex; i <= blocksAvailableLocallyUntil && !sequenceBroken; i++)
		{
			// Check if block height matches expected sequence position
			auto heightCheckHeader = CBlockHeader::instantiate(mHeaviestChainProof[i], hir, errorInfo, false);
			if (!heightCheckHeader || heightCheckHeader->getHeight() != expectedStartHeight + (i - startIndex))
			{
				tools->logEvent(
					"Block sequence break detected at index " + std::to_string(i) +
					", expected height " + std::to_string(expectedStartHeight + (i - startIndex)),
					eLogEntryCategory::localSystem,8,eLogEntryType::notification,eColor::lightPink);
				sequenceBroken = true;
				break;
			}

			// Block Detached Cache Support - BEGIN
			// Rationale: blocks added as soon as these are downloaded. To omit re-instantiation.
			// This allows us to use already downloaded blocks without accessing cold storage.
			block = getBlockFromUnorderedCache(mHeaviestPath[i]);

			if (block)
			{
				bir = eBlockInstantiationResult::OK;
			}
			// Block Detached Cache Support - END
			else
			{
				block = mSolidStorage->getBlockByHash(mHeaviestPath[i], bir);
			}

		

			if (block && bir == eBlockInstantiationResult::OK)
			{
				// Block is available - schedule it for processing
				pushBlock(block, true);
				nrOfPushedBlocks++;
			}
			else
			{
				// Attempt to schedule block download only if:
				// 1. For height 0 - always allow (genesis block)
				// 2. For other heights - only if we have genesis block
				if (currentHeight != 0 || heightCheckHeader->getHeight() == 0)
				{
					// Block instantiation failed - schedule network download if not already queued
					if (!isBlockInProcessingQeueue(mHeaviestPath[i]))
					{
						if (addBlockToHuntedList(mHeaviestPath[i], heightCheckHeader))
						{
							nrOfBlocksScheduleForDownload++;
						}
					}
				}
				// Break sequence since current block unavailable
				sequenceBroken = true;
			}
		}

		if (sequenceBroken)
		{
			tools->logEvent(
				"Block scheduling stopped at height " + std::to_string(expectedStartHeight + nrOfPushedBlocks),
				eLogEntryCategory::localSystem, 8, eLogEntryType::notification, eColor::lightPink);
		}
	}
	// Schedule Blocks - END


	if (nrOfPushedBlocks)
	{
		toRet = eChainProofCommitResult::blocksEnqued;
	}
	return toRet;
	//Operational Logic - END
}


uint64_t CBlockchainManager::getSyncPercentage()
{
	std::lock_guard<std::mutex> lock(mFieldsGuardian);
	return mSynchronizationPercentage;
}

void CBlockchainManager::setSyncPercentage(uint64_t percentage)
{
	std::lock_guard<std::mutex> lock(mFieldsGuardian);
	mSynchronizationPercentage = percentage;
}

bool CBlockchainManager::attemptToLockHeaviestPath()
{
	return mHeaviestPathGuardian.try_lock();
}

void CBlockchainManager::unlockHeaviestPath()
{
	mHeaviestPathGuardian.unlock();
}
/// <summary>
/// Note: This function is NOT used when doing block processing.
/// It might be used when doing verification of chain proofs received from network.
/// IMPORTANT: The function would never allow for modification of the mVerifiedChainProof (returns an error).
/// Updates provided chainProof (sequence of block headers) given the other (sub)-proof.
/// The function does total cumulative chain-weight analysis.
/// There NEEDS TO be a common point between subProof and chainProof for the function to succeed.
/// The function does NOT verify subProof with the help of local blocks even if available.
/// Both the chainProof and subProof are verified first separately. BUT for a situation where chainProof is the local mHeaviestChainProof which is assumed to be valid(optimization).
/// 
/// 
/// This function can be used to analyze and merge any given two chainProofs into one IF the resulting chainProof has greater total difficulty than the initial one.
/// Otherwise, the function returns false.
/// The function return False also when no common point between the  proofs is found.
/// Optimizations:
/// If, the chainProof is found to be the local-heaviest-chainProof (mHeaviestChainProof NOT the verified mVerifiedChainProof), the mHeaviestPath and mHeaviestChainProof are updated also
/// including the data in cold-storage.
/// 

void CBlockchainManager::setSyncIsStuck(bool isIt)
{
	std::lock_guard<std::mutex> lock(mFieldsGuardian);

	if (isIt == mSyncIsStuck)
		return;

	std::shared_ptr<CTools> tools = getTools();

	if (isIt)
	{
		tools->logEvent("Synchronization seems stuck.", "Vitals Monitoring", eLogEntryCategory::localSystem, 10,
			eLogEntryType::warning, eColor::lightPink);
	}
	else if (mSyncIsStuck)
	{
		tools->logEvent("Synchronization seems stuck no more.", "Vitals Monitoring", eLogEntryCategory::localSystem, 10,
			eLogEntryType::warning, eColor::lightGreen);
	}
	mSyncIsStuck = isIt;

}

bool CBlockchainManager::getIsSyncStuck()
{
	std::lock_guard<std::mutex> lock(mFieldsGuardian);
	return mSyncIsStuck;
}

eChainProofUpdateResult::eChainProofUpdateResult CBlockchainManager::analyzeAndUpdateChainProofExt(std::vector<std::vector<uint8_t>> subChain, eChainProofValidationResult::eChainProofValidationResult& result, std::vector<std::vector<uint8_t>>& resultingCompleteChainProof, uint64_t& totalDiffOfNewChainProof, const uint64_t& blocksScheduledForDownloadCount, const std::vector<uint8_t>& receivedPackedChainProof, uint64_t barID, bool doColdStorage)
{
	/*
	std::lock_guard<std::recursive_mutex> locka(mBlockProcessingGuardian);
	std::lock_guard<std::recursive_mutex> lock3(mLeaderGuardian);
	std::lock_guard<std::recursive_mutex> lock1(mHeaviestPathGuardian);//this mutex is to protect 2 data structures (longest-path and chain-proof)
	std::lock_guard<std::recursive_mutex> lock2(mChainGuardian);
	*/
	return analyzeAndUpdateChainProof(subChain, result, mHeaviestChainProof, totalDiffOfNewChainProof, blocksScheduledForDownloadCount, receivedPackedChainProof, 999, doColdStorage, resultingCompleteChainProof);
}
/// 
/// That is why when queering peers, we're doing a 3step gradual fall-back when asking for a chain-proof.
/// In worst case scenario, the 3rd chain-proof we ask for will be the full-chain-proof, one starting from the very Genesis Block.
/// </summary>
/// <param name="chain"></param>
/// <param name="proof"></param>
/// <returns></returns>
eChainProofUpdateResult::eChainProofUpdateResult CBlockchainManager::analyzeAndUpdateChainProof(std::vector<std::vector<uint8_t>> subChain,
	eChainProofValidationResult::eChainProofValidationResult& result,
	std::vector<std::vector<uint8_t>>& chainProof,
	uint64_t& totalDiffOfNewChainProof, 
	const uint64_t& blocksScheduledForDownloadCount, 
	const std::vector<uint8_t>& receivedPackedChainProof,
	uint64_t barID, 
	bool doColdStorage,
	const std::vector<std::vector<uint8_t>>& resultingCompleteChainProof)
{

	//pre-processing (to cover for a bug?)
	if (subChain.size() && subChain[subChain.size() - 1].empty())
	{
		subChain.pop_back();
	}

	bool startedAnalyzingLongChainProof = false;
	if (receivedPackedChainProof.size() && subChain.size() > 1000)
	{
		startedAnalyzingLongChainProof = true;
		setIsProcessingLongChainProof(true);
		getTools()->logEvent("I'm about to process a very long incoming Chain-Proof (" + std::to_string(subChain.size()) + "). Status will be shown..", eLogEntryCategory::localSystem, 10, eLogEntryType::notification, eColor::lightPink);
	}

	bool heaviestPathGuardianLocked = false;

	uint64_t currentHeight = getCachedHeight();//WARNING: it is PLUS ONE

	std::vector<uint64_t> heaviestPoWsProposal;
	if (subChain.size() == 0)//|| chainProof.size() == 0 <- no genesis block might be available locally which is perfectly fine
	{
		if (startedAnalyzingLongChainProof)
			setIsProcessingLongChainProof(false);
		return eChainProofUpdateResult::Error;
	}

	//backup the chain-proof since it will be replaced ONLY if:
	// - the resulting total weight is greater than its current one
	// - the resulting weight is same but length is greater
    // - it contains more blocks meeting checkpoints

	std::vector<std::vector<uint8_t>> newChainProofProposal = chainProof;
	std::shared_ptr<CBlockHeader> keyLeader;

	//logical flags
	bool valid = true;
	bool isHeaviestChainProof = false;
	bool commonPointAFound = false;
	bool doVerifyChainProof = true;
	std::shared_ptr<CTools> tools = getTools();
	std::shared_ptr<CStatusBarHub> barHub = CStatusBarHub::getInstance();
	std::vector<uint64_t> heaviestPoWsBackup;
	eBlockchainMode::eBlockchainMode mode = getMode();
	//common header indicators
	totalDiffOfNewChainProof = 0;
	uint64_t commonPointAtSubchainProof = 0;
	uint64_t commonPointAtChainProofIndex = 0;
	bool chainProofContainsGenesis = false;
	//total difficulty per chain proof
	uint64_t currentTotalDiff = 0;
	uint64_t subProofTotalDiff = 0;
	bool optimizing = false;

	//is this the main ChainProof?
	if (&chainProof == &mHeaviestChainProof)
	{
		mHeaviestPathGuardian.lock();
		heaviestPoWsBackup = mHeaviestChainProofCumulativePoWs;
		heaviestPathGuardianLocked = true;
		isHeaviestChainProof = true;
	}
	else if (&chainProof == &mVerifiedChainProof)
	{
		if (startedAnalyzingLongChainProof)
			setIsProcessingLongChainProof(false);
		if (heaviestPathGuardianLocked)
			mHeaviestPathGuardian.unlock();
		valid = false;
		return eChainProofUpdateResult::Error;//read description
	}

	//if so.. do some assumptions
	if (isHeaviestChainProof)
	{

		doVerifyChainProof = false;//do not verify the main chainProof (optimization; this is done at startup).
		currentTotalDiff = getHeaviestChainProofTotalDifficulty();
		if (mHeaviestChainProof.size())
		{
			currentHeight++;
		}
	}

	// Infant Local Heaviest Chain Proof - BEGIN
	if (currentTotalDiff == 0 && subChain.size() != 0)//it won't be 0 for mHeaviestChainProof if it was validated previously (and it was). within CBlockchainManager's constructor.
	{//do not validate for an empty local chain-proof.

		// [ MULTI-CALL] verifyChainProof() call 1/3
		
		// Negative (0) is POSITIVE (enum). Positive is Wrong.
		result = verifyChainProof(subChain,
			currentTotalDiff,
			false,
			false,
			nullptr,
			false,
			std::vector<uint64_t>(),
			nullptr,
			0,
			false,
			false, // do NOT require checkpoints to be present in a (possibly) PARTIAL chain-proof. Further checks, after chain proof is reconstructed would reveal this anyway.
			100,
			false);
		if (result)//do not validate the chainProofProposal against local data i.e. do not calculate total difficulty
			//taking into account parental blocks that were not included in the chain-proof itself, there's no need, if there's a common point found, we will calculate it anyway.
		{
			if (startedAnalyzingLongChainProof)
				setIsProcessingLongChainProof(false);
			if (heaviestPathGuardianLocked)
				mHeaviestPathGuardian.unlock();
			valid = false;
			return eChainProofUpdateResult::invalidData;
		}
	}
	// Infant Local Heaviest Chain Proof - END



	// Account for the existing Chain-Proof - BEGIN
	// find a common point A between subProof and chainProof, closest (and only - assuming good resistance to collisions of SHA256) to  Genesis block.
	std::vector<uint8_t> hash;
	// Assuming chainProof and subChain have the same size. Adjust if not.
	size_t totalSize = chainProof.size();

	if (totalSize > 0)  // Protect against division by zero
	{
		int lastProgressReported = -1;

		// Create a map to store hashed values of chainProof with their corresponding index
		std::unordered_map<std::vector<uint8_t>, uint64_t> hashedChainProof;
		for (uint64_t i = totalSize; i-- > 0;) {
			hash = mCryptoFactory->getSHA2_256Vec(newChainProofProposal[i]);  // Replace with actual hash computation
			hashedChainProof[hash] = i;

			// Report progress if it has changed
			int progress = (int)((double)(totalSize - i) / totalSize * 100); // Compute progress after hash is added to the map
			if (progress != lastProgressReported) {
				barHub->setCustomStatusBarText(mode, barID, "[Chain-Proof] analysis: " + std::to_string(progress) + " % ");

				lastProgressReported = progress;
			}
		}

		// Reset for the subChain loop
		lastProgressReported = -1;
		uint64_t subChainSize = subChain.size();

		// Now iterate over subChain and look for a match in the map
		for (uint64_t y = subChainSize; y-- > 0; ) {
			hash = mCryptoFactory->getSHA2_256Vec(subChain[y]);  // Replace with actual hash computation
			auto it = hashedChainProof.find(hash);
			if (it != hashedChainProof.end()) {
				commonPointAtChainProofIndex = it->second;
				commonPointAtSubchainProof = y;
				commonPointAFound = true;
				break;
			}

			// Report progress if it has changed
			int progress = (int)((double)(subChainSize - y) / subChainSize * 100); // Compute progress after hash is looked up in the map
			if (progress != lastProgressReported) {
				barHub->setCustomStatusBarText(mode, barID, "[Chain-Proof] searching common point: " + std::to_string(progress) + " %");
				lastProgressReported = progress;
			}
		}
	}

	// Debugging - BEGIN
	if (!subChain.empty()) {
		CBlockHeader::eBlockHeaderInstantiationResult ebhrLeading, ebhrTrailing;
		std::string errLeading, errTrailing;
		std::stringstream report;
		report << "Chain-Proof Analysis Report:\n";

		// Analyze first block of subChain
		std::shared_ptr<CBlockHeader> leadingBlock = CBlockHeader::instantiate(subChain[0], ebhrLeading, errLeading, false, mMode);
		std::vector<uint8_t> leadingHash = CCryptoFactory::getInstance()->getSHA2_256Vec(subChain[0]);

		if (leadingBlock) {
			report << "[ Sub-Chain Start ]  Height: " << leadingBlock->getHeight()
				<< " Key Height: " << leadingBlock->getKeyHeight()
				<< " Type: " << (leadingBlock->isKeyBlock() ? "Key" : "Data")
				<< " ID: " << tools->base58CheckEncode(leadingHash);
		}
		else {
			report << "[ Sub-Chain Start ]  Error instantiating block. Error: " << errLeading;
		}

		// Analyze last block of subChain
		std::shared_ptr<CBlockHeader> trailingBlock;
		std::vector<uint8_t> trailingHash;

		if (subChain.size() > 1) {
			trailingBlock = CBlockHeader::instantiate(subChain[subChain.size() - 1], ebhrTrailing, errTrailing, false, mMode);
			trailingHash = CCryptoFactory::getInstance()->getSHA2_256Vec(subChain[subChain.size() - 1]);

			if (trailingBlock) {
				report << "\n[ Sub-Chain End ]    Height: " << trailingBlock->getHeight()
					<< " Key Height: " << trailingBlock->getKeyHeight()
					<< " Type: " << (trailingBlock->isKeyBlock() ? "Key" : "Data")
					<< " ID: " << tools->base58CheckEncode(trailingHash);
			}
			else {
				report << "\n[ Sub-Chain End ]    Error instantiating block. Error: " << errTrailing;
			}
		}
		else {
			report << "\n[ Sub-Chain End ]    Same as start (single block chain)";
		}

		report << "\n[ Sub-Chain Size ]   Elements: " << subChain.size();

		// Common Point Analysis
		if (!commonPointAFound) {
			report << "\n[ Gap Analysis ]     No common point found between chains";

			// Analyze potential gaps
			if (!chainProof.empty()) {
				std::shared_ptr<CBlockHeader> chainProofStart = CBlockHeader::instantiate(chainProof[0], ebhrLeading, errLeading, false, mMode);
				std::shared_ptr<CBlockHeader> chainProofEnd = CBlockHeader::instantiate(chainProof[chainProof.size() - 1], ebhrTrailing, errTrailing, false, mMode);

				if (chainProofStart && chainProofEnd && leadingBlock && trailingBlock) {
					report << "\n[ Chain Gap ]       Local chain: Heights "
						<< chainProofStart->getHeight() << " to " << chainProofEnd->getHeight()
						<< "\n                    Sub-chain: Heights "
						<< leadingBlock->getHeight() << " to " << trailingBlock->getHeight();

					// Detect if chains are disjoint or overlapping
					if (leadingBlock->getHeight() > chainProofEnd->getHeight()) {
						report << "\n[ Gap Type ]        Forward gap of "
							<< (leadingBlock->getHeight() - chainProofEnd->getHeight())
							<< " blocks";
					}
					else if (trailingBlock->getHeight() < chainProofStart->getHeight()) {
						report << "\n[ Gap Type ]        Backward gap of "
							<< (chainProofStart->getHeight() - trailingBlock->getHeight())
							<< " blocks";
					}
					else {
						report << "\n[ Gap Type ]        Overlapping heights but no matching blocks (possible fork)";
					}
				}
			}
		}
		else {
			// Common point found - provide detailed information
			std::shared_ptr<CBlockHeader> commonBlock = CBlockHeader::instantiate(chainProof[commonPointAtChainProofIndex], ebhrLeading, errLeading, false, mMode);
			if (commonBlock) {
				report << "\n[ Common Point ]    Found at:"
					<< "\n                    Local chain index: " << commonPointAtChainProofIndex
					<< "\n                    Sub-chain index: " << commonPointAtSubchainProof
					<< "\n                    Block Height: " << commonBlock->getHeight()
					<< "\n                    Key Height: " << commonBlock->getKeyHeight()
					<< "\n                    Block Type: " << (commonBlock->isKeyBlock() ? "Key" : "Data")
					<< "\n                    Block ID: " << tools->base58CheckEncode(CCryptoFactory::getInstance()->getSHA2_256Vec(chainProof[commonPointAtChainProofIndex]));
			}
		}

		tools->logEvent(report.str(), eLogEntryCategory::network, 1, eLogEntryType::notification);
	}
	// Debugging - END

	if (!commonPointAFound)
	{
		tools->logEvent(tools->getColoredString("the received chain-proof does not aim to extend the local chain ", eColor::lightPink) + " (" + std::to_string(chainProof.size()) + " elements).", "Chain-Proof",
			eLogEntryCategory::localSystem, 10);
		const_cast<std::vector<std::vector<uint8_t>>&>(resultingCompleteChainProof) = subChain;
		//ONLY IF no common-point found  validate the provided (sub) chain-proof alone..
		//obligatory validation of the sub-proof would be both redundant and open up doors to abuse (processing of sub-proofs excessive in length)

		// [ MULTI-CALL] verifyChainProof() call 2/3 ( optional )

		// Negative (0) is POSITIVE (enum). Positive is Wrong.
		result = verifyChainProof(subChain,
			subProofTotalDiff,
			false,
			startedAnalyzingLongChainProof,
			keyLeader, 
			chainProofContainsGenesis,
			heaviestPoWsProposal,
			nullptr,
			0, 
			false, 
			true, // <- since no common point was found we need to assume this is a complete chain-proof (since Genesis Block) candidate. Thus, all checkpoints are required.
			100, 
			false);
		
		if (result)//do not validate the subProof against local data
		{
			if (startedAnalyzingLongChainProof)
				setIsProcessingLongChainProof(false);
			if (heaviestPathGuardianLocked)
				mHeaviestPathGuardian.unlock();
			valid = false;
			return eChainProofUpdateResult::invalidData;
		}

	}


	if (commonPointAFound && newChainProofProposal.size() && ((newChainProofProposal.size() - 1) > commonPointAtChainProofIndex))//check if the largest indexable element has higher index than the common-point//if so, erase the following ones.
	{//a common point was found; we can eliminate trailing blocks for now
		newChainProofProposal.erase(newChainProofProposal.begin() + commonPointAtChainProofIndex + 1, newChainProofProposal.end());

		//if (isHeaviestChainProof) WARNING: Do *NOT* alter the LIVE data-structures JUST YET.  mHeaviestChainProofCumulativePoWs is a LIVE data structure.
		//{
		//	mHeaviestChainProofCumulativePoWs.erase(mHeaviestChainProofCumulativePoWs.begin() + commonPointAtChainProofIndex + 1, mHeaviestChainProofCumulativePoWs.end());
		//}
	}
	else if (!commonPointAFound)
	{//there's no common point at all;in such a case the provided sub-chain-proof would need to start at the genesis block and comprise best history of events

		newChainProofProposal.clear();
	}

	//now, transplant entries from the new sub-chain beginning from the first entry *after* the commonPointSubChain
	if (commonPointAFound && subChain.size() && (commonPointAtSubchainProof + 1) <= (subChain.size() - 1))//check if there's anything to transplant.
	{
		for (uint64_t i = commonPointAtSubchainProof + 1; i <= subChain.size() - 1; i++)//there's a boundary check already within protecting access to subChain
		{
			newChainProofProposal.push_back(subChain[i]);
		}
	}
	else if (!commonPointAFound && newChainProofProposal.empty())
	{
		newChainProofProposal = std::move(subChain);
	}


	//Verify Chain-Proof Proposal - BEGIN

	std::shared_ptr<CBlockHeader> bl;
	optimizing = isHeaviestChainProof && commonPointAtChainProofIndex;
	//notice:we'll be using 'PoWs' later on, ONCE it is decided that we update the heaviest chain-proof.

		//OPTIMIZATION: verifyChainProof() would automatically use optimization IF it detects the target chain-proof to be the Heaviest Chain-Proof AND
		// if additional conditions are met. These additional conditions are MANDATORY. If not met, the function would throw a FATAL exception (which is by design).

		//Optimization Logic: verify only starting from the common point found among the heaviest chain-proof and the provided sub-chain.
		//IMPORTANT: the optimization mechanics NEEDS pre-generated PoWs - valid for the heaviest chain-proof only.
	bool report = (isHeaviestChainProof && heaviestPathGuardianLocked && newChainProofProposal.size() > 100);
	if (report)
	{
		tools->logEvent("About to process a long chain-proof. Status will be shown..", eLogEntryCategory::localSystem, 10, eLogEntryType::notification, eColor::orange);
	}

	if (commonPointAFound)
	{
		const_cast<std::vector<std::vector<uint8_t>>&>(resultingCompleteChainProof) = newChainProofProposal;


		// [ MULTI-CALL] verifyChainProof() call 3/3
		result = verifyChainProof(newChainProofProposal, // <- Genesis Chain-Proof candidate
			totalDiffOfNewChainProof,
			true,
			report,
			keyLeader,
			false,
			heaviestPoWsProposal,
			bl, 
			commonPointAtChainProofIndex,
			true,
			true, // <- this is final since-Genesis-block chain-proof candidate, thus - all checkpoints are required. 
			100,
			false);
		
		// Negative (0) is POSITIVE (enum). Positive is Wrong.
		if (result)//it IS required. now we check if the total diff of newChainProofProposal > currentTotalDiff 
		{
			if (startedAnalyzingLongChainProof)
				setIsProcessingLongChainProof(false);
			if (heaviestPathGuardianLocked)
				mHeaviestPathGuardian.unlock();
			valid = false;
			return eChainProofUpdateResult::invalidData;//if so, we update our chain-proof. NOW, we want to use cold storage INDEED.
		}
	}
	else
	{

		//no need to verify as we've been transplanting the entire chain-proof from point 0.
		//we had wiped out the entire 'newChainProofProposal'.

		//IMPORTANT: we would use the received packed-chain proof if provided for optimization, later on, down below - when saving to Cold Storage.

		//the PoWs list from initial validation would be used just fine.
		totalDiffOfNewChainProof = subProofTotalDiff;//we thus assume the difficulty of the received chain-proof as total chain proof difficulty.

		//Notice: heaviestPoWsProposal has already been filled-in for both cases (common point found or not).

	}
	/*if (optimizing)
	{//just a test
		uint64_t withoutOptTotalPow = 0;
		if (!verifyChainProof(newChainProofProposal, withoutOptTotalPow, true, false, keyLeader, false, PoWs, bl, 0, false))//it IS required. now we check if the total difficulty of newChainProofProposal > currentTotalDiff
		{
			if (mHeaviestPathGuardianLocked)
				mHeaviestPathGuardian.unlock();
			return eChainProofUpdateResult::invalidData;//if so, we update our chain-proof. NOW, we want to use cold storage INDEED.
		}
		assertGN(withoutOptTotalPow == totalDiffOfNewChainProof);
	}*/

	//Verify Chain-Proof Proposal - END

//Account for the existing Chain-Proof - END

	//note in case of updating heaviest chain:
	//if we're doing a CUT within area of the block-cache (in mem cached sequence of blocks), then, there won't be a need to retrieve all the blocks up to the genesis block
	//since the blocks in cache have their mTotalWorkDone field set, during updates of the total required difficulty.
	//there's always the amount of blocks required for difficulty updated within RAM
//todo:optimize, keep only key-blocks there?


	// Checkpoints Assessment - BEGIN

// Variables to track checkpoint verification results:
//
// For the local heaviest chain-proof (chainProof):
//   - latestCheckpointAtHeightCPLocal: the highest block height for which a checkpoint has been verified
//   - checkpointsPresentInHeaviestLocal: the count of verified checkpoints
//
// For the proposed chain-proof (newChainProofProposal):
//   - latestCheckpointAtHeightCPProposal: the highest block height for which a checkpoint has been verified
//   - checkpointsPresentInHeaviestProposal: the count of verified checkpoints
//
	int64_t latestCheckpointAtHeightCPProposal = 0;   // For newChainProofProposal
	int64_t latestCheckpointAtHeightCPLocal = 0;      // For chainProof
	uint64_t checkpointsPresentInHeaviestLocal = 0;     // Count for chainProof
	uint64_t checkpointsPresentInHeaviestProposal = 0;  // Count for newChainProofProposal

	if (isHeaviestChainProof) // Only perform this assessment when updating the local heaviest chain-proof
	{
		// Retrieve the sorted list of checkpoints (assumed to be in ascending order of block height)
		std::vector<std::shared_ptr<CBCheckpoint>> checkpoints = getCheckpoints();

		// Define a local structure to bundle a chain-proof with its associated result variables.
		struct ProofInfo {
			std::vector<std::vector<uint8_t>>* cp; // Pointer to the chain-proof under assessment.
			int64_t* latestCheckpoint;             // Pointer to the variable tracking the latest verified checkpoint height.
			uint64_t* checkpointCount;             // Pointer to the variable counting verified checkpoints.
		};

		// Create an array with both the local chain-proof and the proposed chain-proof,
		// along with their corresponding result variables.
		ProofInfo proofs[] = {
			{ &chainProof,            &latestCheckpointAtHeightCPLocal,   &checkpointsPresentInHeaviestLocal },
			{ &newChainProofProposal, &latestCheckpointAtHeightCPProposal, &checkpointsPresentInHeaviestProposal }
		};

		// Loop over each chain-proof candidate.
		for (const auto& proof : proofs)
		{
			// For clarity, assign the target chain-proof pointer.
			std::vector<std::vector<uint8_t>>* targetCP = proof.cp;

			// Iterate over each checkpoint.
			for (const auto& checkpoint : checkpoints)
			{
				// Retrieve the checkpoint height.
				uint64_t checkpointHeight = checkpoint->getHeight();

				// Ensure the chain-proof has a block header at the checkpoint's height.
				// Since the chain-proof is zero-indexed, its size must exceed the checkpoint height.
				if (checkpointHeight >= targetCP->size())
				{
					// The chain-proof is too short; no further checkpoints can be verified.
					break;
				}

				// Compute the SHA2-256 hash for the block header at the checkpoint's height.
				std::vector<uint8_t> computedHash = mCryptoFactory->getSHA2_256Vec((*targetCP)[checkpointHeight]);

				// Compare the computed hash with the expected hash from the checkpoint.
				if (!tools->compareByteVectors(checkpoint->getHash(), computedHash))
				{
					// Mismatch found: the block header does not match the checkpoint.
					break;
				}

				// Successful verification for this checkpoint:
				// Update the latest verified checkpoint height and increment the checkpoint count.
				*(proof.latestCheckpoint) = checkpointHeight;
				++(*(proof.checkpointCount));
			}
		}
	}
	// Checkpoints Assessment - END


// Decision Criteria for Accepting the New Chain-Proof Proposal:
//
// The new chain-proof is accepted if ANY of the following conditions is met:
// 1. It has a higher total difficulty than the current chain-proof.
//    (totalDiffOfNewChainProof > currentTotalDiff)
// 2. It has an equal total difficulty but is longer (i.e., contains more blocks).
//    This ensures that a chain extension by adding data blocks is favored.
//    (totalDiffOfNewChainProof == currentTotalDiff && newChainProofProposal.size() > chainProof.size())
// 3. When updating the heaviest chain-proof, it has advanced further by verified checkpoints.
//    (isHeaviestChainProof && latestCheckpointAtHeightCPProposal > latestCheckpointAtHeightCPLocal)
	if (totalDiffOfNewChainProof > currentTotalDiff  // Condition 1: Higher total difficulty.
		|| (totalDiffOfNewChainProof == currentTotalDiff && newChainProofProposal.size() > chainProof.size()) // Condition 2: Equal difficulty but longer.
		|| (isHeaviestChainProof && latestCheckpointAtHeightCPProposal > latestCheckpointAtHeightCPLocal) // Condition 3: More advanced checkpoints.
		)
	{
		std::vector<uint8_t> id;
		chainProof = std::move(newChainProofProposal);//move the chain-proof proposal, we'll compute the path in a sec if needed - in case of the heaviest chain-proof.


		//Heaviest Chain-Proof - BEGIN
		if (isHeaviestChainProof)
		{
			if (!keyLeader)
			{
				tools->logEvent("Processing of the provided chain-proof failed. ", eLogEntryCategory::localSystem, 10, eLogEntryType::notification, eColor::cyborgBlood);
				if (heaviestPathGuardianLocked)
				{

					mHeaviestPathGuardian.unlock();
					heaviestPathGuardianLocked = false;
					return eChainProofUpdateResult::Error;
				}
			}
			//if (getAchievablePerspectiveAtIndex() > commonPointAtChainProofIndex)//we do not want to invalidate reachability of perspectives in the entire mHeaviestChainProof
				//setAchievablePerspectiveAtIndex(commonPointAtChainProofIndex);//but we certainly do need to invalidate up to the beginning of the new part. 
			tools->logEvent("Provided chain-proof results in the best known history of events ( " + std::to_string(chainProof.size()) + " elements ). Updating.. ", eLogEntryCategory::localSystem, 10, eLogEntryType::notification, eColor::lightGreen);
			//tools->writeLine("Provided chain-proof results in the best known history of events! updating..");

			//make a cut in the Heaviest Path and the Heaviest Chain-Proof (it's assumed these are synchronized already)
			//Update: we make a cut in the PATH solely, as the Heaviest Chain-Proof has been updated through a MOVE operation, above.

			//v---------------------------------------------------------------------------------------v
			//[WARNING]: 'offset' down below is NOT commonPointAtChainProofIndex. Offset indicates *THE BLOCK AFTER*.
			//^---------------------------------------------------------------------------------------^

			uint64_t offset = (commonPointAtChainProofIndex ? commonPointAtChainProofIndex + 1 : 0);
			//^ if no common point was found then we need to regenerate the entire Heaviest Path (starting from index 0)

			//check if the common point in the midst of the current heaviest chain-proof.
			//IMPORTANT: 'offset' has already been made to account for the next block after the common point.
			if (!mHeaviestPath.empty() && commonPointAtChainProofIndex < (mHeaviestPath.size() - 1))
			{//down below we would be appending blocks starting from the next block after the common point found in the LIVE data structures.
				//if a common point was found to be in the midst of the heaviest chain-proof - we need to truncate trailing block to make the logic hold.

				mHeaviestPathDoubleGuardian.lock();//double-buffer for external queries
				mHeaviestPathDouble.erase(mHeaviestPathDouble.begin() + offset, mHeaviestPathDouble.end());//IMPORTANT: removes all blocks AFTER the common-point.
				mHeaviestPathDoubleGuardian.unlock();

				//v- IMPORTANT: removes all SHA256- values AFTER the common-point.
				mHeaviestPath.erase(mHeaviestPath.begin() + offset, mHeaviestPath.end());//LIVE data structure for local processing

				//v- IMPORTANT: removes all pre-computed PoWs AFTER the common-point.
				mHeaviestChainProofCumulativePoWs.erase(mHeaviestChainProofCumulativePoWs.begin() + offset, mHeaviestChainProofCumulativePoWs.end());//cache for PoWs (optimization)
			}

			//Update 'mHeaviestPath' AND 'mHeaviestChainProofCumulativePoWs'  - BEGIN
			//now we copy over i.e attach the new part - BEGIN
			//[IMPORTANT 1]: 'offset' was  computed to point to the block right AFTER the common-point.
			//[IMPORTANT 2]:  contents of newChainProofProposal has been already MOVED to 'chainProof. Thus, we now need to update BOTH 
			//				 'mHeaviestPath' AND 'mHeaviestChainProofCumulativePoWs' to stay in sync with 'chainProof' (which is now a REFERENCE to mHeaviestChainProof).
			mHeaviestPathDoubleGuardian.lock();//minimize duration of the time-lock so do NOT lock earlier.
			for (uint64_t i = offset; i < chainProof.size(); i++)
			{
				id = mCryptoFactory->getSHA2_256Vec(chainProof[i]);
				mHeaviestPath.push_back(id);
				mHeaviestPathDouble.push_back(id);
			}
			mHeaviestPathDoubleGuardian.unlock();
			//append to the sequence of cached cumulative PoWs

			//IMPORTANT: 'offset' has already been made to account for next block after the common point.
			for (uint64_t i = offset; i < heaviestPoWsProposal.size(); i++)//IMPORTANT: start with 'offset' NOT the common-point since we copy beginning from the very first new block. No redundancy do we want.
			{
				mHeaviestChainProofCumulativePoWs.push_back(heaviestPoWsProposal[i]);
			}


			//copy over i.e attach the new part - END

			//Update 'mHeaviestPath' AND 'mHeaviestChainProofCumulativePoWs'  - END



			if (!(mHeaviestPath.size() == mHeaviestChainProof.size() && (mHeaviestChainProof.size() == mHeaviestChainProofCumulativePoWs.size())))
			{
				getChainProof(eChainProof::heaviest, false, true);
				getPath(eChainProof::heaviest, false, false, true);

				mHeaviestChainProofCumulativePoWs = heaviestPoWsBackup;
				if (mHeaviestChainProof.size())
				{
					std::string errorI;
					CBlockHeader::eBlockHeaderInstantiationResult bhir = CBlockHeader::eBlockHeaderInstantiationResult::failure;

				}
				if (startedAnalyzingLongChainProof)
					setIsProcessingLongChainProof(false);
				tools->logEvent("Critical integrity error when updating chain-proofs. Path and Chain-Proof length do not match. Restored original ones. ", eLogEntryCategory::localSystem, 10, eLogEntryType::failure, eColor::cyborgBlood);
				if (heaviestPathGuardianLocked)
					mHeaviestPathGuardian.unlock();
				return eChainProofUpdateResult::Error;

			}

			//the following just to affect the cold-storage
			setPath(mHeaviestPath, eChainProof::heaviest, false, doColdStorage);

			//the below is optimized when accepting the entire received full chain-proof, we re-use the received PACKED
			//chain-proof as is to avoid repacking (it was accepted already, above).
			//i.e. when common-point found, i.e. when accepting a partial chain-proof - no optimization would be allowed.
			setChainProof(mHeaviestChainProof, eChainProof::heaviest, false, (commonPointAFound == true ? std::vector<uint8_t>() : receivedPackedChainProof), doColdStorage);

			// Update Heaviest Index - BEGIN
			// each time heaviest chain proof is updated we need to update the Height->BlockID index.
			if (keyLeader) {
				uint64_t startingPoint = commonPointAFound == true ? commonPointAtChainProofIndex : 0;
				for (uint64_t i = startingPoint; i < newChainProofProposal.size(); i++)
				{
					// We know the chain is valid at this point as verifyChainProof passed
					CBlockHeader::eBlockHeaderInstantiationResult instRes;
					std::string error;
					std::shared_ptr<CBlockHeader> header = CBlockHeader::instantiate(newChainProofProposal[i],
						instRes,
						error, 
						false, // prevent Merkle Patricia Tries from being instantiated
						mMode);

					if (header && header->isKeyBlock())
					{
						setBlockIDAtKeyHeight(// notice there are two indexes; one for the Heaviest and Verified chain proofs.
							header->getKeyHeight(),
							mCryptoFactory->getSHA2_256Vec(newChainProofProposal[i]),
							eChainProof::heaviest
						);
					}
				}
			}
			// Update Heaviest Index - END


			updateHeaviestPathLeaders();

			// Truncate Level 1 Block Indexes - BEGIN
			// [ Rationale ]: indexes may be out of sync after self repairs.
			// [ IMPORTANT ]: DO NOT update the Verified Chain Proof over here or any caches related to it.
			if (heaviestPathGuardianLocked && mHeaviestChainProofLeaderBlock)
			{
				assertGN(truncateKeyBlockIDsFromKeyHeight(mHeaviestChainProofLeaderBlock->getKeyHeight() + 1, eChainProof::heaviest));
			}
			// Truncate Level 1 Block Indexes - END

			setHeaviestChainProofTotalDifficulty(totalDiffOfNewChainProof);
			setHeaviestChainProofKeyLeader(keyLeader);
			setHeaviestChainProofLeadBlockID(mHeaviestPath[mHeaviestPath.size() - 1]);
			if (startedAnalyzingLongChainProof)
				setIsProcessingLongChainProof(false);


			if (heaviestPathGuardianLocked)
			{
				if (currentHeight > mHeaviestChainProof.size())
				{

					// Node is on a fork
					// TODO: Flag the fork in UI
					setSyncPercentage(101);  // special value indicating a fork. The current heaviest leader is at an actual lower height
				}
				else if (mHeaviestChainProof.size())
				{
					double percentage;
					if (mVerifiedChainProof.size() == mHeaviestChainProof.size()) {
						percentage = 100.0;
					}
					else {
						percentage = (100.0 * mVerifiedChainProof.size()) / mHeaviestChainProof.size();
						if (percentage > 99.99 && percentage < 100) {
							percentage = 99.99;
						}
					}

					setSyncPercentage(percentage);
				}
				else
				{
					setSyncPercentage(0);
				}
				mHeaviestPathGuardian.unlock();
				heaviestPathGuardianLocked = false;
			}

			//Checkpoints Support - BEGIN

			uint64_t activatedCheckpointsCount = activateCheckpoints(eChainProof::heaviest).size();
			if (activatedCheckpointsCount)
			{
				tools->logEvent("Activated " + std::to_string(activatedCheckpointsCount) + " checkpoints.", eLogEntryCategory::localSystem, 2, eLogEntryType::notification, eColor::orange);
			}
			// Checkpoints Support - END
			return eChainProofUpdateResult::updatedLocalBestKnown;
		}//Heaviest Chain-Proof - END

	}
	else
	{
		if (heaviestPathGuardianLocked)
		{
			if (mHeaviestChainProof.size())
			{
				double percentage;
				if (mVerifiedChainProof.size() == mHeaviestChainProof.size()) {
					percentage = 100.0;
				}
				else {
					percentage = (100.0 * mVerifiedChainProof.size()) / mHeaviestChainProof.size();
					if (percentage > 99.99 && percentage < 100) {
						percentage = 99.99;
					}
				}

				setSyncPercentage(percentage);
			}
			mHeaviestPathGuardian.unlock();
			heaviestPathGuardianLocked = false;
		}

		if (startedAnalyzingLongChainProof)
			setIsProcessingLongChainProof(false);
		return eChainProofUpdateResult::totalDiffLower;
	}
	if (startedAnalyzingLongChainProof)
		setIsProcessingLongChainProof(false);
	if (heaviestPathGuardianLocked)
		mHeaviestPathGuardian.unlock();
	return eChainProofUpdateResult::Error;
}

void CBlockchainManager::updateHeaviestPathLeaders()
{
	std::lock_guard<ExclusiveWorkerMutex> lock(mHeaviestPathGuardian);
	//Reported Heaviest Leaders - BEGIN
	if (!mHeaviestChainProof.empty())
	{
		std::shared_ptr<CBlockHeader> header, hpl, hpkl;
		for (uint64_t i = mHeaviestChainProof.size() - 1; i > 0; i--)
		{
			header = CBlockHeader::instantiate(mHeaviestChainProof[i]);

			if (header && !hpl)
			{//set the heaviest path leading block
				hpl = header;
				setHeaviestChainProofLeader(hpl);
			}

			if (header->isKeyBlock())
			{//set the heaviest path leading key-block
				hpkl = header;
				setHeaviestChainProofKeyLeader(hpkl);
				break;
			}

		}

	}
	//Reported Heaviest Leaders - END
}

/// <summary>
/// Sets the selected heaviest path.
/// Ensures thread-safety.
/// </summary>
/// <param name="path"></param>
/// <param name="whichOne"></param>
/// <param name="onlyColdStorage"></param>
/// <returns></returns>
bool CBlockchainManager::setPath(std::vector<std::vector<uint8_t>> path, eChainProof::eChainProof whichOne, bool onlyColdStorage, bool doColdStorage)
{
	if (whichOne == eChainProof::heaviest)
	{
		std::lock_guard<ExclusiveWorkerMutex> lock(mHeaviestPathGuardian);
		if (!onlyColdStorage)
		{
			mHeaviestPath = path;
			mHeaviestPathDoubleGuardian.lock();
			mHeaviestPathDouble = mHeaviestPath;
			mHeaviestPathDoubleGuardian.unlock();
		}

		if (doColdStorage)
		{
			mSolidStorage->saveByteVectors("heaviestPath", path);
		}
	}
	else
	{
		sync::SynchronizedLocker lock(
			mChainGuardian,           // lock1
			mVerifiedPathGuardian,    // lock2
			mLeaderGuardian           // lock3
		);

		/*Notice: we could have used an explicit locking policy as follows:
		sync::SynchronizedLocker lock(
				sync::LockingPolicy::SequenceOrdered,
				mChainGuardian,           // lock1
				mVerifiedPathGuardian,    // lock2
			   mLeaderGuardian           // lock3
		);
		*/

		if (!onlyColdStorage)
			mVerifiedPath = path;

		if (doColdStorage)
		{
			mSolidStorage->saveByteVectors("verifiedPath", path);
		}
	}


	return true;
}

/// <summary>
/// Sets the selected chain-proof.
/// Data is saved to Cold Storage.
/// Ensures thread-safety.
/// EXTREME Warning: receivedPackedChainProof is used for optimization to avoid repacking data when saved to cold storage.
/// This optimization can be used ONLY after having (externally) verified the data received.
/// NO verifications would be performed over here and it needs to be ensured that 'receivedPackedChainProof' matches  the unpacked 'proof'.
/// </summary>
/// <param name="proof"></param>
/// <param name="whichOne"></param>
/// <param name="onlyColdStorage"></param>
/// <returns></returns>
bool CBlockchainManager::setChainProof(const std::vector<std::vector<uint8_t>>& proof, eChainProof::eChainProof whichOne, bool onlyColdStorage, const std::vector<uint8_t>& receivedPackedChainProof, bool doColdStorage)
{
	if (whichOne == eChainProof::heaviest)
	{
		std::lock_guard<ExclusiveWorkerMutex> lock(mHeaviestPathGuardian);
		if (!onlyColdStorage)
		{
			setAchievablePerspectiveAtIndex(0);
			mHeaviestChainProof = proof;
			setCachedHeaviestHeight(proof.size() ? proof.size() - 1 : 0);
		}
		if (doColdStorage && !getIsRestartNeeded())
		{
			if (!receivedPackedChainProof.size())
				mSolidStorage->saveByteVectors("heaviestChainProof", proof);
			else
				mSolidStorage->saveValue("heaviestChainProof", receivedPackedChainProof);
		}

	}
	else
	{
		mChainGuardian.lock();//Lock only while data structure in hot storage is updated
		mVerifiedPathGuardian.lock();
		mLeaderGuardian.lock();

		if (!onlyColdStorage)
			mVerifiedChainProof = proof;

		mLeaderGuardian.unlock();
		mVerifiedPathGuardian.unlock();
		mChainGuardian.unlock();

		if (doColdStorage && !getIsRestartNeeded())
		{
			if (!receivedPackedChainProof.size())
				mSolidStorage->saveByteVectors("verifiedChainProof", proof);
			else
				mSolidStorage->saveValue("verifiedChainProof", receivedPackedChainProof);
		}
	}

	if (doColdStorage && !getIsRestartNeeded())
	{
		pingChainProofCSSyncTime(whichOne);
	}
	return true;
}



size_t CBlockchainManager::getTransactionMemPoolSize()
{
	return mLiveTransactionsManager->getMemPoolSize();
}

void CBlockchainManager::stop()
{
	std::lock_guard<std::recursive_mutex> lock(mGuardian);
	getTools()->writeLine(getTools()->getColoredString("Shutting-down myself NOW. \n", eColor::cyborgBlood));

	while (getIsVitalsMonitorRunning())
	{//wait for vitals monitor to shut down.
		setStatusChange(eManagerStatus::stopped);
		std::this_thread::sleep_for(std::chrono::milliseconds(100));
	}

	if (getStatus() == eManagerStatus::eManagerStatus::stopped)
		return;

	setIsVitalsMonitorToBeRunning(false);
	mVitalsMonitor.join();

	setStatusChange(eManagerStatus::eManagerStatus::stopped);
	if (!mController.joinable() && getStatus() != eManagerStatus::eManagerStatus::stopped)//controller is dead; we need first to thwart it for to enable for a state-transmission.
		mController = std::thread(&CBlockchainManager::mControllerThreadF, this);

	if (mController.get_id() != std::this_thread::get_id())
		while (getStatus() != eManagerStatus::eManagerStatus::stopped && getStatus() != eManagerStatus::eManagerStatus::initial)
		{
			std::this_thread::sleep_for(std::chrono::milliseconds(100));
		}

	if (mController.joinable() && std::this_thread::get_id() != mController.get_id())
		mController.join();

	//just to make sure

	//ACID (Flow) Managers - BEGIN
	if (mLiveTransactionsManager != nullptr)
		mLiveTransactionsManager->stop();

	if (mTerminalTransactionsManager != nullptr)
		mTerminalTransactionsManager->stop();

	if (mVerificationFlowTransactionsManager != nullptr)
		mVerificationFlowTransactionsManager->stop();

	if (mBlockFormationFlowManager != nullptr)
		mBlockFormationFlowManager->stop();
	//ACID (Flow) Managers - END

	if (mNetworkManager != nullptr)
		mNetworkManager->stop();

	if (mWorkManager != nullptr)
		mWorkManager->stop();

	if (mTests != nullptr)
	{
		mTests->stop();
		mTests = nullptr;
	}

	mWorkManager = nullptr;

	getTools()->writeLine("Blockchain Manager killed;");
}

void CBlockchainManager::pause()
{
	if (getStatus() == eManagerStatus::eManagerStatus::paused)
		return;

	std::shared_ptr<CTransactionManager> verificationFlowManager = getVerificationFlowManager();
	std::shared_ptr<CTransactionManager> formationFlowManager = getFormationFlowManager();
	//halt all the intrinsic sub-systems
	verificationFlowManager->pause();
	formationFlowManager->pause();

	if (mNetworkManager != nullptr)
		mNetworkManager->pause();

	//finally pause the Blockchain Manager itself
	setStatusChange(eManagerStatus::eManagerStatus::paused);
	if (!mController.joinable() && getStatus() != eManagerStatus::eManagerStatus::paused)//controller is dead; we need first to thwart it for to enable for a state-transmission.
		mController = std::thread(&CBlockchainManager::mControllerThreadF, this);

	while (getStatus() != eManagerStatus::eManagerStatus::paused && getStatus() != eManagerStatus::eManagerStatus::initial)
	{
		std::this_thread::sleep_for(std::chrono::milliseconds(100));
	}
}

void CBlockchainManager::resume()
{
	if (getStatus() == eManagerStatus::eManagerStatus::running)
		return;

	std::shared_ptr<CTransactionManager> verificationFlowManager = getVerificationFlowManager();
	std::shared_ptr<CTransactionManager> formationFlowManager = getVerificationFlowManager();
	setStatusChange(eManagerStatus::eManagerStatus::running);
	if (!mController.joinable() && getStatus() != eManagerStatus::eManagerStatus::running)//controller is dead; we need first to thwart it for to enable for a state-transmission.
		mController = std::thread(&CBlockchainManager::mControllerThreadF, this);

	verificationFlowManager->resume();
	formationFlowManager->resume();

	if (mNetworkManager != nullptr)
		mNetworkManager->resume();

	if (mController.get_id() != std::this_thread::get_id())
		while (getStatus() != eManagerStatus::eManagerStatus::running && getStatus() != eManagerStatus::eManagerStatus::initial)
		{
			std::this_thread::sleep_for(std::chrono::milliseconds(100));
		}
}

eManagerStatus::eManagerStatus CBlockchainManager::getStatus()
{
	std::lock_guard<std::recursive_mutex> lock(mStatusGuardian);
	return mStatus;
}

void CBlockchainManager::setStatus(eManagerStatus::eManagerStatus status)
{
	std::lock_guard<std::recursive_mutex> lock(mStatusGuardian);
	if (mStatus == status)
		return;
	mStatus = status;
	switch (status)
	{
	case eManagerStatus::eManagerStatus::running:

		getTools()->writeLine("I'm now running");
		break;
	case eManagerStatus::eManagerStatus::paused:
		getTools()->writeLine(" is now paused");
		break;
	case eManagerStatus::eManagerStatus::stopped:
		getTools()->writeLine("I'm now stopped");
		break;
	default:
		getTools()->writeLine("I'm nowin an unknown state;/");
		break;
	}
}

void CBlockchainManager::requestStatusChange(eManagerStatus::eManagerStatus status)
{
	std::lock_guard<std::mutex> lock(mStatusChangeGuardian);
	mStatusChange = status;
}

eManagerStatus::eManagerStatus CBlockchainManager::getRequestedStatusChange()
{
	std::lock_guard<std::mutex> lock(mStatusChangeGuardian);
	return mStatusChange;
}

/// <summary>
/// Verifies a sequence of block identifiers locally and co-operatively.
/// Ensures that hard-coded check-points are present within the path.
/// Note: for use only with full paths. (ones in which the first element is the Genesis Block)
/// </summary>
/// <param name="path"></param>
/// <returns></returns>
/*bool CBlockchainManager::verifyPath(std::vector<std::vector<uint8_t>> path)
{
	std::lock_guard<std::recursive_mutex> lock(mGuardian);
	std::vector<CBCheckpoint> checkpoints;
	CGlobalSecSettings sec;
	checkpoints = sec.getBCheckpoints();
	//verify locally, check hard-coded checkpoints
	for (int i = 0; i < checkpoints.size(); i++)
	{
		if (path.size() < checkpoints[i].getHeight())
			return false;
		if (path[i].size() != 32 || checkpoints[i].getHash().size() != 32)
			return false;
		if (std::memcmp(path[i].data(), checkpoints[i].getHash().data(), 32) != 0)
			return false;
	}
	return false;
	//P2P verification
}*/
